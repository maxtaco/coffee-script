/**
 * IcedCoffeeScript Compiler v108.0.15
 * http://iced-coffee-script.github.io/iced-coffee-script
 *
 * Copyright 2011, Jeremy Ashkenas, Maxwell Krohn
 * Released under the MIT License
 */
(function(root){
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.CoffeeScript = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  var CoffeeScript, compile, runScripts,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  CoffeeScript = require('./coffee-script');

  CoffeeScript.require = require;

  compile = CoffeeScript.compile;

  CoffeeScript["eval"] = function(code, options) {
    if (options == null) {
      options = {};
    }
    if (options.bare == null) {
      options.bare = true;
    }
    return eval(compile(code, options));
  };

  CoffeeScript.run = function(code, options) {
    if (options == null) {
      options = {};
    }
    options.bare = true;
    options.shiftLine = true;
    return Function(compile(code, options))();
  };

  if (typeof window === "undefined" || window === null) {
    return;
  }

  if ((typeof btoa !== "undefined" && btoa !== null) && (typeof JSON !== "undefined" && JSON !== null) && (typeof unescape !== "undefined" && unescape !== null) && (typeof encodeURIComponent !== "undefined" && encodeURIComponent !== null)) {
    compile = function(code, options) {
      var js, v3SourceMap, _ref;
      if (options == null) {
        options = {};
      }
      options.sourceMap = true;
      options.inline = true;
      _ref = CoffeeScript.compile(code, options), js = _ref.js, v3SourceMap = _ref.v3SourceMap;
      return "" + js + "\n//# sourceMappingURL=data:application/json;base64," + (btoa(unescape(encodeURIComponent(v3SourceMap)))) + "\n//# sourceURL=coffeescript";
    };
  }

  CoffeeScript.load = function(url, callback, options, hold) {
    var xhr;
    if (options == null) {
      options = {};
    }
    if (hold == null) {
      hold = false;
    }
    options.sourceFiles = [url];
    xhr = window.ActiveXObject ? new window.ActiveXObject('Microsoft.XMLHTTP') : new window.XMLHttpRequest();
    xhr.open('GET', url, true);
    if ('overrideMimeType' in xhr) {
      xhr.overrideMimeType('text/plain');
    }
    xhr.onreadystatechange = function() {
      var param, _ref;
      if (xhr.readyState === 4) {
        if ((_ref = xhr.status) === 0 || _ref === 200) {
          param = [xhr.responseText, options];
          if (!hold) {
            CoffeeScript.run.apply(CoffeeScript, param);
          }
        } else {
          throw new Error("Could not load " + url);
        }
        if (callback) {
          return callback(param);
        }
      }
    };
    return xhr.send(null);
  };

  runScripts = function() {
    var coffees, coffeetypes, execute, i, index, s, script, scripts, _fn, _i, _len;
    scripts = window.document.getElementsByTagName('script');
    coffeetypes = ['text/coffeescript', 'text/literate-coffeescript'];
    coffees = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = scripts.length; _i < _len; _i++) {
        s = scripts[_i];
        if (_ref = s.type, __indexOf.call(coffeetypes, _ref) >= 0) {
          _results.push(s);
        }
      }
      return _results;
    })();
    index = 0;
    execute = function() {
      var param;
      param = coffees[index];
      if (param instanceof Array) {
        CoffeeScript.run.apply(CoffeeScript, param);
        index++;
        return execute();
      }
    };
    _fn = function(script, i) {
      var options;
      options = {
        literate: script.type === coffeetypes[1]
      };
      if (script.src) {
        return CoffeeScript.load(script.src, function(param) {
          coffees[i] = param;
          return execute();
        }, options, true);
      } else {
        options.sourceFiles = ['embedded'];
        return coffees[i] = [script.innerHTML, options];
      }
    };
    for (i = _i = 0, _len = coffees.length; _i < _len; i = ++_i) {
      script = coffees[i];
      _fn(script, i);
    }
    return execute();
  };

  if (window.addEventListener) {
    window.addEventListener('DOMContentLoaded', runScripts, false);
  } else {
    window.attachEvent('onload', runScripts);
  }

  window.iced = CoffeeScript.iced;

  module.exports = CoffeeScript;

}).call(this);

},{"./coffee-script":2}],2:[function(require,module,exports){
(function (process,global){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  var ANONYMOUS_TAG, Lexer, SourceMap, compile, ext, formatSourcePosition, fs, getSourceMap, helpers, iced_runtime, iced_transform, lexer, parser, path, prepareStackTrace, sourceMaps, source_map_support_lazy, sources, vm, withPrettyErrors, _base, _i, _len, _ref,
    __hasProp = {}.hasOwnProperty;

  fs = require('fs');

  vm = require('vm');

  path = require('path');

  Lexer = require('./lexer').Lexer;

  parser = require('./parser').parser;

  helpers = require('./helpers');

  SourceMap = require('./sourcemap').SourceMap;

  iced_transform = require('./iced').transform;

  iced_runtime = require('iced-runtime');

  source_map_support_lazy = function() {
    return require('source-map-support');
  };

  exports.VERSION = '108.0.15';

  exports.FILE_EXTENSIONS = ['.coffee', '.litcoffee', '.coffee.md', '.iced', '.liticed', '.iced.md'];

  exports.helpers = helpers;

  withPrettyErrors = function(fn) {
    return function(code, options) {
      var err;
      if (options == null) {
        options = {};
      }
      try {
        return fn.call(this, code, options);
      } catch (_error) {
        err = _error;
        throw helpers.updateSyntaxError(err, code, options.filename);
      }
    };
  };

  sources = {};

  sourceMaps = {};

  ANONYMOUS_TAG = '<anonymous iced>';

  exports.compile = compile = withPrettyErrors(function(code, options) {
    var currentColumn, currentLine, encoded, extend, filename, fragment, fragments, generateSourceMap, header, js, map, merge, newLines, sourceMapDataURI, sourceURL, v3SourceMap, _i, _len, _ref;
    merge = helpers.merge, extend = helpers.extend;
    options = extend({}, options);
    generateSourceMap = options.sourceMap || options.inlineMap || (options.filename == null);
    filename = options.filename || ANONYMOUS_TAG;
    sources[filename] = code;
    if (generateSourceMap) {
      map = new SourceMap;
    }
    fragments = (iced_transform(parser.parse(lexer.tokenize(code, options)), options)).compileToFragments(options);
    currentLine = 0;
    if (options.header) {
      currentLine += 1;
    }
    if (options.shiftLine) {
      currentLine += 1;
    }
    currentColumn = 0;
    js = "";
    for (_i = 0, _len = fragments.length; _i < _len; _i++) {
      fragment = fragments[_i];
      if (generateSourceMap) {
        if (fragment.locationData) {
          map.add([fragment.locationData.first_line, fragment.locationData.first_column], [currentLine, currentColumn], {
            noReplace: true
          });
        }
        newLines = helpers.count(fragment.code, "\n");
        currentLine += newLines;
        if (newLines) {
          currentColumn = fragment.code.length - (fragment.code.lastIndexOf("\n") + 1);
        } else {
          currentColumn += fragment.code.length;
        }
      }
      js += fragment.code;
    }
    if (options.header) {
      header = "Generated by IcedCoffeeScript " + this.VERSION;
      js = "// " + header + "\n" + js;
    }
    if (generateSourceMap) {
      options.sourceFiles = [filename];
      v3SourceMap = map.generate(options, code);
      sourceMaps[filename] = {
        map: map,
        v3SourceMap: v3SourceMap
      };
    }
    if (options.inlineMap) {
      encoded = base64encode(JSON.stringify(v3SourceMap));
      sourceMapDataURI = "//# sourceMappingURL=data:application/json;base64," + encoded;
      sourceURL = "//# sourceURL=" + ((_ref = options.filename) != null ? _ref : 'iced-coffee-script');
      js = "" + js + "\n" + sourceMapDataURI + "\n" + sourceURL;
    }
    if (options.sourceMap) {
      return {
        js: js,
        sourceMap: map,
        v3SourceMap: JSON.stringify(v3SourceMap, null, 2)
      };
    } else {
      return js;
    }
  });

  exports.tokens = withPrettyErrors(function(code, options) {
    return lexer.tokenize(code, options);
  });

  exports.nodes = withPrettyErrors(function(source, options) {
    var ast;
    if (typeof source === 'string') {
      ast = parser.parse(lexer.tokenize(source, options));
    } else {
      ast = parser.parse(source);
    }
    if (!options.noIcedTransform) {
      ast = iced_transform(ast, options);
    }
    return ast;
  });

  exports.run = function(code, options) {
    var answer, dir, mainModule, _ref;
    if (options == null) {
      options = {};
    }
    mainModule = require.main;
    mainModule.filename = process.argv[1] = options.filename ? fs.realpathSync(options.filename) : ANONYMOUS_TAG;
    mainModule.moduleCache && (mainModule.moduleCache = {});
    dir = options.filename ? path.dirname(fs.realpathSync(options.filename)) : fs.realpathSync('.');
    mainModule.paths = require('module')._nodeModulePaths(dir);
    if (!helpers.isCoffee(mainModule.filename) || require.extensions) {
      options.runtime = "interp";
      answer = compile(code, options);
      code = (_ref = answer.js) != null ? _ref : answer;
    }
    return mainModule._compile(code, mainModule.filename);
  };

  exports["eval"] = function(code, options) {
    var Module, Script, js, k, o, r, sandbox, v, _i, _len, _module, _ref, _ref1, _require;
    if (options == null) {
      options = {};
    }
    if (!(code = code.trim())) {
      return;
    }
    Script = vm.Script;
    if (Script) {
      if (options.sandbox != null) {
        if (options.sandbox instanceof Script.createContext().constructor) {
          sandbox = options.sandbox;
        } else {
          sandbox = Script.createContext();
          _ref = options.sandbox;
          for (k in _ref) {
            if (!__hasProp.call(_ref, k)) continue;
            v = _ref[k];
            sandbox[k] = v;
          }
        }
        sandbox.global = sandbox.root = sandbox.GLOBAL = sandbox;
      } else {
        sandbox = global;
      }
      sandbox.__filename = options.filename || 'eval';
      sandbox.__dirname = path.dirname(sandbox.__filename);
      if (!(sandbox !== global || sandbox.module || sandbox.require)) {
        Module = require('module');
        sandbox.module = _module = new Module(options.modulename || 'eval');
        sandbox.require = _require = function(path) {
          return Module._load(path, _module, true);
        };
        _module.filename = sandbox.__filename;
        _ref1 = Object.getOwnPropertyNames(require);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          r = _ref1[_i];
          if (r !== 'paths') {
            _require[r] = require[r];
          }
        }
        _require.paths = _module.paths = Module._nodeModulePaths(process.cwd());
        _require.resolve = function(request) {
          return Module._resolveFilename(request, _module);
        };
      }
    }
    o = {};
    for (k in options) {
      if (!__hasProp.call(options, k)) continue;
      v = options[k];
      o[k] = v;
    }
    o.bare = true;
    js = compile(code, o);
    if (sandbox === global) {
      return vm.runInThisContext(js);
    } else {
      return vm.runInContext(js, sandbox);
    }
  };

  exports.register = function() {
    return require('./register');
  };

  if (require.extensions) {
    _ref = this.FILE_EXTENSIONS;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ext = _ref[_i];
      if ((_base = require.extensions)[ext] == null) {
        _base[ext] = function() {
          throw new Error("Use CoffeeScript.register() or require the coffee-script/register module to require " + ext + " files.");
        };
      }
    }
  }

  exports._compileFile = function(filename, sourceMap, opts_passed) {
    var answer, err, k, opts, raw, stripped, v;
    if (sourceMap == null) {
      sourceMap = false;
    }
    if (opts_passed == null) {
      opts_passed = {};
    }
    raw = fs.readFileSync(filename, 'utf8');
    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
    opts = {
      filename: filename,
      sourceMap: sourceMap,
      literate: helpers.isLiterate(filename)
    };
    for (k in opts_passed) {
      v = opts_passed[k];
      opts[k] = v;
    }
    try {
      answer = compile(stripped, opts);
    } catch (_error) {
      err = _error;
      throw helpers.updateSyntaxError(err, stripped, filename);
    }
    return answer;
  };

  lexer = new Lexer;

  parser.lexer = {
    lex: function() {
      var tag, token;
      token = this.tokens[this.pos++];
      if (token) {
        tag = token[0], this.yytext = token[1], this.yylloc = token[2];
        this.errorToken = token.origin || token;
        this.yylineno = this.yylloc.first_line;
      } else {
        tag = '';
      }
      return tag;
    },
    setInput: function(tokens) {
      this.tokens = tokens;
      return this.pos = 0;
    },
    upcomingInput: function() {
      return "";
    }
  };

  parser.yy = require('./nodes');

  exports.iced = iced_runtime;

  parser.yy.parseError = function(message, _arg) {
    var errorLoc, errorTag, errorText, errorToken, token, tokens, _ref1;
    token = _arg.token;
    _ref1 = parser.lexer, errorToken = _ref1.errorToken, tokens = _ref1.tokens;
    errorTag = errorToken[0], errorText = errorToken[1], errorLoc = errorToken[2];
    errorText = errorToken === tokens[tokens.length - 1] ? 'end of input' : errorTag === 'INDENT' || errorTag === 'OUTDENT' ? 'indentation' : helpers.nameWhitespaceCharacter(errorText);
    return helpers.throwSyntaxError("unexpected " + errorText, errorLoc);
  };

  formatSourcePosition = function(frame, getSourceMapping) {
    var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
    fileName = void 0;
    fileLocation = '';
    if (frame.isNative()) {
      fileLocation = "native";
    } else {
      if (frame.isEval()) {
        fileName = frame.getScriptNameOrSourceURL();
        if (!fileName) {
          fileLocation = "" + (frame.getEvalOrigin()) + ", ";
        }
      } else {
        fileName = frame.getFileName();
      }
      fileName || (fileName = "<anonymous>");
      line = frame.getLineNumber();
      column = frame.getColumnNumber();
      source = getSourceMapping(fileName, line, column);
      fileLocation = source ? "" + fileName + ":" + source[0] + ":" + source[1] : "" + fileName + ":" + line + ":" + column;
    }
    functionName = frame.getFunctionName();
    isConstructor = frame.isConstructor();
    isMethodCall = !(frame.isToplevel() || isConstructor);
    if (isMethodCall) {
      methodName = frame.getMethodName();
      typeName = frame.getTypeName();
      if (functionName) {
        tp = as = '';
        if (typeName && functionName.indexOf(typeName)) {
          tp = "" + typeName + ".";
        }
        if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
          as = " [as " + methodName + "]";
        }
        return "" + tp + functionName + as + " (" + fileLocation + ")";
      } else {
        return "" + typeName + "." + (methodName || '<anonymous>') + " (" + fileLocation + ")";
      }
    } else if (isConstructor) {
      return "new " + (functionName || '<anonymous>') + " (" + fileLocation + ")";
    } else if (functionName) {
      return "" + functionName + " (" + fileLocation + ")";
    } else {
      return fileLocation;
    }
  };

  getSourceMap = function(filename, defaultAnonymous) {
    var anonMap, answer;
    if (defaultAnonymous == null) {
      defaultAnonymous = false;
    }
    if (sourceMaps[filename] != null) {
      return sourceMaps[filename];
    } else if (defaultAnonymous && ((anonMap = sourceMaps[ANONYMOUS_TAG]) != null)) {
      return anonMap;
    } else if (sources[filename] != null) {
      answer = compile(sources[filename], {
        filename: filename,
        sourceMap: true,
        literate: helpers.isLiterate(filename)
      });
      return answer;
    } else {
      return null;
    }
  };

  prepareStackTrace = function(err, stack) {
    var frame, frames, getSourceMapping;
    getSourceMapping = function(filename, line, column) {
      var answer, sourceMap;
      sourceMap = getSourceMap(filename, true);
      if (sourceMap) {
        answer = sourceMap.map.sourceLocation([line - 1, column - 1]);
      }
      if (answer) {
        return [answer[0] + 1, answer[1] + 1];
      } else {
        return null;
      }
    };
    frames = (function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = stack.length; _j < _len1; _j++) {
        frame = stack[_j];
        if (frame.getFunction() === exports.run) {
          break;
        }
        _results.push("  at " + (formatSourcePosition(frame, getSourceMapping)));
      }
      return _results;
    })();
    return "" + (err.toString()) + "\n" + (frames.join('\n')) + "\n";
  };

  exports.installPrepareStackTrace = function() {
    return Error.prepareStackTrace = prepareStackTrace;
  };

  exports.installSourceMapSupport = function(opts, sourceMapSupport) {
    opts.retrieveSourceMap = function(filename) {
      var sourceMap;
      sourceMap = getSourceMap(filename);
      if (sourceMap) {
        return {
          map: sourceMap.v3SourceMap
        };
      } else {
        return null;
      }
    };
    return (sourceMapSupport != null ? sourceMapSupport : source_map_support_lazy()).install(opts);
  };

}).call(this);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./helpers":3,"./iced":4,"./lexer":5,"./nodes":6,"./parser":7,"./register":8,"./sourcemap":11,"_process":22,"fs":13,"iced-runtime":18,"module":13,"path":21,"source-map-support":34,"vm":35}],3:[function(require,module,exports){
(function (process){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  var buildLocationData, extend, flatten, last, repeat, syntaxErrorToString, _ref;

  exports.starts = function(string, literal, start) {
    return literal === string.substr(start, literal.length);
  };

  exports.ends = function(string, literal, back) {
    var len;
    len = literal.length;
    return literal === string.substr(string.length - len - (back || 0), len);
  };

  exports.repeat = repeat = function(str, n) {
    var res;
    res = '';
    while (n > 0) {
      if (n & 1) {
        res += str;
      }
      n >>>= 1;
      str += str;
    }
    return res;
  };

  exports.compact = function(array) {
    var item, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (item) {
        _results.push(item);
      }
    }
    return _results;
  };

  exports.count = function(string, substr) {
    var num, pos;
    num = pos = 0;
    if (!substr.length) {
      return 1 / 0;
    }
    while (pos = 1 + string.indexOf(substr, pos)) {
      num++;
    }
    return num;
  };

  exports.merge = function(options, overrides) {
    return extend(extend({}, options), overrides);
  };

  extend = exports.extend = function(object, properties) {
    var key, val;
    for (key in properties) {
      val = properties[key];
      object[key] = val;
    }
    return object;
  };

  exports.flatten = flatten = function(array) {
    var element, flattened, _i, _len;
    flattened = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      element = array[_i];
      if (element instanceof Array) {
        flattened = flattened.concat(flatten(element));
      } else {
        flattened.push(element);
      }
    }
    return flattened;
  };

  exports.del = function(obj, key) {
    var val;
    val = obj[key];
    delete obj[key];
    return val;
  };

  exports.last = last = function(array, back) {
    return array[array.length - (back || 0) - 1];
  };

  exports.some = (_ref = Array.prototype.some) != null ? _ref : function(fn) {
    var e, _i, _len;
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      e = this[_i];
      if (fn(e)) {
        return true;
      }
    }
    return false;
  };

  exports.invertLiterate = function(code) {
    var line, lines, maybe_code;
    maybe_code = true;
    lines = (function() {
      var _i, _len, _ref1, _results;
      _ref1 = code.split('\n');
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        line = _ref1[_i];
        if (maybe_code && /^([ ]{4}|[ ]{0,3}\t)/.test(line)) {
          _results.push(line);
        } else if (maybe_code = /^\s*$/.test(line)) {
          _results.push(line);
        } else {
          _results.push('# ' + line);
        }
      }
      return _results;
    })();
    return lines.join('\n');
  };

  buildLocationData = function(first, last) {
    if (!last) {
      return first;
    } else {
      return {
        first_line: first.first_line,
        first_column: first.first_column,
        last_line: last.last_line,
        last_column: last.last_column
      };
    }
  };

  exports.addLocationDataFn = function(first, last) {
    return function(obj) {
      if (((typeof obj) === 'object') && (!!obj['updateLocationDataIfMissing'])) {
        obj.updateLocationDataIfMissing(buildLocationData(first, last));
      }
      return obj;
    };
  };

  exports.locationDataToString = function(obj) {
    var locationData;
    if (("2" in obj) && ("first_line" in obj[2])) {
      locationData = obj[2];
    } else if ("first_line" in obj) {
      locationData = obj;
    }
    if (locationData) {
      return ("" + (locationData.first_line + 1) + ":" + (locationData.first_column + 1) + "-") + ("" + (locationData.last_line + 1) + ":" + (locationData.last_column + 1));
    } else {
      return "No location data";
    }
  };

  exports.baseFileName = function(file, stripExt, useWinPathSep) {
    var parts, pathSep;
    if (stripExt == null) {
      stripExt = false;
    }
    if (useWinPathSep == null) {
      useWinPathSep = false;
    }
    pathSep = useWinPathSep ? /\\|\// : /\//;
    parts = file.split(pathSep);
    file = parts[parts.length - 1];
    if (!(stripExt && file.indexOf('.') >= 0)) {
      return file;
    }
    parts = file.split('.');
    parts.pop();
    if (parts[parts.length - 1] === 'coffee' && parts.length > 1) {
      parts.pop();
    }
    return parts.join('.');
  };

  exports.isCoffee = function(file) {
    return /\.((lit)?coffee|coffee\.md|iced|liticed|iced\.md)$/.test(file);
  };

  exports.isLiterate = function(file) {
    return /\.(litcoffee|coffee\.md|liticed|iced\.md)$/.test(file);
  };

  exports.throwSyntaxError = function(message, location) {
    var error;
    error = new SyntaxError(message);
    error.location = location;
    error.toString = syntaxErrorToString;
    error.stack = error.toString();
    throw error;
  };

  exports.updateSyntaxError = function(error, code, filename) {
    if (error.toString === syntaxErrorToString) {
      error.code || (error.code = code);
      error.filename || (error.filename = filename);
      error.stack = error.toString();
    }
    return error;
  };

  syntaxErrorToString = function() {
    var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, start, _ref1, _ref2;
    if (!(this.code && this.location)) {
      return Error.prototype.toString.call(this);
    }
    _ref1 = this.location, first_line = _ref1.first_line, first_column = _ref1.first_column, last_line = _ref1.last_line, last_column = _ref1.last_column;
    if (last_line == null) {
      last_line = first_line;
    }
    if (last_column == null) {
      last_column = first_column;
    }
    filename = this.filename || '[stdin]';
    codeLine = this.code.split('\n')[first_line];
    start = first_column;
    end = first_line === last_line ? last_column + 1 : codeLine.length;
    marker = codeLine.slice(0, start).replace(/[^\s]/g, ' ') + repeat('^', end - start);
    if ((typeof process !== "undefined" && process !== null ? process.stdout : void 0) != null) {
      colorsEnabled = process.stdout.isTTY && !process.env.NODE_DISABLE_COLORS;
    }
    if ((_ref2 = this.colorful) != null ? _ref2 : colorsEnabled) {
      colorize = function(str) {
        return "\x1B[1;31m" + str + "\x1B[0m";
      };
      codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
      marker = colorize(marker);
    }
    return "" + filename + ":" + (first_line + 1) + ":" + (first_column + 1) + ": error: " + this.message + "\n" + codeLine + "\n" + marker;
  };

  exports.nameWhitespaceCharacter = function(string) {
    switch (string) {
      case ' ':
        return 'space';
      case '\n':
        return 'newline';
      case '\r':
        return 'carriage return';
      case '\t':
        return 'tab';
      default:
        return string;
    }
  };

}).call(this);

}).call(this,require('_process'))
},{"_process":22}],4:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  exports.transform = function(x, options) {
    return x.icedTransform(options);
  };

  exports.runtime = require('iced-runtime');

}).call(this);

},{"iced-runtime":18}],5:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HEREDOC, HEREDOC_ILLEGAL, HEREDOC_INDENT, HEREGEX, HEREGEX_OMIT, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INVERSES, JSTOKEN, JS_FORBIDDEN, JS_KEYWORDS, LINE_BREAK, LINE_CONTINUER, LOGIC, Lexer, MATH, MULTILINER, MULTI_DENT, NOT_REGEX, NOT_SPACED_REGEX, NUMBER, OPERATOR, REGEX, RELATION, RESERVED, Rewriter, SHIFT, SIMPLESTR, STRICT_PROSCRIBED, TRAILING_SPACES, UNARY, UNARY_MATH, WHITESPACE, compact, count, invertLiterate, key, last, locationDataToString, repeat, starts, throwSyntaxError, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('./rewriter'), Rewriter = _ref.Rewriter, INVERSES = _ref.INVERSES;

  _ref1 = require('./helpers'), count = _ref1.count, starts = _ref1.starts, compact = _ref1.compact, last = _ref1.last, repeat = _ref1.repeat, invertLiterate = _ref1.invertLiterate, locationDataToString = _ref1.locationDataToString, throwSyntaxError = _ref1.throwSyntaxError;

  exports.Lexer = Lexer = (function() {
    function Lexer() {}

    Lexer.prototype.tokenize = function(code, opts) {
      var consumed, i, tag, _ref2;
      if (opts == null) {
        opts = {};
      }
      this.literate = opts.literate;
      this.indent = 0;
      this.baseIndent = 0;
      this.indebt = 0;
      this.outdebt = 0;
      this.indents = [];
      this.ends = [];
      this.tokens = [];
      this.chunkLine = opts.line || 0;
      this.chunkColumn = opts.column || 0;
      code = this.clean(code);
      i = 0;
      while (this.chunk = code.slice(i)) {
        consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.heredocToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();
        _ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = _ref2[0], this.chunkColumn = _ref2[1];
        i += consumed;
      }
      this.closeIndentation();
      if (tag = this.ends.pop()) {
        this.error("missing " + tag);
      }
      if (opts.rewrite === false) {
        return this.tokens;
      }
      return (new Rewriter).rewrite(this.tokens);
    };

    Lexer.prototype.clean = function(code) {
      if (code.charCodeAt(0) === BOM) {
        code = code.slice(1);
      }
      code = code.replace(/\r/g, '').replace(TRAILING_SPACES, '');
      if (WHITESPACE.test(code)) {
        code = "\n" + code;
        this.chunkLine--;
      }
      if (this.literate) {
        code = invertLiterate(code);
      }
      return code;
    };

    Lexer.prototype.identifierToken = function() {
      var colon, colonOffset, forcedIdentifier, id, idLength, input, match, poppedToken, prev, tag, tagToken, _ref2, _ref3, _ref4;
      if (!(match = IDENTIFIER.exec(this.chunk))) {
        return 0;
      }
      input = match[0], id = match[1], colon = match[2];
      idLength = id.length;
      poppedToken = void 0;
      if (id === 'own' && this.tag() === 'FOR') {
        this.token('OWN', id);
        return id.length;
      }
      if (id === 'from' && this.tag() === 'YIELD') {
        this.token('FROM', id);
        return id.length;
      }
      forcedIdentifier = colon || (prev = last(this.tokens)) && (((_ref2 = prev[0]) === '.' || _ref2 === '?.' || _ref2 === '::' || _ref2 === '?::') || !prev.spaced && prev[0] === '@') && id !== 'defer';
      tag = 'IDENTIFIER';
      if (!forcedIdentifier && (__indexOf.call(JS_KEYWORDS, id) >= 0 || __indexOf.call(COFFEE_KEYWORDS, id) >= 0)) {
        tag = id.toUpperCase();
        if (tag === 'WHEN' && (_ref3 = this.tag(), __indexOf.call(LINE_BREAK, _ref3) >= 0)) {
          tag = 'LEADING_WHEN';
        } else if (tag === 'FOR') {
          this.seenFor = true;
        } else if (tag === 'UNLESS') {
          tag = 'IF';
        } else if (__indexOf.call(UNARY, tag) >= 0) {
          tag = 'UNARY';
        } else if (__indexOf.call(RELATION, tag) >= 0) {
          if (tag !== 'INSTANCEOF' && this.seenFor) {
            tag = 'FOR' + tag;
            this.seenFor = false;
          } else {
            tag = 'RELATION';
            if (this.value() === '!') {
              poppedToken = this.tokens.pop();
              id = '!' + id;
            }
          }
        }
      }
      if (__indexOf.call(JS_FORBIDDEN, id) >= 0) {
        if (forcedIdentifier) {
          tag = 'IDENTIFIER';
          id = new String(id);
          id.reserved = true;
        } else if (__indexOf.call(RESERVED, id) >= 0) {
          this.error("reserved word \"" + id + "\"");
        }
      }
      if (!forcedIdentifier) {
        if (__indexOf.call(COFFEE_ALIASES, id) >= 0) {
          id = COFFEE_ALIAS_MAP[id];
        }
        tag = (function() {
          switch (id) {
            case '!':
              return 'UNARY';
            case '==':
            case '!=':
              return 'COMPARE';
            case '&&':
            case '||':
              return 'LOGIC';
            case 'true':
            case 'false':
              return 'BOOL';
            case 'break':
            case 'continue':
              return 'STATEMENT';
            default:
              return tag;
          }
        })();
      }
      tagToken = this.token(tag, id, 0, idLength);
      if (poppedToken) {
        _ref4 = [poppedToken[2].first_line, poppedToken[2].first_column], tagToken[2].first_line = _ref4[0], tagToken[2].first_column = _ref4[1];
      }
      if (colon) {
        colonOffset = input.lastIndexOf(':');
        this.token(':', ':', colonOffset, colon.length);
      }
      return input.length;
    };

    Lexer.prototype.numberToken = function() {
      var binaryLiteral, lexedLength, match, number, octalLiteral;
      if (!(match = NUMBER.exec(this.chunk))) {
        return 0;
      }
      number = match[0];
      if (/^0[BOX]/.test(number)) {
        this.error("radix prefix '" + number + "' must be lowercase");
      } else if (/E/.test(number) && !/^0x/.test(number)) {
        this.error("exponential notation '" + number + "' must be indicated with a lowercase 'e'");
      } else if (/^0\d*[89]/.test(number)) {
        this.error("decimal literal '" + number + "' must not be prefixed with '0'");
      } else if (/^0\d+/.test(number)) {
        this.error("octal literal '" + number + "' must be prefixed with '0o'");
      }
      lexedLength = number.length;
      if (octalLiteral = /^0o([0-7]+)/.exec(number)) {
        number = '0x' + parseInt(octalLiteral[1], 8).toString(16);
      }
      if (binaryLiteral = /^0b([01]+)/.exec(number)) {
        number = '0x' + parseInt(binaryLiteral[1], 2).toString(16);
      }
      this.token('NUMBER', number, 0, lexedLength);
      return lexedLength;
    };

    Lexer.prototype.stringToken = function() {
      var inner, innerLen, numBreak, octalEsc, pos, quote, string, trimmed;
      switch (quote = this.chunk.charAt(0)) {
        case "'":
          string = (SIMPLESTR.exec(this.chunk) || [])[0];
          break;
        case '"':
          string = this.balancedString(this.chunk, '"');
      }
      if (!string) {
        return 0;
      }
      inner = string.slice(1, -1);
      trimmed = this.removeNewlines(inner);
      if (quote === '"' && 0 < string.indexOf('#{', 1)) {
        numBreak = pos = 0;
        innerLen = inner.length;
        while (inner.charAt(pos++) === '\n' && pos < innerLen) {
          numBreak++;
        }
        this.interpolateString(trimmed, {
          strOffset: 1 + numBreak,
          lexedLength: string.length
        });
      } else {
        this.token('STRING', quote + this.escapeLines(trimmed) + quote, 0, string.length);
      }
      if (octalEsc = /^(?:\\.|[^\\])*\\(?:0[0-7]|[1-7])/.test(string)) {
        this.error("octal escape sequences " + string + " are not allowed");
      }
      return string.length;
    };

    Lexer.prototype.heredocToken = function() {
      var doc, heredoc, match, quote, strOffset;
      if (!(match = HEREDOC.exec(this.chunk))) {
        return 0;
      }
      heredoc = match[0];
      quote = heredoc.charAt(0);
      doc = this.sanitizeHeredoc(match[2], {
        quote: quote,
        indent: null
      });
      if (quote === '"' && 0 <= doc.indexOf('#{')) {
        strOffset = match[2].charAt(0) === '\n' ? 4 : 3;
        this.interpolateString(doc, {
          heredoc: true,
          strOffset: strOffset,
          lexedLength: heredoc.length
        });
      } else {
        this.token('STRING', this.makeString(doc, quote, true), 0, heredoc.length);
      }
      return heredoc.length;
    };

    Lexer.prototype.commentToken = function() {
      var comment, here, match;
      if (!(match = this.chunk.match(COMMENT))) {
        return 0;
      }
      comment = match[0], here = match[1];
      if (here) {
        this.token('HERECOMMENT', this.sanitizeHeredoc(here, {
          herecomment: true,
          indent: repeat(' ', this.indent)
        }), 0, comment.length);
      }
      return comment.length;
    };

    Lexer.prototype.jsToken = function() {
      var match, script;
      if (!(this.chunk.charAt(0) === '`' && (match = JSTOKEN.exec(this.chunk)))) {
        return 0;
      }
      this.token('JS', (script = match[0]).slice(1, -1), 0, script.length);
      return script.length;
    };

    Lexer.prototype.regexToken = function() {
      var flags, length, match, prev, regex, _ref2, _ref3;
      if (this.chunk.charAt(0) !== '/') {
        return 0;
      }
      if (length = this.heregexToken()) {
        return length;
      }
      prev = last(this.tokens);
      if (prev && (_ref2 = prev[0], __indexOf.call((prev.spaced ? NOT_REGEX : NOT_SPACED_REGEX), _ref2) >= 0)) {
        return 0;
      }
      if (!(match = REGEX.exec(this.chunk))) {
        return 0;
      }
      _ref3 = match, match = _ref3[0], regex = _ref3[1], flags = _ref3[2];
      if (regex === '//') {
        return 0;
      }
      if (regex.slice(0, 2) === '/*') {
        this.error('regular expressions cannot begin with `*`');
      }
      this.token('REGEX', "" + regex + flags, 0, match.length);
      return match.length;
    };

    Lexer.prototype.heregexToken = function() {
      var body, flags, flagsOffset, heregex, match, plusToken, prev, re, tag, token, tokens, value, _i, _len, _ref2, _ref3, _ref4;
      if (!(match = HEREGEX.exec(this.chunk))) {
        return 0;
      }
      heregex = match[0], body = match[1], flags = match[2];
      if (0 > body.indexOf('#{')) {
        re = this.escapeLines(body.replace(HEREGEX_OMIT, '$1$2').replace(/\//g, '\\/'), true);
        if (re.match(/^\*/)) {
          this.error('regular expressions cannot begin with `*`');
        }
        this.token('REGEX', "/" + (re || '(?:)') + "/" + flags, 0, heregex.length);
        return heregex.length;
      }
      this.token('IDENTIFIER', 'RegExp', 0, 0);
      this.token('CALL_START', '(', 0, 0);
      tokens = [];
      _ref2 = this.interpolateString(body, {
        regex: true,
        strOffset: 3
      });
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        token = _ref2[_i];
        tag = token[0], value = token[1];
        if (tag === 'TOKENS') {
          tokens.push.apply(tokens, value);
        } else if (tag === 'NEOSTRING') {
          if (!(value = value.replace(HEREGEX_OMIT, '$1$2'))) {
            continue;
          }
          value = value.replace(/\\/g, '\\\\');
          token[0] = 'STRING';
          token[1] = this.makeString(value, '"', true);
          tokens.push(token);
        } else {
          this.error("Unexpected " + tag);
        }
        prev = last(this.tokens);
        plusToken = ['+', '+'];
        plusToken[2] = prev[2];
        tokens.push(plusToken);
      }
      tokens.pop();
      if (((_ref3 = tokens[0]) != null ? _ref3[0] : void 0) !== 'STRING') {
        this.token('STRING', '""', 0, 0);
        this.token('+', '+', 0, 0);
      }
      (_ref4 = this.tokens).push.apply(_ref4, tokens);
      if (flags) {
        flagsOffset = heregex.lastIndexOf(flags);
        this.token(',', ',', flagsOffset, 0);
        this.token('STRING', '"' + flags + '"', flagsOffset, flags.length);
      }
      this.token(')', ')', heregex.length - 1, 0);
      return heregex.length;
    };

    Lexer.prototype.lineToken = function() {
      var diff, indent, match, noNewlines, size;
      if (!(match = MULTI_DENT.exec(this.chunk))) {
        return 0;
      }
      indent = match[0];
      this.seenFor = false;
      size = indent.length - 1 - indent.lastIndexOf('\n');
      noNewlines = this.unfinished();
      if (size - this.indebt === this.indent) {
        if (noNewlines) {
          this.suppressNewlines();
        } else {
          this.newlineToken(0);
        }
        return indent.length;
      }
      if (size > this.indent) {
        if (noNewlines) {
          this.indebt = size - this.indent;
          this.suppressNewlines();
          return indent.length;
        }
        if (!this.tokens.length) {
          this.baseIndent = this.indent = size;
          return indent.length;
        }
        diff = size - this.indent + this.outdebt;
        this.token('INDENT', diff, indent.length - size, size);
        this.indents.push(diff);
        this.ends.push('OUTDENT');
        this.outdebt = this.indebt = 0;
        this.indent = size;
      } else if (size < this.baseIndent) {
        this.error('missing indentation', indent.length);
      } else {
        this.indebt = 0;
        this.outdentToken(this.indent - size, noNewlines, indent.length);
      }
      return indent.length;
    };

    Lexer.prototype.outdentToken = function(moveOut, noNewlines, outdentLength) {
      var decreasedIndent, dent, lastIndent, _ref2;
      decreasedIndent = this.indent - moveOut;
      while (moveOut > 0) {
        lastIndent = this.indents[this.indents.length - 1];
        if (!lastIndent) {
          moveOut = 0;
        } else if (lastIndent === this.outdebt) {
          moveOut -= this.outdebt;
          this.outdebt = 0;
        } else if (lastIndent < this.outdebt) {
          this.outdebt -= lastIndent;
          moveOut -= lastIndent;
        } else {
          dent = this.indents.pop() + this.outdebt;
          if (outdentLength && (_ref2 = this.chunk[outdentLength], __indexOf.call(INDENTABLE_CLOSERS, _ref2) >= 0)) {
            decreasedIndent -= dent - moveOut;
            moveOut = dent;
          }
          this.outdebt = 0;
          this.pair('OUTDENT');
          this.token('OUTDENT', moveOut, 0, outdentLength);
          moveOut -= dent;
        }
      }
      if (dent) {
        this.outdebt -= moveOut;
      }
      while (this.value() === ';') {
        this.tokens.pop();
      }
      if (!(this.tag() === 'TERMINATOR' || noNewlines)) {
        this.token('TERMINATOR', '\n', outdentLength, 0);
      }
      this.indent = decreasedIndent;
      return this;
    };

    Lexer.prototype.whitespaceToken = function() {
      var match, nline, prev;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === '\n'))) {
        return 0;
      }
      prev = last(this.tokens);
      if (prev) {
        prev[match ? 'spaced' : 'newLine'] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    };

    Lexer.prototype.newlineToken = function(offset) {
      while (this.value() === ';') {
        this.tokens.pop();
      }
      if (this.tag() !== 'TERMINATOR') {
        this.token('TERMINATOR', '\n', offset, 0);
      }
      return this;
    };

    Lexer.prototype.suppressNewlines = function() {
      if (this.value() === '\\') {
        this.tokens.pop();
      }
      return this;
    };

    Lexer.prototype.literalToken = function() {
      var match, prev, tag, value, _ref2, _ref3, _ref4, _ref5;
      if (match = OPERATOR.exec(this.chunk)) {
        value = match[0];
        if (CODE.test(value)) {
          this.tagParameters();
        }
      } else {
        value = this.chunk.charAt(0);
      }
      tag = value;
      prev = last(this.tokens);
      if (value === '=' && prev) {
        if (!prev[1].reserved && (_ref2 = prev[1], __indexOf.call(JS_FORBIDDEN, _ref2) >= 0)) {
          this.error("reserved word \"" + (this.value()) + "\" can't be assigned");
        }
        if ((_ref3 = prev[1]) === '||' || _ref3 === '&&') {
          prev[0] = 'COMPOUND_ASSIGN';
          prev[1] += '=';
          return value.length;
        }
      }
      if (value === ';') {
        this.seenFor = false;
        tag = 'TERMINATOR';
      } else if (__indexOf.call(MATH, value) >= 0) {
        tag = 'MATH';
      } else if (__indexOf.call(COMPARE, value) >= 0) {
        tag = 'COMPARE';
      } else if (__indexOf.call(COMPOUND_ASSIGN, value) >= 0) {
        tag = 'COMPOUND_ASSIGN';
      } else if (__indexOf.call(UNARY, value) >= 0) {
        tag = 'UNARY';
      } else if (__indexOf.call(UNARY_MATH, value) >= 0) {
        tag = 'UNARY_MATH';
      } else if (__indexOf.call(SHIFT, value) >= 0) {
        tag = 'SHIFT';
      } else if (__indexOf.call(LOGIC, value) >= 0 || value === '?' && (prev != null ? prev.spaced : void 0)) {
        tag = 'LOGIC';
      } else if (prev && !prev.spaced) {
        if (value === '(' && (_ref4 = prev[0], __indexOf.call(CALLABLE, _ref4) >= 0)) {
          if (prev[0] === '?') {
            prev[0] = 'FUNC_EXIST';
          }
          tag = 'CALL_START';
        } else if (value === '[' && (_ref5 = prev[0], __indexOf.call(INDEXABLE, _ref5) >= 0)) {
          tag = 'INDEX_START';
          switch (prev[0]) {
            case '?':
              prev[0] = 'INDEX_SOAK';
          }
        }
      }
      switch (value) {
        case '(':
        case '{':
        case '[':
          this.ends.push(INVERSES[value]);
          break;
        case ')':
        case '}':
        case ']':
          this.pair(value);
      }
      this.token(tag, value);
      return value.length;
    };

    Lexer.prototype.sanitizeHeredoc = function(doc, options) {
      var attempt, herecomment, indent, match, _ref2;
      indent = options.indent, herecomment = options.herecomment;
      if (herecomment) {
        if (HEREDOC_ILLEGAL.test(doc)) {
          this.error("block comment cannot contain \"*/\", starting");
        }
        if (doc.indexOf('\n') < 0) {
          return doc;
        }
      } else {
        while (match = HEREDOC_INDENT.exec(doc)) {
          attempt = match[1];
          if (indent === null || (0 < (_ref2 = attempt.length) && _ref2 < indent.length)) {
            indent = attempt;
          }
        }
      }
      if (indent) {
        doc = doc.replace(RegExp("\\n" + indent, "g"), '\n');
      }
      if (!herecomment) {
        doc = doc.replace(/^\n/, '');
      }
      return doc;
    };

    Lexer.prototype.tagParameters = function() {
      var i, stack, tok, tokens;
      if (this.tag() !== ')') {
        return this;
      }
      stack = [];
      tokens = this.tokens;
      i = tokens.length;
      tokens[--i][0] = 'PARAM_END';
      while (tok = tokens[--i]) {
        switch (tok[0]) {
          case ')':
            stack.push(tok);
            break;
          case '(':
          case 'CALL_START':
            if (stack.length) {
              stack.pop();
            } else if (tok[0] === '(') {
              tok[0] = 'PARAM_START';
              return this;
            } else {
              return this;
            }
        }
      }
      return this;
    };

    Lexer.prototype.closeIndentation = function() {
      return this.outdentToken(this.indent);
    };

    Lexer.prototype.balancedString = function(str, end) {
      var continueCount, i, letter, match, prev, stack, _i, _ref2;
      continueCount = 0;
      stack = [end];
      for (i = _i = 1, _ref2 = str.length; 1 <= _ref2 ? _i < _ref2 : _i > _ref2; i = 1 <= _ref2 ? ++_i : --_i) {
        if (continueCount) {
          --continueCount;
          continue;
        }
        switch (letter = str.charAt(i)) {
          case '\\':
            ++continueCount;
            continue;
          case end:
            stack.pop();
            if (!stack.length) {
              return str.slice(0, +i + 1 || 9e9);
            }
            end = stack[stack.length - 1];
            continue;
        }
        if (end === '}' && (letter === '"' || letter === "'")) {
          stack.push(end = letter);
        } else if (end === '}' && letter === '/' && (match = HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i)))) {
          continueCount += match[0].length - 1;
        } else if (end === '}' && letter === '{') {
          stack.push(end = '}');
        } else if (end === '"' && prev === '#' && letter === '{') {
          stack.push(end = '}');
        }
        prev = letter;
      }
      return this.error("missing " + (stack.pop()) + ", starting");
    };

    Lexer.prototype.interpolateString = function(str, options) {
      var column, errorToken, expr, heredoc, i, inner, interpolated, len, letter, lexedLength, line, locationToken, nested, offsetInChunk, pi, plusToken, popped, regex, rparen, strOffset, tag, token, tokens, value, _i, _len, _ref2, _ref3, _ref4;
      if (options == null) {
        options = {};
      }
      heredoc = options.heredoc, regex = options.regex, offsetInChunk = options.offsetInChunk, strOffset = options.strOffset, lexedLength = options.lexedLength;
      offsetInChunk || (offsetInChunk = 0);
      strOffset || (strOffset = 0);
      lexedLength || (lexedLength = str.length);
      tokens = [];
      pi = 0;
      i = -1;
      while (letter = str.charAt(i += 1)) {
        if (letter === '\\') {
          i += 1;
          continue;
        }
        if (!(letter === '#' && str.charAt(i + 1) === '{' && (expr = this.balancedString(str.slice(i + 1), '}')))) {
          continue;
        }
        if (pi < i) {
          tokens.push(this.makeToken('NEOSTRING', str.slice(pi, i), strOffset + pi));
        }
        if (!errorToken) {
          errorToken = this.makeToken('', 'string interpolation', offsetInChunk + i + 1, 2);
        }
        inner = expr.slice(1, -1);
        if (inner.length) {
          _ref2 = this.getLineAndColumnFromChunk(strOffset + i + 2), line = _ref2[0], column = _ref2[1];
          nested = new Lexer().tokenize(inner, {
            line: line,
            column: column,
            rewrite: false
          });
          popped = nested.pop();
          if (((_ref3 = nested[0]) != null ? _ref3[0] : void 0) === 'TERMINATOR') {
            popped = nested.shift();
          }
          if (len = nested.length) {
            if (len > 1) {
              nested.unshift(this.makeToken('(', '(', strOffset + i + 1, 0));
              nested.push(this.makeToken(')', ')', strOffset + i + 1 + inner.length, 0));
            }
            tokens.push(['TOKENS', nested]);
          }
        }
        i += expr.length;
        pi = i + 1;
      }
      if ((i > pi && pi < str.length)) {
        tokens.push(this.makeToken('NEOSTRING', str.slice(pi), strOffset + pi));
      }
      if (regex) {
        return tokens;
      }
      if (!tokens.length) {
        return this.token('STRING', '""', offsetInChunk, lexedLength);
      }
      if (tokens[0][0] !== 'NEOSTRING') {
        tokens.unshift(this.makeToken('NEOSTRING', '', offsetInChunk));
      }
      if (interpolated = tokens.length > 1) {
        this.token('(', '(', offsetInChunk, 0, errorToken);
      }
      for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
        token = tokens[i];
        tag = token[0], value = token[1];
        if (i) {
          if (i) {
            plusToken = this.token('+', '+');
          }
          locationToken = tag === 'TOKENS' ? value[0] : token;
          plusToken[2] = {
            first_line: locationToken[2].first_line,
            first_column: locationToken[2].first_column,
            last_line: locationToken[2].first_line,
            last_column: locationToken[2].first_column
          };
        }
        if (tag === 'TOKENS') {
          (_ref4 = this.tokens).push.apply(_ref4, value);
        } else if (tag === 'NEOSTRING') {
          token[0] = 'STRING';
          token[1] = this.makeString(value, '"', heredoc);
          this.tokens.push(token);
        } else {
          this.error("Unexpected " + tag);
        }
      }
      if (interpolated) {
        rparen = this.makeToken(')', ')', offsetInChunk + lexedLength, 0);
        rparen.stringEnd = true;
        this.tokens.push(rparen);
      }
      return tokens;
    };

    Lexer.prototype.pair = function(tag) {
      var wanted;
      if (tag !== (wanted = last(this.ends))) {
        if ('OUTDENT' !== wanted) {
          this.error("unmatched " + tag);
        }
        this.outdentToken(last(this.indents), true);
        return this.pair(tag);
      }
      return this.ends.pop();
    };

    Lexer.prototype.getLineAndColumnFromChunk = function(offset) {
      var column, lineCount, lines, string;
      if (offset === 0) {
        return [this.chunkLine, this.chunkColumn];
      }
      if (offset >= this.chunk.length) {
        string = this.chunk;
      } else {
        string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);
      }
      lineCount = count(string, '\n');
      column = this.chunkColumn;
      if (lineCount > 0) {
        lines = string.split('\n');
        column = last(lines).length;
      } else {
        column += string.length;
      }
      return [this.chunkLine + lineCount, column];
    };

    Lexer.prototype.makeToken = function(tag, value, offsetInChunk, length) {
      var lastCharacter, locationData, token, _ref2, _ref3;
      if (offsetInChunk == null) {
        offsetInChunk = 0;
      }
      if (length == null) {
        length = value.length;
      }
      locationData = {};
      _ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = _ref2[0], locationData.first_column = _ref2[1];
      lastCharacter = Math.max(0, length - 1);
      _ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = _ref3[0], locationData.last_column = _ref3[1];
      token = [tag, value, locationData];
      return token;
    };

    Lexer.prototype.token = function(tag, value, offsetInChunk, length, origin) {
      var token;
      token = this.makeToken(tag, value, offsetInChunk, length);
      if (origin) {
        token.origin = origin;
      }
      this.tokens.push(token);
      return token;
    };

    Lexer.prototype.tag = function(index, tag) {
      var tok;
      return (tok = last(this.tokens, index)) && (tag ? tok[0] = tag : tok[0]);
    };

    Lexer.prototype.value = function(index, val) {
      var tok;
      return (tok = last(this.tokens, index)) && (val ? tok[1] = val : tok[1]);
    };

    Lexer.prototype.unfinished = function() {
      var _ref2;
      return LINE_CONTINUER.test(this.chunk) || ((_ref2 = this.tag()) === '\\' || _ref2 === '.' || _ref2 === '?.' || _ref2 === '?::' || _ref2 === 'UNARY' || _ref2 === 'MATH' || _ref2 === 'UNARY_MATH' || _ref2 === '+' || _ref2 === '-' || _ref2 === 'YIELD' || _ref2 === '**' || _ref2 === 'SHIFT' || _ref2 === 'RELATION' || _ref2 === 'COMPARE' || _ref2 === 'LOGIC' || _ref2 === 'THROW' || _ref2 === 'EXTENDS');
    };

    Lexer.prototype.removeNewlines = function(str) {
      return str.replace(/^\s*\n\s*/, '').replace(/([^\\]|\\\\)\s*\n\s*$/, '$1');
    };

    Lexer.prototype.escapeLines = function(str, heredoc) {
      str = str.replace(/\\[^\S\n]*(\n|\\)\s*/g, function(escaped, character) {
        if (character === '\n') {
          return '';
        } else {
          return escaped;
        }
      });
      if (heredoc) {
        return str.replace(MULTILINER, '\\n');
      } else {
        return str.replace(/\s*\n\s*/g, ' ');
      }
    };

    Lexer.prototype.makeString = function(body, quote, heredoc) {
      if (!body) {
        return quote + quote;
      }
      body = body.replace(RegExp("\\\\(" + quote + "|\\\\)", "g"), function(match, contents) {
        if (contents === quote) {
          return contents;
        } else {
          return match;
        }
      });
      body = body.replace(RegExp("" + quote, "g"), '\\$&');
      return quote + this.escapeLines(body, heredoc) + quote;
    };

    Lexer.prototype.error = function(message, offset) {
      var first_column, first_line, _ref2;
      if (offset == null) {
        offset = 0;
      }
      _ref2 = this.getLineAndColumnFromChunk(offset), first_line = _ref2[0], first_column = _ref2[1];
      return throwSyntaxError(message, {
        first_line: first_line,
        first_column: first_column
      });
    };

    return Lexer;

  })();

  JS_KEYWORDS = ['true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'debugger', 'yield', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super'];

  COFFEE_KEYWORDS = ['undefined', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when'];

  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(['await', 'defer']);

  COFFEE_ALIAS_MAP = {
    and: '&&',
    or: '||',
    is: '==',
    isnt: '!=',
    not: '!',
    yes: 'true',
    no: 'false',
    on: 'true',
    off: 'false'
  };

  COFFEE_ALIASES = (function() {
    var _results;
    _results = [];
    for (key in COFFEE_ALIAS_MAP) {
      _results.push(key);
    }
    return _results;
  })();

  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);

  RESERVED = ['case', 'default', 'function', 'var', 'void', 'with', 'const', 'let', 'enum', 'export', 'import', 'native', '__hasProp', '__extends', '__slice', '__bind', '__indexOf', 'implements', 'interface', 'package', 'private', 'protected', 'public', 'static'];

  STRICT_PROSCRIBED = ['arguments', 'eval', 'yield*'];

  JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);

  exports.RESERVED = RESERVED.concat(JS_KEYWORDS).concat(COFFEE_KEYWORDS).concat(STRICT_PROSCRIBED);

  exports.STRICT_PROSCRIBED = STRICT_PROSCRIBED;

  BOM = 65279;

  IDENTIFIER = /^([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([^\n\S]*:(?!:))?/;

  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

  HEREDOC = /^("""|''')((?:\\[\s\S]|[^\\])*?)(?:\n[^\n\S]*)?\1/;

  OPERATOR = /^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>*\/%])\2=?|\?(\.|::)|\.{2,3})/;

  WHITESPACE = /^[^\n\S]+/;

  COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|###$)|^(?:\s*#(?!##[^#]).*)+/;

  CODE = /^[-=]>/;

  MULTI_DENT = /^(?:\n[^\n\S]*)+/;

  SIMPLESTR = /^'[^\\']*(?:\\[\s\S][^\\']*)*'/;

  JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;

  REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;

  HEREGEX = /^\/{3}((?:\\?[\s\S])+?)\/{3}([imgy]{0,4})(?!\w)/;

  HEREGEX_OMIT = /((?:\\\\)+)|\\(\s|\/)|\s+(?:#.*)?/g;

  MULTILINER = /\n/g;

  HEREDOC_INDENT = /\n+([^\n\S]*)/g;

  HEREDOC_ILLEGAL = /\*\//;

  LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;

  TRAILING_SPACES = /\s+$/;

  COMPOUND_ASSIGN = ['-=', '+=', '/=', '*=', '%=', '||=', '&&=', '?=', '<<=', '>>=', '>>>=', '&=', '^=', '|=', '**=', '//=', '%%='];

  UNARY = ['NEW', 'TYPEOF', 'DELETE', 'DO'];

  UNARY_MATH = ['!', '~'];

  LOGIC = ['&&', '||', '&', '|', '^'];

  SHIFT = ['<<', '>>', '>>>'];

  COMPARE = ['==', '!=', '<', '>', '<=', '>='];

  MATH = ['*', '/', '%', '//', '%%'];

  RELATION = ['IN', 'OF', 'INSTANCEOF'];

  BOOL = ['TRUE', 'FALSE'];

  NOT_REGEX = ['NUMBER', 'REGEX', 'BOOL', 'NULL', 'UNDEFINED', '++', '--'];

  NOT_SPACED_REGEX = NOT_REGEX.concat(')', '}', 'THIS', 'IDENTIFIER', 'STRING', ']');

  CALLABLE = ['IDENTIFIER', 'STRING', 'REGEX', ')', ']', '}', '?', '::', '@', 'THIS', 'SUPER'];

  INDEXABLE = CALLABLE.concat('NUMBER', 'BOOL', 'NULL', 'UNDEFINED');

  LINE_BREAK = ['INDENT', 'OUTDENT', 'TERMINATOR'];

  INDENTABLE_CLOSERS = [')', '}', ']'];

  CALLABLE.push('DEFER');

}).call(this);

},{"./helpers":3,"./rewriter":9}],6:[function(require,module,exports){
(function (__dirname){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  var Access, Arr, Assign, Await, Base, Block, Call, Class, Closure, Code, CodeFragment, Comment, CpsCascade, Defer, Existence, Expansion, Extends, For, HEXNUM, IDENTIFIER, IDENTIFIER_STR, IS_REGEX, IS_STRING, IcedReturnValue, IcedRuntime, IcedTailCall, If, In, Index, InlineRuntime, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, Literal, METHOD_DEF, NEGATE, NO, NULL, NUMBER, Obj, Op, Param, Parens, RESERVED, Range, Return, SIMPLENUM, STRICT_PROSCRIBED, Scope, Slice, Slot, Splat, Switch, TAB, THIS, Throw, Try, UTILITIES, Value, While, YES, addLocationDataFn, compact, del, ends, extend, flatten, fragmentsToText, iced, isLiteralArguments, isLiteralThis, last, locationDataToString, merge, multident, parseNum, pathmod, quote_funcname_for_debug, quote_path_for_emission, require_top_dir, some, starts, throwSyntaxError, unfoldSoak, utility, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  Error.stackTraceLimit = Infinity;

  Scope = require('./scope').Scope;

  _ref = require('./lexer'), RESERVED = _ref.RESERVED, STRICT_PROSCRIBED = _ref.STRICT_PROSCRIBED;

  iced = require('iced-runtime');

  pathmod = require('path');

  _ref1 = require('./helpers'), compact = _ref1.compact, flatten = _ref1.flatten, extend = _ref1.extend, merge = _ref1.merge, del = _ref1.del, starts = _ref1.starts, ends = _ref1.ends, last = _ref1.last, some = _ref1.some, addLocationDataFn = _ref1.addLocationDataFn, locationDataToString = _ref1.locationDataToString, throwSyntaxError = _ref1.throwSyntaxError;

  exports.extend = extend;

  exports.addLocationDataFn = addLocationDataFn;

  YES = function() {
    return true;
  };

  NO = function() {
    return false;
  };

  THIS = function() {
    return this;
  };

  NEGATE = function() {
    this.negated = !this.negated;
    return this;
  };

  NULL = function() {
    return new Value(new Literal('null'));
  };

  exports.CodeFragment = CodeFragment = (function() {
    function CodeFragment(parent, code) {
      var _ref2;
      this.code = "" + code;
      this.locationData = parent != null ? parent.locationData : void 0;
      this.type = (parent != null ? (_ref2 = parent.constructor) != null ? _ref2.name : void 0 : void 0) || 'unknown';
    }

    CodeFragment.prototype.toString = function() {
      return "" + this.code + (this.locationData ? ": " + locationDataToString(this.locationData) : '');
    };

    return CodeFragment;

  })();

  fragmentsToText = function(fragments) {
    var fragment;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = fragments.length; _i < _len; _i++) {
        fragment = fragments[_i];
        _results.push(fragment.code);
      }
      return _results;
    })()).join('');
  };

  exports.Base = Base = (function() {
    function Base() {
      this.icedContinuationBlock = null;
      this.icedLoopFlag = false;
      this.icedNodeFlag = false;
      this.icedGotCpsSplitFlag = false;
      this.icedCpsPivotFlag = false;
      this.icedHasAutocbFlag = false;
      this.icedFoundArguments = false;
      this.icedParentAwait = null;
      this.icedCallContinuationFlag = false;
    }

    Base.prototype.compile = function(o, lvl) {
      return fragmentsToText(this.compileToFragments(o, lvl));
    };

    Base.prototype.compileToFragments = function(o, lvl) {
      var node;
      o = extend({}, o);
      if (lvl) {
        o.level = lvl;
      }
      node = this.unfoldSoak(o) || this;
      node.tab = o.indent;
      if (node.icedHasContinuation() && !node.icedGotCpsSplitFlag) {
        return node.icedCompileCps(o);
      } else if (o.level === LEVEL_TOP || !node.isStatement(o)) {
        return node.compileNode(o);
      } else {
        return node.compileClosure(o);
      }
    };

    Base.prototype.compileClosure = function(o) {
      var args, argumentsNode, func, jumpNode, meth;
      if (jumpNode = this.jumps()) {
        jumpNode.error('cannot use a pure statement in an expression');
      }
      o.sharedScope = true;
      this.icedClearAutocbFlags();
      func = new Code([], Block.wrap([this]));
      args = [];
      if ((argumentsNode = this.contains(isLiteralArguments)) || this.contains(isLiteralThis)) {
        args = [new Literal('this')];
        if (argumentsNode) {
          meth = 'apply';
          args.push(new Literal('arguments'));
        } else {
          meth = 'call';
        }
        func = new Value(func, [new Access(new Literal(meth))]);
      }
      return (new Call(func, args)).compileNode(o);
    };

    Base.prototype.cache = function(o, level, reused) {
      var ref, sub;
      if (!this.isComplex()) {
        ref = level ? this.compileToFragments(o, level) : this;
        return [ref, ref];
      } else {
        ref = new Literal(reused || o.scope.freeVariable('ref'));
        sub = new Assign(ref, this);
        if (level) {
          return [sub.compileToFragments(o, level), [this.makeCode(ref.value)]];
        } else {
          return [sub, ref];
        }
      }
    };

    Base.prototype.cacheToCodeFragments = function(cacheValues) {
      return [fragmentsToText(cacheValues[0]), fragmentsToText(cacheValues[1])];
    };

    Base.prototype.makeReturn = function(res) {
      var me;
      me = this.unwrapAll();
      if (res) {
        return new Call(new Literal("" + res + ".push"), [me]);
      } else {
        return new Return(me, this.icedHasAutocbFlag);
      }
    };

    Base.prototype.contains = function(pred) {
      var node;
      node = void 0;
      this.traverseChildren(false, function(n) {
        if (pred(n)) {
          node = n;
          return false;
        }
      });
      return node;
    };

    Base.prototype.lastNonComment = function(list) {
      var i;
      i = list.length;
      while (i--) {
        if (!(list[i] instanceof Comment)) {
          return list[i];
        }
      }
      return null;
    };

    Base.prototype.toString = function(idt, name) {
      var extras, tree;
      if (idt == null) {
        idt = '';
      }
      if (name == null) {
        name = this.constructor.name;
      }
      extras = [];
      if (this.icedNodeFlag) {
        extras.push("A");
      }
      if (this.icedLoopFlag) {
        extras.push("L");
      }
      if (this.icedCpsPivotFlag) {
        extras.push("P");
      }
      if (this.icedIsAutocbCode) {
        extras.push("B");
      }
      if (this.icedHasAutocbFlag) {
        extras.push("C");
      }
      if (this.icedParentAwait) {
        extras.push("D");
      }
      if (this.icedFoundArguments) {
        extras.push("G");
      }
      if (extras.length) {
        extras = " (" + extras.join('') + ")";
      }
      tree = '\n' + idt + name;
      tree = '\n' + idt + name;
      if (this.soak) {
        tree += '?';
      }
      tree += extras;
      this.eachChild(function(node) {
        return tree += node.toString(idt + TAB);
      });
      if (this.icedContinuationBlock) {
        idt += TAB;
        tree += '\n' + idt + "Continuation";
        tree += this.icedContinuationBlock.toString(idt + TAB);
      }
      return tree;
    };

    Base.prototype.eachChild = function(func) {
      var attr, child, _i, _j, _len, _len1, _ref2, _ref3;
      if (!this.children) {
        return this;
      }
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            if (func(child) === false) {
              return this;
            }
          }
        }
      }
      return this;
    };

    Base.prototype.traverseChildren = function(crossScope, func) {
      return this.eachChild(function(child) {
        var recur;
        recur = func(child);
        if (recur !== false) {
          return child.traverseChildren(crossScope, func);
        }
      });
    };

    Base.prototype.invert = function() {
      return new Op('!', this);
    };

    Base.prototype.unwrapAll = function() {
      var node;
      node = this;
      while (node !== (node = node.unwrap())) {
        continue;
      }
      return node;
    };

    Base.prototype.flattenChildren = function() {
      var attr, child, out, _i, _j, _len, _len1, _ref2, _ref3;
      out = [];
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            child = _ref3[_j];
            out.push(child);
          }
        }
      }
      return out;
    };

    Base.prototype.icedCompileCps = function(o) {
      var code;
      this.icedGotCpsSplitFlag = true;
      code = CpsCascade.wrap(this, this.icedContinuationBlock, null, o);
      o.sharedScope = true;
      return code.compileNode(o);
    };

    Base.prototype.icedWalkAst = function(p, o) {
      var child, _i, _len, _ref2;
      this.icedParentAwait = p;
      this.icedHasAutocbFlag = o.foundAutocb;
      _ref2 = this.flattenChildren();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        child = _ref2[_i];
        if (child.icedWalkAst(p, o)) {
          this.icedNodeFlag = true;
        }
      }
      return this.icedNodeFlag;
    };

    Base.prototype.icedWalkAstLoops = function(flood) {
      var child, _i, _len, _ref2;
      if (this.isLoop() && this.icedNodeFlag) {
        flood = true;
      }
      if (this.isLoop() && !this.icedNodeFlag) {
        flood = false;
      }
      this.icedLoopFlag = flood;
      _ref2 = this.flattenChildren();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        child = _ref2[_i];
        if (child.icedWalkAstLoops(flood)) {
          this.icedLoopFlag = true;
        }
      }
      return this.icedLoopFlag;
    };

    Base.prototype.icedWalkCpsPivots = function() {
      var child, _i, _len, _ref2;
      if (this.icedNodeFlag || (this.icedLoopFlag && this.icedIsJump())) {
        this.icedCpsPivotFlag = true;
      }
      _ref2 = this.flattenChildren();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        child = _ref2[_i];
        if (child.icedWalkCpsPivots()) {
          this.icedCpsPivotFlag = true;
        }
      }
      return this.icedCpsPivotFlag;
    };

    Base.prototype.icedClearAutocbFlags = function() {
      this.icedHasAutocbFlag = false;
      return this.traverseChildren(false, function(node) {
        node.icedHasAutocbFlag = false;
        return true;
      });
    };

    Base.prototype.icedCpsRotate = function() {
      var child, _i, _len, _ref2;
      _ref2 = this.flattenChildren();
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        child = _ref2[_i];
        child.icedCpsRotate();
      }
      return this;
    };

    Base.prototype.icedIsCpsPivot = function() {
      return this.icedCpsPivotFlag;
    };

    Base.prototype.icedNestContinuationBlock = function(b) {
      return this.icedContinuationBlock = b;
    };

    Base.prototype.icedHasContinuation = function() {
      return !!this.icedContinuationBlock;
    };

    Base.prototype.icedCallContinuation = function() {
      return this.icedCallContinuationFlag = true;
    };

    Base.prototype.icedWrapContinuation = NO;

    Base.prototype.icedIsJump = NO;

    Base.prototype.icedUnwrap = function(e) {
      if (e.icedHasContinuation() && this.icedHasContinuation()) {
        return this;
      } else {
        if (this.icedHasContinuation()) {
          e.icedContinuationBlock = this.icedContinuationBlock;
        }
        return e;
      }
    };

    Base.prototype.icedStatementAssertion = function() {
      if (this.icedIsCpsPivot()) {
        return this.error("await'ed statements can't act as expressions");
      }
    };

    Base.prototype.children = [];

    Base.prototype.isStatement = NO;

    Base.prototype.jumps = NO;

    Base.prototype.isComplex = YES;

    Base.prototype.isChainable = NO;

    Base.prototype.isAssignable = NO;

    Base.prototype.isLoop = NO;

    Base.prototype.unwrap = THIS;

    Base.prototype.unfoldSoak = NO;

    Base.prototype.assigns = NO;

    Base.prototype.updateLocationDataIfMissing = function(locationData) {
      if (this.locationData) {
        return this;
      }
      this.locationData = locationData;
      return this.eachChild(function(child) {
        return child.updateLocationDataIfMissing(locationData);
      });
    };

    Base.prototype.error = function(message) {
      return throwSyntaxError(message, this.locationData);
    };

    Base.prototype.makeCode = function(code) {
      return new CodeFragment(this, code);
    };

    Base.prototype.wrapInBraces = function(fragments) {
      return [].concat(this.makeCode('('), fragments, this.makeCode(')'));
    };

    Base.prototype.joinFragmentArrays = function(fragmentsList, joinStr) {
      var answer, fragments, i, _i, _len;
      answer = [];
      for (i = _i = 0, _len = fragmentsList.length; _i < _len; i = ++_i) {
        fragments = fragmentsList[i];
        if (i) {
          answer.push(this.makeCode(joinStr));
        }
        answer = answer.concat(fragments);
      }
      return answer;
    };

    return Base;

  })();

  exports.Block = Block = (function(_super) {
    __extends(Block, _super);

    function Block(nodes) {
      Block.__super__.constructor.call(this);
      this.expressions = compact(flatten(nodes || []));
    }

    Block.prototype.children = ['expressions'];

    Block.prototype.push = function(node) {
      this.expressions.push(node);
      return this;
    };

    Block.prototype.pop = function() {
      return this.expressions.pop();
    };

    Block.prototype.unshift = function(node) {
      this.expressions.unshift(node);
      return this;
    };

    Block.prototype.unwrap = function() {
      if (this.expressions.length === 1) {
        return this.icedUnwrap(this.expressions[0]);
      } else {
        return this;
      }
    };

    Block.prototype.isEmpty = function() {
      return !this.expressions.length;
    };

    Block.prototype.isStatement = function(o) {
      var exp, _i, _len, _ref2;
      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        exp = _ref2[_i];
        if (exp.isStatement(o)) {
          return true;
        }
      }
      return false;
    };

    Block.prototype.jumps = function(o) {
      var exp, jumpNode, _i, _len, _ref2;
      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        exp = _ref2[_i];
        if (jumpNode = exp.jumps(o)) {
          return jumpNode;
        }
      }
    };

    Block.prototype.makeReturn = function(res) {
      var expr, foundReturn, len;
      len = this.expressions.length;
      foundReturn = false;
      while (len--) {
        expr = this.expressions[len];
        if (!(expr instanceof Comment)) {
          this.expressions[len] = expr.makeReturn(res);
          if (expr instanceof Return && !expr.expression && !expr.icedHasAutocbFlag) {
            this.expressions.splice(len, 1);
            foundReturn = true;
          } else if (!(expr instanceof If) || expr.elseBody) {
            foundReturn = true;
          }
          break;
        }
      }
      if (this.icedHasAutocbFlag && !this.icedNodeFlag && !foundReturn) {
        this.expressions.push(new Return(null, true));
      }
      return this;
    };

    Block.prototype.compileToFragments = function(o, level) {
      if (o == null) {
        o = {};
      }
      if (o.scope) {
        return Block.__super__.compileToFragments.call(this, o, level);
      } else {
        return this.compileRoot(o);
      }
    };

    Block.prototype.compileNode = function(o) {
      var answer, compiledNodes, fragments, index, node, top, _i, _len, _ref2;
      this.tab = o.indent;
      top = o.level === LEVEL_TOP;
      compiledNodes = [];
      _ref2 = this.expressions;
      for (index = _i = 0, _len = _ref2.length; _i < _len; index = ++_i) {
        node = _ref2[index];
        node = node.unwrapAll();
        node = node.unfoldSoak(o) || node;
        if (node instanceof Block) {
          compiledNodes.push(node.compileNode(o));
        } else if (top) {
          node.front = true;
          fragments = node.compileToFragments(o);
          if (!node.isStatement(o)) {
            fragments.unshift(this.makeCode("" + this.tab));
            fragments.push(this.makeCode(";"));
          }
          compiledNodes.push(fragments);
        } else {
          compiledNodes.push(node.compileToFragments(o, LEVEL_LIST));
        }
      }
      if (top) {
        if (this.spaced) {
          return [].concat(this.joinFragmentArrays(compiledNodes, '\n\n'), this.makeCode("\n"));
        } else {
          return this.joinFragmentArrays(compiledNodes, '\n');
        }
      }
      if (compiledNodes.length) {
        answer = this.joinFragmentArrays(compiledNodes, ', ');
      } else {
        answer = [this.makeCode("void 0")];
      }
      if (compiledNodes.length > 1 && o.level >= LEVEL_LIST) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Block.prototype.compileRoot = function(o) {
      var exp, fragments, i, name, prelude, preludeExps, rest, _i, _len, _ref2;
      o.indent = o.bare ? '' : TAB;
      o.level = LEVEL_TOP;
      this.spaced = true;
      o.scope = new Scope(null, this, null);
      _ref2 = o.locals || [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        name = _ref2[_i];
        o.scope.parameter(name);
      }
      prelude = [];
      if (!o.bare) {
        preludeExps = (function() {
          var _j, _len1, _ref3, _results;
          _ref3 = this.expressions;
          _results = [];
          for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {
            exp = _ref3[i];
            if (!(exp.unwrap() instanceof Comment)) {
              break;
            }
            _results.push(exp);
          }
          return _results;
        }).call(this);
        rest = this.expressions.slice(preludeExps.length);
        this.expressions = preludeExps;
        if (preludeExps.length) {
          prelude = this.compileNode(merge(o, {
            indent: ''
          }));
          prelude.push(this.makeCode("\n"));
        }
        this.expressions = rest;
      }
      fragments = this.compileWithDeclarations(o);
      if (o.bare) {
        return fragments;
      }
      return [].concat(prelude, this.makeCode("(function() {\n"), fragments, this.makeCode("\n}).call(this);\n"));
    };

    Block.prototype.compileWithDeclarations = function(o) {
      var assigns, declars, exp, fragments, i, post, rest, scope, spaced, _i, _len, _ref2, _ref3, _ref4;
      fragments = [];
      post = [];
      _ref2 = this.expressions;
      for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
        exp = _ref2[i];
        exp = exp.unwrap();
        if (!(exp instanceof Comment || exp instanceof Literal)) {
          break;
        }
      }
      o = merge(o, {
        level: LEVEL_TOP
      });
      if (i) {
        rest = this.expressions.splice(i, 9e9);
        _ref3 = [this.spaced, false], spaced = _ref3[0], this.spaced = _ref3[1];
        _ref4 = [this.compileNode(o), spaced], fragments = _ref4[0], this.spaced = _ref4[1];
        this.expressions = rest;
      }
      post = this.compileNode(o);
      scope = o.scope;
      if (scope.expressions === this) {
        declars = o.scope.hasDeclarations();
        assigns = scope.hasAssignments;
        if (declars || assigns) {
          if (i) {
            fragments.push(this.makeCode('\n'));
          }
          fragments.push(this.makeCode("" + this.tab + "var "));
          if (declars) {
            fragments.push(this.makeCode(scope.declaredVariables().join(', ')));
          }
          if (assigns) {
            if (declars) {
              fragments.push(this.makeCode(",\n" + (this.tab + TAB)));
            }
            fragments.push(this.makeCode(scope.assignedVariables().join(",\n" + (this.tab + TAB))));
          }
          fragments.push(this.makeCode(";\n" + (this.spaced ? '\n' : '')));
        } else if (fragments.length && post.length) {
          fragments.push(this.makeCode("\n"));
        }
      }
      return fragments.concat(post);
    };

    Block.wrap = function(nodes) {
      if (nodes.length === 1 && nodes[0] instanceof Block) {
        return nodes[0];
      }
      return new Block(nodes);
    };

    Block.prototype.icedThreadReturn = function(call) {
      var expr, len;
      call = call || new IcedTailCall;
      len = this.expressions.length;
      while (len--) {
        expr = this.expressions[len];
        if (expr.isStatement()) {
          break;
        }
        if (!(expr instanceof Comment) && !(expr instanceof Return)) {
          call.assignValue(expr);
          this.expressions[len] = call;
          return;
        }
      }
      return this.expressions.push(call);
    };

    Block.prototype.icedCompileCps = function(o) {
      this.icedGotCpsSplitFlag = true;
      if (this.expressions.length > 1) {
        return Block.__super__.icedCompileCps.call(this, o);
      } else {
        return this.compileNode(o);
      }
    };

    Block.prototype.icedCpsRotate = function() {
      var child, e, i, pivot, rest, _i, _j, _len, _len1, _ref2;
      pivot = null;
      _ref2 = this.expressions;
      for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
        e = _ref2[i];
        if (e.icedIsCpsPivot()) {
          pivot = e;
          pivot.icedCallContinuation();
        }
        e.icedCpsRotate();
        if (pivot) {
          break;
        }
      }
      if (!pivot) {
        return this;
      }
      if (pivot.icedContinuationBlock) {
        throw SyntaxError("unexpected continuation block in node");
      }
      rest = this.expressions.slice(i + 1);
      this.expressions = this.expressions.slice(0, i + 1);
      if (rest.length) {
        child = new Block(rest);
        pivot.icedNestContinuationBlock(child);
        for (_j = 0, _len1 = rest.length; _j < _len1; _j++) {
          e = rest[_j];
          if (e.icedNodeFlag) {
            child.icedNodeFlag = true;
          }
          if (e.icedLoopFlag) {
            child.icedLoopFlag = true;
          }
          if (e.icedCpsPivotFlag) {
            child.icedCpsPivotFlag = true;
          }
          if (e.icedHasAutocbFlag) {
            child.icedHasAutocbFlag = true;
          }
        }
        child.icedCpsRotate();
      }
      return this;
    };

    Block.prototype.icedAddRuntime = function(foundDefer, foundAwait) {
      var index, node;
      index = 0;
      while ((node = this.expressions[index]) && node instanceof Comment || node instanceof Value && node.isString()) {
        index++;
      }
      return this.expressions.splice(index, 0, new IcedRuntime(foundDefer, foundAwait));
    };

    Block.prototype.icedTransform = function(opts) {
      var obj;
      obj = {};
      this.icedWalkAst(null, obj);
      if (!(opts != null ? opts.repl : void 0) && (obj.foundDefer || obj.foundAwait || opts.runforce)) {
        this.icedAddRuntime(obj.foundDefer, obj.foundAwait);
      }
      if (obj.foundAwait) {
        this.icedWalkAstLoops(false);
        this.icedWalkCpsPivots();
        this.icedCpsRotate();
      }
      return this;
    };

    Block.prototype.icedGetSingle = function() {
      if (this.expressions.length === 1) {
        return this.expressions[0];
      } else {
        return null;
      }
    };

    return Block;

  })(Base);

  exports.Literal = Literal = (function(_super) {
    __extends(Literal, _super);

    function Literal(value) {
      this.value = value;
      if (this.value == null) {
        throw new Error("whoops!");
      }
      Literal.__super__.constructor.call(this);
    }

    Literal.prototype.makeReturn = function() {
      if (this.isStatement()) {
        return this;
      } else {
        return Literal.__super__.makeReturn.apply(this, arguments);
      }
    };

    Literal.prototype.isAssignable = function() {
      return IDENTIFIER.test(this.value);
    };

    Literal.prototype.isStatement = function() {
      var _ref2;
      return (_ref2 = this.value) === 'break' || _ref2 === 'continue' || _ref2 === 'debugger';
    };

    Literal.prototype.isComplex = NO;

    Literal.prototype.assigns = function(name) {
      return name === this.value;
    };

    Literal.prototype.jumps = function(o) {
      if (this.value === 'break' && !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) {
        return this;
      }
      if (this.value === 'continue' && !(o != null ? o.loop : void 0)) {
        return this;
      }
    };

    Literal.prototype.compileNode = function(o) {
      var answer, code, _ref2;
      if (this.icedLoopFlag && this.icedIsJump()) {
        return this.icedCompileIced(o);
      }
      code = this.value === 'this' ? ((_ref2 = o.scope.method) != null ? _ref2.bound : void 0) ? o.scope.method.context : this.value : this.value.reserved ? "\"" + this.value + "\"" : this.value;
      answer = this.isStatement() ? "" + this.tab + code + ";" : code;
      return [this.makeCode(answer)];
    };

    Literal.prototype.toString = function() {
      return ' "' + this.value + '"';
    };

    Literal.prototype.icedWalkAst = function(parent, o) {
      if (this.value === 'arguments' && o.foundAwaitFunc) {
        o.foundArguments = true;
        this.value = "_arguments";
      }
      return false;
    };

    Literal.prototype.icedIsJump = function() {
      var _ref2;
      return (_ref2 = this.value) === 'break' || _ref2 === 'continue';
    };

    Literal.prototype.icedCompileIced = function(o) {
      var call, d, func, l;
      d = {
        'continue': iced["const"].c_while,
        'break': iced["const"].b_while
      };
      l = d[this.value];
      func = new Value(new Literal(l));
      call = new Call(func, []);
      return call.compileNode(o);
    };

    return Literal;

  })(Base);

  exports.Undefined = (function(_super) {
    __extends(Undefined, _super);

    function Undefined() {
      return Undefined.__super__.constructor.apply(this, arguments);
    }

    Undefined.prototype.isAssignable = NO;

    Undefined.prototype.isComplex = NO;

    Undefined.prototype.compileNode = function(o) {
      return [this.makeCode(o.level >= LEVEL_ACCESS ? '(void 0)' : 'void 0')];
    };

    return Undefined;

  })(Base);

  exports.Null = (function(_super) {
    __extends(Null, _super);

    function Null() {
      return Null.__super__.constructor.apply(this, arguments);
    }

    Null.prototype.isAssignable = NO;

    Null.prototype.isComplex = NO;

    Null.prototype.compileNode = function() {
      return [this.makeCode("null")];
    };

    return Null;

  })(Base);

  exports.Bool = (function(_super) {
    __extends(Bool, _super);

    Bool.prototype.isAssignable = NO;

    Bool.prototype.isComplex = NO;

    Bool.prototype.compileNode = function() {
      return [this.makeCode(this.val)];
    };

    function Bool(val) {
      this.val = val;
    }

    return Bool;

  })(Base);

  exports.Return = Return = (function(_super) {
    __extends(Return, _super);

    function Return(expression, auto) {
      this.expression = expression;
      Return.__super__.constructor.call(this);
      this.icedHasAutocbFlag = auto;
    }

    Return.prototype.children = ['expression'];

    Return.prototype.isStatement = YES;

    Return.prototype.makeReturn = THIS;

    Return.prototype.jumps = THIS;

    Return.prototype.compileToFragments = function(o, level) {
      var expr, _ref2;
      expr = (_ref2 = this.expression) != null ? _ref2.makeReturn() : void 0;
      if (expr && !(expr instanceof Return)) {
        return expr.compileToFragments(o, level);
      } else {
        return Return.__super__.compileToFragments.call(this, o, level);
      }
    };

    Return.prototype.compileNode = function(o) {
      var answer;
      if (this.icedHasAutocbFlag) {
        return this.icedCompileIced(o);
      }
      answer = [];
      answer.push(this.makeCode(this.tab + ("return" + (this.expression ? " " : ""))));
      if (this.expression) {
        answer = answer.concat(this.expression.compileToFragments(o, LEVEL_PAREN));
      }
      answer.push(this.makeCode(";"));
      return answer;
    };

    Return.prototype.icedCompileIced = function(o) {
      var args, block, call, cb, ret;
      cb = new Value(new Literal(iced["const"].autocb));
      args = this.expression ? [this.expression] : [];
      call = new Call(cb, args);
      ret = new Literal("return");
      block = new Block([call, ret]);
      return block.compileNode(o);
    };

    return Return;

  })(Base);

  exports.Value = Value = (function(_super) {
    __extends(Value, _super);

    function Value(base, props, tag) {
      Value.__super__.constructor.call(this);
      if (!props && base instanceof Value) {
        return base;
      }
      this.base = base;
      this.properties = props || [];
      if (tag) {
        this[tag] = true;
      }
      return this;
    }

    Value.prototype.children = ['base', 'properties'];

    Value.prototype.copy = function() {
      return new Value(this.base, this.properties);
    };

    Value.prototype.add = function(props) {
      this.properties = this.properties.concat(props);
      return this;
    };

    Value.prototype.hasProperties = function() {
      return !!this.properties.length;
    };

    Value.prototype.bareLiteral = function(type) {
      return !this.properties.length && this.base instanceof type;
    };

    Value.prototype.isArray = function() {
      return this.bareLiteral(Arr);
    };

    Value.prototype.isRange = function() {
      return this.bareLiteral(Range);
    };

    Value.prototype.isComplex = function() {
      return this.hasProperties() || this.base.isComplex();
    };

    Value.prototype.isAssignable = function() {
      return this.hasProperties() || this.base.isAssignable();
    };

    Value.prototype.isSimpleNumber = function() {
      return this.bareLiteral(Literal) && SIMPLENUM.test(this.base.value);
    };

    Value.prototype.isString = function() {
      return this.bareLiteral(Literal) && IS_STRING.test(this.base.value);
    };

    Value.prototype.isRegex = function() {
      return this.bareLiteral(Literal) && IS_REGEX.test(this.base.value);
    };

    Value.prototype.isAtomic = function() {
      var node, _i, _len, _ref2;
      _ref2 = this.properties.concat(this.base);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        node = _ref2[_i];
        if (node.soak || node instanceof Call) {
          return false;
        }
      }
      return true;
    };

    Value.prototype.isNotCallable = function() {
      return this.isSimpleNumber() || this.isString() || this.isRegex() || this.isArray() || this.isRange() || this.isSplice() || this.isObject();
    };

    Value.prototype.isStatement = function(o) {
      return !this.properties.length && this.base.isStatement(o);
    };

    Value.prototype.assigns = function(name) {
      return !this.properties.length && this.base.assigns(name);
    };

    Value.prototype.jumps = function(o) {
      return !this.properties.length && this.base.jumps(o);
    };

    Value.prototype.isObject = function(onlyGenerated) {
      if (this.properties.length) {
        return false;
      }
      return (this.base instanceof Obj) && (!onlyGenerated || this.base.generated);
    };

    Value.prototype.isSplice = function() {
      return last(this.properties) instanceof Slice;
    };

    Value.prototype.looksStatic = function(className) {
      var _ref2;
      return this.base.value === className && this.properties.length && ((_ref2 = this.properties[0].name) != null ? _ref2.value : void 0) !== 'prototype';
    };

    Value.prototype.unwrap = function() {
      if (this.properties.length) {
        return this;
      } else {
        return this.base;
      }
    };

    Value.prototype.cacheReference = function(o) {
      var base, bref, name, nref;
      name = last(this.properties);
      if (this.properties.length < 2 && !this.base.isComplex() && !(name != null ? name.isComplex() : void 0)) {
        return [this, this];
      }
      base = new Value(this.base, this.properties.slice(0, -1));
      if (base.isComplex()) {
        bref = new Literal(o.scope.freeVariable('base'));
        base = new Value(new Parens(new Assign(bref, base)));
      }
      if (!name) {
        return [base, bref];
      }
      if (name.isComplex()) {
        nref = new Literal(o.scope.freeVariable('name'));
        name = new Index(new Assign(nref, name.index));
        nref = new Index(nref);
      }
      return [base.add(name), new Value(bref || base.base, [nref || name])];
    };

    Value.prototype.compileNode = function(o) {
      var fragments, prop, props, _i, _len;
      this.base.front = this.front;
      props = this.properties;
      fragments = this.base.compileToFragments(o, (props.length ? LEVEL_ACCESS : null));
      if ((this.base instanceof Parens || props.length) && SIMPLENUM.test(fragmentsToText(fragments))) {
        fragments.push(this.makeCode('.'));
      }
      for (_i = 0, _len = props.length; _i < _len; _i++) {
        prop = props[_i];
        fragments.push.apply(fragments, prop.compileToFragments(o));
      }
      return fragments;
    };

    Value.prototype.unfoldSoak = function(o) {
      return this.unfoldedSoak != null ? this.unfoldedSoak : this.unfoldedSoak = (function(_this) {
        return function() {
          var fst, i, ifn, prop, ref, snd, _i, _len, _ref2, _ref3;
          if (ifn = _this.base.unfoldSoak(o)) {
            (_ref2 = ifn.body.properties).push.apply(_ref2, _this.properties);
            return ifn;
          }
          _ref3 = _this.properties;
          for (i = _i = 0, _len = _ref3.length; _i < _len; i = ++_i) {
            prop = _ref3[i];
            if (!prop.soak) {
              continue;
            }
            prop.soak = false;
            fst = new Value(_this.base, _this.properties.slice(0, i));
            snd = new Value(_this.base, _this.properties.slice(i));
            if (fst.isComplex()) {
              ref = new Literal(o.scope.freeVariable('ref'));
              fst = new Parens(new Assign(ref, fst));
              snd.base = ref;
            }
            return new If(new Existence(fst), snd, {
              soak: true
            });
          }
          return false;
        };
      })(this)();
    };

    Value.prototype.icedToSlot = function(i) {
      var suffix;
      if (this.base instanceof Obj) {
        return this.base.icedToSlot(i);
      }
      suffix = null;
      if (this.properties && this.properties.length) {
        suffix = this.properties.pop();
      }
      return new Slot(i, this, suffix);
    };

    Value.prototype.icedToSlotAccess = function() {
      if (this["this"]) {
        return this.properties[0];
      } else {
        return new Access(this);
      }
    };

    return Value;

  })(Base);

  exports.Comment = Comment = (function(_super) {
    __extends(Comment, _super);

    function Comment(comment) {
      this.comment = comment;
      Comment.__super__.constructor.call(this);
    }

    Comment.prototype.isStatement = YES;

    Comment.prototype.makeReturn = THIS;

    Comment.prototype.compileNode = function(o, level) {
      var code, comment;
      comment = this.comment.replace(/^(\s*)# /gm, "$1 * ");
      code = "/*" + (multident(comment, this.tab)) + (__indexOf.call(comment, '\n') >= 0 ? "\n" + this.tab : '') + " */";
      if ((level || o.level) === LEVEL_TOP) {
        code = o.indent + code;
      }
      return [this.makeCode("\n"), this.makeCode(code)];
    };

    return Comment;

  })(Base);

  exports.Call = Call = (function(_super) {
    __extends(Call, _super);

    function Call(variable, args, soak) {
      this.args = args != null ? args : [];
      this.soak = soak;
      Call.__super__.constructor.call(this);
      this.isNew = false;
      this.isSuper = variable === 'super';
      this.variable = this.isSuper ? null : variable;
      if (variable instanceof Value && variable.isNotCallable()) {
        variable.error("literal is not a function");
      }
    }

    Call.prototype.children = ['variable', 'args'];

    Call.prototype.newInstance = function() {
      var base, _ref2;
      base = ((_ref2 = this.variable) != null ? _ref2.base : void 0) || this.variable;
      if (base instanceof Call && !base.isNew) {
        base.newInstance();
      } else {
        this.isNew = true;
      }
      return this;
    };

    Call.prototype.superReference = function(o) {
      var accesses, method;
      method = o.scope.namedMethod();
      if (method != null ? method.klass : void 0) {
        accesses = [new Access(new Literal('__super__'))];
        if (method["static"]) {
          accesses.push(new Access(new Literal('constructor')));
        }
        accesses.push(new Access(new Literal(method.name)));
        return (new Value(new Literal(method.klass), accesses)).compile(o);
      } else if (method != null ? method.ctor : void 0) {
        return "" + method.name + ".__super__.constructor";
      } else {
        return this.error('cannot call super outside of an instance method.');
      }
    };

    Call.prototype.superThis = function(o) {
      var method;
      if (o.scope.icedgen) {
        return "_this";
      } else {
        method = o.scope.method;
        return (method && !method.klass && method.context) || "this";
      }
    };

    Call.prototype.unfoldSoak = function(o) {
      var call, ifn, left, list, rite, _i, _len, _ref2, _ref3;
      if (this.soak) {
        if (this.variable) {
          if (ifn = unfoldSoak(o, this, 'variable')) {
            return ifn;
          }
          _ref2 = new Value(this.variable).cacheReference(o), left = _ref2[0], rite = _ref2[1];
        } else {
          left = new Literal(this.superReference(o));
          rite = new Value(left);
        }
        rite = new Call(rite, this.args);
        rite.isNew = this.isNew;
        left = new Literal("typeof " + (left.compile(o)) + " === \"function\"");
        return new If(left, new Value(rite), {
          soak: true
        });
      }
      call = this;
      list = [];
      while (true) {
        if (call.variable instanceof Call) {
          list.push(call);
          call = call.variable;
          continue;
        }
        if (!(call.variable instanceof Value)) {
          break;
        }
        list.push(call);
        if (!((call = call.variable.base) instanceof Call)) {
          break;
        }
      }
      _ref3 = list.reverse();
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        call = _ref3[_i];
        if (ifn) {
          if (call.variable instanceof Call) {
            call.variable = ifn;
          } else {
            call.variable.base = ifn;
          }
        }
        ifn = unfoldSoak(o, call, 'variable');
      }
      return ifn;
    };

    Call.prototype.compileNode = function(o) {
      var arg, argIndex, compiledArgs, compiledArray, fragments, preface, _i, _len, _ref2, _ref3;
      if ((_ref2 = this.variable) != null) {
        _ref2.front = this.front;
      }
      compiledArray = Splat.compileSplattedArray(o, this.args, true);
      if (compiledArray.length) {
        return this.compileSplat(o, compiledArray);
      }
      compiledArgs = [];
      _ref3 = this.args;
      for (argIndex = _i = 0, _len = _ref3.length; _i < _len; argIndex = ++_i) {
        arg = _ref3[argIndex];
        arg.icedStatementAssertion();
        if (argIndex) {
          compiledArgs.push(this.makeCode(", "));
        }
        compiledArgs.push.apply(compiledArgs, arg.compileToFragments(o, LEVEL_LIST));
      }
      fragments = [];
      if (this.isSuper) {
        preface = this.superReference(o) + (".call(" + (this.superThis(o)));
        if (compiledArgs.length) {
          preface += ", ";
        }
        fragments.push(this.makeCode(preface));
      } else {
        if (this.isNew) {
          fragments.push(this.makeCode('new '));
        }
        fragments.push.apply(fragments, this.variable.compileToFragments(o, LEVEL_ACCESS));
        fragments.push(this.makeCode("("));
      }
      fragments.push.apply(fragments, compiledArgs);
      fragments.push(this.makeCode(")"));
      return fragments;
    };

    Call.prototype.compileSplat = function(o, splatArgs) {
      var answer, base, fun, idt, name, ref;
      if (this.isSuper) {
        return [].concat(this.makeCode("" + (this.superReference(o)) + ".apply(" + (this.superThis(o)) + ", "), splatArgs, this.makeCode(")"));
      }
      if (this.isNew) {
        idt = this.tab + TAB;
        return [].concat(this.makeCode("(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args);\n" + idt + "return Object(result) === result ? result : child;\n" + this.tab + "})("), this.variable.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), splatArgs, this.makeCode(", function(){})"));
      }
      answer = [];
      base = new Value(this.variable);
      if ((name = base.properties.pop()) && base.isComplex()) {
        ref = o.scope.freeVariable('ref');
        answer = answer.concat(this.makeCode("(" + ref + " = "), base.compileToFragments(o, LEVEL_LIST), this.makeCode(")"), name.compileToFragments(o));
      } else {
        fun = base.compileToFragments(o, LEVEL_ACCESS);
        if (SIMPLENUM.test(fragmentsToText(fun))) {
          fun = this.wrapInBraces(fun);
        }
        if (name) {
          ref = fragmentsToText(fun);
          fun.push.apply(fun, name.compileToFragments(o));
        } else {
          ref = 'null';
        }
        answer = answer.concat(fun);
      }
      return answer = answer.concat(this.makeCode(".apply(" + ref + ", "), splatArgs, this.makeCode(")"));
    };

    return Call;

  })(Base);

  exports.Extends = Extends = (function(_super) {
    __extends(Extends, _super);

    function Extends(child, parent) {
      this.child = child;
      this.parent = parent;
      Extends.__super__.constructor.call(this);
    }

    Extends.prototype.children = ['child', 'parent'];

    Extends.prototype.compileToFragments = function(o) {
      return new Call(new Value(new Literal(utility('extends'))), [this.child, this.parent]).compileToFragments(o);
    };

    return Extends;

  })(Base);

  exports.Access = Access = (function(_super) {
    __extends(Access, _super);

    function Access(name, tag) {
      this.name = name;
      Access.__super__.constructor.call(this);
      this.name.asKey = true;
      this.soak = tag === 'soak';
    }

    Access.prototype.children = ['name'];

    Access.prototype.compileToFragments = function(o) {
      var name;
      name = this.name.compileToFragments(o);
      if ((IDENTIFIER.test(fragmentsToText(name))) || this.name instanceof Defer) {
        name.unshift(this.makeCode("."));
      } else {
        name.unshift(this.makeCode("["));
        name.push(this.makeCode("]"));
      }
      return name;
    };

    Access.prototype.isComplex = NO;

    return Access;

  })(Base);

  exports.Index = Index = (function(_super) {
    __extends(Index, _super);

    function Index(index) {
      this.index = index;
      Index.__super__.constructor.call(this);
    }

    Index.prototype.children = ['index'];

    Index.prototype.compileToFragments = function(o) {
      return [].concat(this.makeCode("["), this.index.compileToFragments(o, LEVEL_PAREN), this.makeCode("]"));
    };

    Index.prototype.isComplex = function() {
      return this.index.isComplex();
    };

    return Index;

  })(Base);

  exports.Range = Range = (function(_super) {
    __extends(Range, _super);

    Range.prototype.children = ['from', 'to'];

    function Range(from, to, tag) {
      this.from = from;
      this.to = to;
      Range.__super__.constructor.call(this);
      this.exclusive = tag === 'exclusive';
      this.equals = this.exclusive ? '' : '=';
    }

    Range.prototype.compileVariables = function(o) {
      var step, _ref2, _ref3, _ref4, _ref5;
      o = merge(o, {
        top: true
      });
      _ref2 = this.cacheToCodeFragments(this.from.cache(o, LEVEL_LIST)), this.fromC = _ref2[0], this.fromVar = _ref2[1];
      _ref3 = this.cacheToCodeFragments(this.to.cache(o, LEVEL_LIST)), this.toC = _ref3[0], this.toVar = _ref3[1];
      if (step = del(o, 'step')) {
        _ref4 = this.cacheToCodeFragments(step.cache(o, LEVEL_LIST)), this.step = _ref4[0], this.stepVar = _ref4[1];
      }
      _ref5 = [this.fromVar.match(NUMBER), this.toVar.match(NUMBER)], this.fromNum = _ref5[0], this.toNum = _ref5[1];
      if (this.stepVar) {
        return this.stepNum = this.stepVar.match(NUMBER);
      }
    };

    Range.prototype.compileNode = function(o) {
      var cond, condPart, from, gt, idx, idxName, known, lt, namedIndex, stepPart, to, varPart, _ref2, _ref3;
      if (!this.fromVar) {
        this.compileVariables(o);
      }
      if (!o.index) {
        return this.compileArray(o);
      }
      known = this.fromNum && this.toNum;
      idx = del(o, 'index');
      idxName = del(o, 'name');
      namedIndex = idxName && idxName !== idx;
      varPart = "" + idx + " = " + this.fromC;
      if (this.toC !== this.toVar) {
        varPart += ", " + this.toC;
      }
      if (this.step !== this.stepVar) {
        varPart += ", " + this.step;
      }
      _ref2 = ["" + idx + " <" + this.equals, "" + idx + " >" + this.equals], lt = _ref2[0], gt = _ref2[1];
      condPart = this.stepNum ? parseNum(this.stepNum[0]) > 0 ? "" + lt + " " + this.toVar : "" + gt + " " + this.toVar : known ? ((_ref3 = [parseNum(this.fromNum[0]), parseNum(this.toNum[0])], from = _ref3[0], to = _ref3[1], _ref3), from <= to ? "" + lt + " " + to : "" + gt + " " + to) : (cond = this.stepVar ? "" + this.stepVar + " > 0" : "" + this.fromVar + " <= " + this.toVar, "" + cond + " ? " + lt + " " + this.toVar + " : " + gt + " " + this.toVar);
      stepPart = this.stepVar ? "" + idx + " += " + this.stepVar : known ? namedIndex ? from <= to ? "++" + idx : "--" + idx : from <= to ? "" + idx + "++" : "" + idx + "--" : namedIndex ? "" + cond + " ? ++" + idx + " : --" + idx : "" + cond + " ? " + idx + "++ : " + idx + "--";
      if (namedIndex) {
        varPart = "" + idxName + " = " + varPart;
      }
      if (namedIndex) {
        stepPart = "" + idxName + " = " + stepPart;
      }
      return [this.makeCode("" + varPart + "; " + condPart + "; " + stepPart)];
    };

    Range.prototype.compileArray = function(o) {
      var args, body, cond, hasArgs, i, idt, post, pre, range, result, vars, _i, _ref2, _ref3, _results;
      if (this.fromNum && this.toNum && Math.abs(this.fromNum - this.toNum) <= 20) {
        range = (function() {
          _results = [];
          for (var _i = _ref2 = +this.fromNum, _ref3 = +this.toNum; _ref2 <= _ref3 ? _i <= _ref3 : _i >= _ref3; _ref2 <= _ref3 ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this);
        if (this.exclusive) {
          range.pop();
        }
        return [this.makeCode("[" + (range.join(', ')) + "]")];
      }
      idt = this.tab + TAB;
      i = o.scope.freeVariable('i');
      result = o.scope.freeVariable('results');
      pre = "\n" + idt + result + " = [];";
      if (this.fromNum && this.toNum) {
        o.index = i;
        body = fragmentsToText(this.compileNode(o));
      } else {
        vars = ("" + i + " = " + this.fromC) + (this.toC !== this.toVar ? ", " + this.toC : '');
        cond = "" + this.fromVar + " <= " + this.toVar;
        body = "var " + vars + "; " + cond + " ? " + i + " <" + this.equals + " " + this.toVar + " : " + i + " >" + this.equals + " " + this.toVar + "; " + cond + " ? " + i + "++ : " + i + "--";
      }
      post = "{ " + result + ".push(" + i + "); }\n" + idt + "return " + result + ";\n" + o.indent;
      hasArgs = function(node) {
        return node != null ? node.contains(isLiteralArguments) : void 0;
      };
      if (hasArgs(this.from) || hasArgs(this.to)) {
        args = ', arguments';
      }
      return [this.makeCode("(function() {" + pre + "\n" + idt + "for (" + body + ")" + post + "}).apply(this" + (args != null ? args : '') + ")")];
    };

    return Range;

  })(Base);

  exports.Slice = Slice = (function(_super) {
    __extends(Slice, _super);

    Slice.prototype.children = ['range'];

    function Slice(range) {
      this.range = range;
      Slice.__super__.constructor.call(this);
    }

    Slice.prototype.compileNode = function(o) {
      var compiled, compiledText, from, fromCompiled, to, toStr, _ref2;
      _ref2 = this.range, to = _ref2.to, from = _ref2.from;
      fromCompiled = from && from.compileToFragments(o, LEVEL_PAREN) || [this.makeCode('0')];
      if (to) {
        compiled = to.compileToFragments(o, LEVEL_PAREN);
        compiledText = fragmentsToText(compiled);
        if (!(!this.range.exclusive && +compiledText === -1)) {
          toStr = ', ' + (this.range.exclusive ? compiledText : SIMPLENUM.test(compiledText) ? "" + (+compiledText + 1) : (compiled = to.compileToFragments(o, LEVEL_ACCESS), "+" + (fragmentsToText(compiled)) + " + 1 || 9e9"));
        }
      }
      return [this.makeCode(".slice(" + (fragmentsToText(fromCompiled)) + (toStr || '') + ")")];
    };

    return Slice;

  })(Base);

  exports.Obj = Obj = (function(_super) {
    __extends(Obj, _super);

    function Obj(props, generated) {
      this.generated = generated != null ? generated : false;
      this.objects = this.properties = props || [];
      Obj.__super__.constructor.call(this);
    }

    Obj.prototype.children = ['properties'];

    Obj.prototype.compileNode = function(o) {
      var answer, i, idt, indent, join, lastNoncom, node, prop, props, _i, _j, _len, _len1;
      props = this.properties;
      if (!props.length) {
        return [this.makeCode(this.front ? '({})' : '{}')];
      }
      if (this.generated) {
        for (_i = 0, _len = props.length; _i < _len; _i++) {
          node = props[_i];
          if (node instanceof Value) {
            node.error('cannot have an implicit value in an implicit object');
          }
        }
      }
      idt = o.indent += TAB;
      lastNoncom = this.lastNonComment(this.properties);
      answer = [];
      for (i = _j = 0, _len1 = props.length; _j < _len1; i = ++_j) {
        prop = props[i];
        join = i === props.length - 1 ? '' : prop === lastNoncom || prop instanceof Comment ? '\n' : ',\n';
        indent = prop instanceof Comment ? '' : idt;
        if (prop instanceof Assign && prop.variable instanceof Value && prop.variable.hasProperties()) {
          prop.variable.error('Invalid object key');
        }
        if (prop instanceof Value && prop["this"]) {
          prop = new Assign(prop.properties[0].name, prop, 'object');
        }
        if (!(prop instanceof Comment)) {
          if (!(prop instanceof Assign)) {
            prop = new Assign(prop, prop, 'object');
          }
          (prop.variable.base || prop.variable).asKey = true;
        }
        if (indent) {
          answer.push(this.makeCode(indent));
        }
        answer.push.apply(answer, prop.compileToFragments(o, LEVEL_TOP));
        if (join) {
          answer.push(this.makeCode(join));
        }
      }
      answer.unshift(this.makeCode("{" + (props.length && '\n')));
      answer.push(this.makeCode("" + (props.length && '\n' + this.tab) + "}"));
      if (this.front) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Obj.prototype.assigns = function(name) {
      var prop, _i, _len, _ref2;
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (prop.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    Obj.prototype.icedToSlot = function(i) {
      var access, prop, _i, _len, _ref2, _results;
      _ref2 = this.properties;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        prop = _ref2[_i];
        if (prop instanceof Assign) {
          _results.push((prop.value.icedToSlot(i)).addAccess(prop.variable.icedToSlotAccess()));
        } else if (prop instanceof Value) {
          access = prop.icedToSlotAccess();
          _results.push((prop.icedToSlot(i)).addAccess(access));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    return Obj;

  })(Base);

  exports.Arr = Arr = (function(_super) {
    __extends(Arr, _super);

    function Arr(objs) {
      this.objects = objs || [];
      Arr.__super__.constructor.call(this);
    }

    Arr.prototype.children = ['objects'];

    Arr.prototype.compileNode = function(o) {
      var answer, compiledObjs, fragments, index, obj, _i, _len;
      if (!this.objects.length) {
        return [this.makeCode('[]')];
      }
      o.indent += TAB;
      answer = Splat.compileSplattedArray(o, this.objects);
      if (answer.length) {
        return answer;
      }
      answer = [];
      compiledObjs = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.objects;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          obj = _ref2[_i];
          _results.push(obj.compileToFragments(o, LEVEL_LIST));
        }
        return _results;
      }).call(this);
      for (index = _i = 0, _len = compiledObjs.length; _i < _len; index = ++_i) {
        fragments = compiledObjs[index];
        if (index) {
          answer.push(this.makeCode(", "));
        }
        answer.push.apply(answer, fragments);
      }
      if (fragmentsToText(answer).indexOf('\n') >= 0) {
        answer.unshift(this.makeCode("[\n" + o.indent));
        answer.push(this.makeCode("\n" + this.tab + "]"));
      } else {
        answer.unshift(this.makeCode("["));
        answer.push(this.makeCode("]"));
      }
      return answer;
    };

    Arr.prototype.assigns = function(name) {
      var obj, _i, _len, _ref2;
      _ref2 = this.objects;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        obj = _ref2[_i];
        if (obj.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    return Arr;

  })(Base);

  exports.Class = Class = (function(_super) {
    __extends(Class, _super);

    function Class(variable, parent, body) {
      this.variable = variable;
      this.parent = parent;
      this.body = body != null ? body : new Block;
      Class.__super__.constructor.call(this);
      this.boundFuncs = [];
      this.body.classBody = true;
    }

    Class.prototype.children = ['variable', 'parent', 'body'];

    Class.prototype.determineName = function() {
      var decl, tail;
      if (!this.variable) {
        return null;
      }
      decl = (tail = last(this.variable.properties)) ? tail instanceof Access && tail.name.value : this.variable.base.value;
      if (__indexOf.call(STRICT_PROSCRIBED, decl) >= 0) {
        this.variable.error("class variable name may not be " + decl);
      }
      return decl && (decl = IDENTIFIER.test(decl) && decl);
    };

    Class.prototype.setContext = function(name) {
      return this.body.traverseChildren(false, function(node) {
        if (node.classBody) {
          return false;
        }
        if (node instanceof Literal && node.value === 'this') {
          return node.value = name;
        } else if (node instanceof Code) {
          node.klass = name;
          if (node.bound) {
            return node.context = name;
          }
        }
      });
    };

    Class.prototype.addBoundFunctions = function(o) {
      var bvar, lhs, _i, _len, _ref2;
      _ref2 = this.boundFuncs;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        bvar = _ref2[_i];
        lhs = (new Value(new Literal("this"), [new Access(bvar)])).compile(o);
        this.ctor.body.unshift(new Literal("" + lhs + " = " + (utility('bind')) + "(" + lhs + ", this)"));
      }
    };

    Class.prototype.addProperties = function(node, name, o) {
      var assign, base, exprs, func, props;
      props = node.base.properties.slice(0);
      exprs = (function() {
        var _results;
        _results = [];
        while (assign = props.shift()) {
          if (assign instanceof Assign) {
            base = assign.variable.base;
            delete assign.context;
            func = assign.value;
            if (base.value === 'constructor') {
              if (this.ctor) {
                assign.error('cannot define more than one constructor in a class');
              }
              if (func.bound) {
                assign.error('cannot define a constructor as a bound function');
              }
              if (func instanceof Code) {
                assign = this.ctor = func;
              } else {
                this.externalCtor = o.classScope.freeVariable('class');
                assign = new Assign(new Literal(this.externalCtor), func);
              }
            } else {
              if (assign.variable["this"]) {
                func["static"] = true;
              } else {
                assign.variable = new Value(new Literal(name), [new Access(new Literal('prototype')), new Access(base)]);
                if (func instanceof Code && func.bound) {
                  this.boundFuncs.push(base);
                  func.bound = false;
                }
              }
            }
          }
          _results.push(assign);
        }
        return _results;
      }).call(this);
      return compact(exprs);
    };

    Class.prototype.walkBody = function(name, o) {
      return this.traverseChildren(false, (function(_this) {
        return function(child) {
          var cont, exps, i, node, _i, _len, _ref2;
          cont = true;
          if (child instanceof Class) {
            return false;
          }
          if (child instanceof Block) {
            _ref2 = exps = child.expressions;
            for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
              node = _ref2[i];
              if (node instanceof Assign && node.variable.looksStatic(name)) {
                node.value["static"] = true;
              } else if (node instanceof Value && node.isObject(true)) {
                cont = false;
                exps[i] = _this.addProperties(node, name, o);
              }
            }
            child.expressions = exps = flatten(exps);
          }
          return cont && !(child instanceof Class);
        };
      })(this));
    };

    Class.prototype.hoistDirectivePrologue = function() {
      var expressions, index, node;
      index = 0;
      expressions = this.body.expressions;
      while ((node = expressions[index]) && node instanceof Comment || node instanceof Value && node.isString()) {
        ++index;
      }
      return this.directives = expressions.splice(0, index);
    };

    Class.prototype.ensureConstructor = function(name) {
      if (!this.ctor) {
        this.ctor = new Code;
        if (this.externalCtor) {
          this.ctor.body.push(new Literal("" + this.externalCtor + ".apply(this, arguments)"));
        } else if (this.parent) {
          this.ctor.body.push(new Literal("" + name + ".__super__.constructor.apply(this, arguments)"));
        }
        this.ctor.body.makeReturn();
        this.body.expressions.unshift(this.ctor);
      }
      this.ctor.ctor = this.ctor.name = name;
      this.ctor.klass = null;
      return this.ctor.noReturn = true;
    };

    Class.prototype.compileNode = function(o) {
      var args, argumentsNode, func, jumpNode, klass, lname, name, superClass, _ref2;
      if (jumpNode = this.body.jumps()) {
        jumpNode.error('Class bodies cannot contain pure statements');
      }
      if (argumentsNode = this.body.contains(isLiteralArguments)) {
        argumentsNode.error("Class bodies shouldn't reference arguments");
      }
      name = this.determineName() || '_Class';
      if (name.reserved) {
        name = "_" + name;
      }
      lname = new Literal(name);
      func = new Code([], Block.wrap([this.body]));
      args = [];
      o.classScope = func.makeScope(o.scope);
      this.hoistDirectivePrologue();
      this.setContext(name);
      this.walkBody(name, o);
      this.ensureConstructor(name);
      this.addBoundFunctions(o);
      this.body.spaced = true;
      this.body.expressions.push(lname);
      if (this.parent) {
        superClass = new Literal(o.classScope.freeVariable('super', false));
        this.body.expressions.unshift(new Extends(lname, superClass));
        func.params.push(new Param(superClass));
        args.push(this.parent);
      }
      (_ref2 = this.body.expressions).unshift.apply(_ref2, this.directives);
      klass = new Parens(new Call(func, args));
      if (this.variable) {
        klass = new Assign(this.variable, klass);
      }
      return klass.compileToFragments(o);
    };

    return Class;

  })(Base);

  exports.Assign = Assign = (function(_super) {
    __extends(Assign, _super);

    function Assign(variable, value, context, options) {
      var forbidden, name, _ref2;
      this.variable = variable;
      this.value = value;
      this.context = context;
      Assign.__super__.constructor.call(this);
      this.param = options && options.param;
      this.subpattern = options && options.subpattern;
      forbidden = (_ref2 = (name = this.variable.unwrapAll().value), __indexOf.call(STRICT_PROSCRIBED, _ref2) >= 0);
      if (forbidden && this.context !== 'object') {
        this.variable.error("variable name may not be \"" + name + "\"");
      }
      this.icedlocal = options && options.icedlocal;
    }

    Assign.prototype.children = ['variable', 'value'];

    Assign.prototype.isStatement = function(o) {
      return (o != null ? o.level : void 0) === LEVEL_TOP && (this.context != null) && __indexOf.call(this.context, "?") >= 0;
    };

    Assign.prototype.assigns = function(name) {
      return this[this.context === 'object' ? 'value' : 'variable'].assigns(name);
    };

    Assign.prototype.unfoldSoak = function(o) {
      return unfoldSoak(o, this, 'variable');
    };

    Assign.prototype.compileNode = function(o) {
      var answer, compiledName, isValue, match, name, val, varBase, _ref2, _ref3, _ref4, _ref5;
      this.value.icedStatementAssertion();
      if (isValue = this.variable instanceof Value) {
        if (this.variable.isArray() || this.variable.isObject()) {
          return this.compilePatternMatch(o);
        }
        if (this.variable.isSplice()) {
          return this.compileSplice(o);
        }
        if ((_ref2 = this.context) === '||=' || _ref2 === '&&=' || _ref2 === '?=') {
          return this.compileConditional(o);
        }
        if ((_ref3 = this.context) === '**=' || _ref3 === '//=' || _ref3 === '%%=') {
          return this.compileSpecialMath(o);
        }
      }
      compiledName = this.variable.compileToFragments(o, LEVEL_LIST);
      name = fragmentsToText(compiledName);
      if (!this.context) {
        varBase = this.variable.unwrapAll();
        if (!varBase.isAssignable()) {
          this.variable.error("\"" + (this.variable.compile(o)) + "\" cannot be assigned");
        }
        if (!(typeof varBase.hasProperties === "function" ? varBase.hasProperties() : void 0)) {
          if (this.param || this.icedlocal) {
            o.scope.add(name, 'var', this.icedlocal);
          } else {
            o.scope.find(name);
          }
        }
      }
      if (this.value instanceof Code && (match = METHOD_DEF.exec(name))) {
        if (match[2]) {
          this.value.klass = match[1];
        }
        this.value.name = (_ref4 = (_ref5 = match[3]) != null ? _ref5 : match[4]) != null ? _ref4 : match[5];
      }
      val = this.value.compileToFragments(o, LEVEL_LIST);
      if (this.context === 'object') {
        return compiledName.concat(this.makeCode(": "), val);
      }
      answer = compiledName.concat(this.makeCode(" " + (this.context || '=') + " "), val);
      if (o.level <= LEVEL_LIST) {
        return answer;
      } else {
        return this.wrapInBraces(answer);
      }
    };

    Assign.prototype.compilePatternMatch = function(o) {
      var acc, assigns, code, expandedIdx, fragments, i, idx, isObject, ivar, name, obj, objects, olen, ref, rest, top, val, value, vvar, vvarText, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      top = o.level === LEVEL_TOP;
      value = this.value;
      objects = this.variable.base.objects;
      if (!(olen = objects.length)) {
        code = value.compileToFragments(o);
        if (o.level >= LEVEL_OP) {
          return this.wrapInBraces(code);
        } else {
          return code;
        }
      }
      isObject = this.variable.isObject();
      if (top && olen === 1 && !((obj = objects[0]) instanceof Splat)) {
        if (obj instanceof Assign) {
          _ref2 = obj, (_ref3 = _ref2.variable, idx = _ref3.base), obj = _ref2.value;
        } else {
          idx = isObject ? obj["this"] ? obj.properties[0].name : obj : new Literal(0);
        }
        acc = IDENTIFIER.test(idx.unwrap().value || 0);
        value = new Value(value);
        value.properties.push(new (acc ? Access : Index)(idx));
        if (_ref4 = obj.unwrap().value, __indexOf.call(RESERVED, _ref4) >= 0) {
          obj.error("assignment to a reserved word: " + (obj.compile(o)));
        }
        return new Assign(obj, value, null, {
          param: this.param
        }).compileToFragments(o, LEVEL_TOP);
      }
      vvar = value.compileToFragments(o, LEVEL_LIST);
      vvarText = fragmentsToText(vvar);
      assigns = [];
      expandedIdx = false;
      if (!IDENTIFIER.test(vvarText) || this.variable.assigns(vvarText)) {
        assigns.push([this.makeCode("" + (ref = o.scope.freeVariable('ref')) + " = ")].concat(__slice.call(vvar)));
        vvar = [this.makeCode(ref)];
        vvarText = ref;
      }
      for (i = _i = 0, _len = objects.length; _i < _len; i = ++_i) {
        obj = objects[i];
        idx = i;
        if (isObject) {
          if (obj instanceof Assign) {
            _ref5 = obj, (_ref6 = _ref5.variable, idx = _ref6.base), obj = _ref5.value;
          } else {
            if (obj.base instanceof Parens) {
              _ref7 = new Value(obj.unwrapAll()).cacheReference(o), obj = _ref7[0], idx = _ref7[1];
            } else {
              idx = obj["this"] ? obj.properties[0].name : obj;
            }
          }
        }
        if (!expandedIdx && obj instanceof Splat) {
          name = obj.name.unwrap().value;
          obj = obj.unwrap();
          val = "" + olen + " <= " + vvarText + ".length ? " + (utility('slice')) + ".call(" + vvarText + ", " + i;
          if (rest = olen - i - 1) {
            ivar = o.scope.freeVariable('i');
            val += ", " + ivar + " = " + vvarText + ".length - " + rest + ") : (" + ivar + " = " + i + ", [])";
          } else {
            val += ") : []";
          }
          val = new Literal(val);
          expandedIdx = "" + ivar + "++";
        } else if (!expandedIdx && obj instanceof Expansion) {
          if (rest = olen - i - 1) {
            if (rest === 1) {
              expandedIdx = "" + vvarText + ".length - 1";
            } else {
              ivar = o.scope.freeVariable('i');
              val = new Literal("" + ivar + " = " + vvarText + ".length - " + rest);
              expandedIdx = "" + ivar + "++";
              assigns.push(val.compileToFragments(o, LEVEL_LIST));
            }
          }
          continue;
        } else {
          name = obj.unwrap().value;
          if (obj instanceof Splat || obj instanceof Expansion) {
            obj.error("multiple splats/expansions are disallowed in an assignment");
          }
          if (typeof idx === 'number') {
            idx = new Literal(expandedIdx || idx);
            acc = false;
          } else {
            acc = isObject && IDENTIFIER.test(idx.unwrap().value || 0);
          }
          val = new Value(new Literal(vvarText), [new (acc ? Access : Index)(idx)]);
        }
        if ((name != null) && __indexOf.call(RESERVED, name) >= 0) {
          obj.error("assignment to a reserved word: " + (obj.compile(o)));
        }
        assigns.push(new Assign(obj, val, null, {
          param: this.param,
          subpattern: true
        }).compileToFragments(o, LEVEL_LIST));
      }
      if (!(top || this.subpattern)) {
        assigns.push(vvar);
      }
      fragments = this.joinFragmentArrays(assigns, ', ');
      if (o.level < LEVEL_LIST) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    Assign.prototype.compileConditional = function(o) {
      var fragments, left, right, _ref2;
      _ref2 = this.variable.cacheReference(o), left = _ref2[0], right = _ref2[1];
      if (!left.properties.length && left.base instanceof Literal && left.base.value !== "this" && !o.scope.check(left.base.value)) {
        this.variable.error("the variable \"" + left.base.value + "\" can't be assigned with " + this.context + " because it has not been declared before");
      }
      if (__indexOf.call(this.context, "?") >= 0) {
        o.isExistentialEquals = true;
        return new If(new Existence(left), right, {
          type: 'if'
        }).addElse(new Assign(right, this.value, '=')).compileToFragments(o);
      } else {
        fragments = new Op(this.context.slice(0, -1), left, new Assign(right, this.value, '=')).compileToFragments(o);
        if (o.level <= LEVEL_LIST) {
          return fragments;
        } else {
          return this.wrapInBraces(fragments);
        }
      }
    };

    Assign.prototype.compileSpecialMath = function(o) {
      var left, right, _ref2;
      _ref2 = this.variable.cacheReference(o), left = _ref2[0], right = _ref2[1];
      return new Assign(left, new Op(this.context.slice(0, -1), right, this.value)).compileToFragments(o);
    };

    Assign.prototype.compileSplice = function(o) {
      var answer, exclusive, from, fromDecl, fromRef, name, to, valDef, valRef, _ref2, _ref3, _ref4;
      _ref2 = this.variable.properties.pop().range, from = _ref2.from, to = _ref2.to, exclusive = _ref2.exclusive;
      name = this.variable.compile(o);
      if (from) {
        _ref3 = this.cacheToCodeFragments(from.cache(o, LEVEL_OP)), fromDecl = _ref3[0], fromRef = _ref3[1];
      } else {
        fromDecl = fromRef = '0';
      }
      if (to) {
        if (from instanceof Value && from.isSimpleNumber() && to instanceof Value && to.isSimpleNumber()) {
          to = to.compile(o) - fromRef;
          if (!exclusive) {
            to += 1;
          }
        } else {
          to = to.compile(o, LEVEL_ACCESS) + ' - ' + fromRef;
          if (!exclusive) {
            to += ' + 1';
          }
        }
      } else {
        to = "9e9";
      }
      _ref4 = this.value.cache(o, LEVEL_LIST), valDef = _ref4[0], valRef = _ref4[1];
      answer = [].concat(this.makeCode("[].splice.apply(" + name + ", [" + fromDecl + ", " + to + "].concat("), valDef, this.makeCode(")), "), valRef);
      if (o.level > LEVEL_TOP) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    return Assign;

  })(Base);

  exports.Code = Code = (function(_super) {
    __extends(Code, _super);

    function Code(params, body, tag) {
      Code.__super__.constructor.call(this);
      this.params = params || [];
      this.body = body || new Block;
      this.icedgen = tag === 'icedgen';
      this.icedPassedDeferral = null;
      this.bound = tag === 'boundfunc' || this.icedgen;
      this.isGenerator = this.body.contains(function(node) {
        var _ref2;
        return node instanceof Op && ((_ref2 = node.operator) === 'yield' || _ref2 === 'yield*');
      });
    }

    Code.prototype.children = ['params', 'body'];

    Code.prototype.isStatement = function() {
      return !!this.ctor;
    };

    Code.prototype.jumps = NO;

    Code.prototype.makeScope = function(parentScope) {
      return new Scope(parentScope, this.body, this);
    };

    Code.prototype.compileNode = function(o) {
      var answer, boundfunc, code, exprs, i, lit, p, param, params, ref, splats, uniqs, val, wasEmpty, wrapper, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (this.bound && ((_ref2 = o.scope.method) != null ? _ref2.bound : void 0)) {
        this.context = o.scope.method.context;
      }
      if (this.bound && !this.context) {
        this.context = '_this';
        wrapper = new Code([new Param(new Literal(this.context))], new Block([this]));
        boundfunc = new Call(wrapper, [new Literal('this')]);
        boundfunc.updateLocationDataIfMissing(this.locationData);
        return boundfunc.compileNode(o);
      }
      o.scope = del(o, 'classScope') || this.makeScope(o.scope);
      o.scope.shared = del(o, 'sharedScope') || this.icedgen;
      o.scope.icedgen = this.icedgen;
      o.indent += TAB;
      delete o.bare;
      delete o.isExistentialEquals;
      params = [];
      exprs = [];
      _ref3 = this.params;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        param = _ref3[_i];
        if (!(param instanceof Expansion)) {
          o.scope.parameter(param.asReference(o));
        }
      }
      _ref4 = this.params;
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        param = _ref4[_j];
        if (!(param.splat || param instanceof Expansion)) {
          continue;
        }
        _ref5 = this.params;
        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
          p = _ref5[_k].name;
          if (!(!(param instanceof Expansion))) {
            continue;
          }
          if (p["this"]) {
            p = p.properties[0].name;
          }
          if (p.value) {
            o.scope.add(p.value, 'var', true);
          }
        }
        splats = new Assign(new Value(new Arr((function() {
          var _l, _len3, _ref6, _results;
          _ref6 = this.params;
          _results = [];
          for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
            p = _ref6[_l];
            _results.push(p.asReference(o));
          }
          return _results;
        }).call(this))), new Value(new Literal('arguments')));
        break;
      }
      _ref6 = this.params;
      for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
        param = _ref6[_l];
        if (param.isComplex()) {
          val = ref = param.asReference(o);
          if (param.value) {
            val = new Op('?', ref, param.value);
          }
          exprs.push(new Assign(new Value(param.name), val, '=', {
            param: true
          }));
        } else {
          ref = param;
          if (param.value) {
            lit = new Literal(ref.name.value + ' == null');
            val = new Assign(new Value(param.name), param.value, '=');
            exprs.push(new If(lit, val));
          }
        }
        if (!splats) {
          params.push(ref);
        }
      }
      wasEmpty = this.body.isEmpty();
      if (splats) {
        exprs.unshift(splats);
      }
      if (exprs.length) {
        (_ref7 = this.body.expressions).unshift.apply(_ref7, exprs);
      }
      for (i = _m = 0, _len4 = params.length; _m < _len4; i = ++_m) {
        p = params[i];
        params[i] = p.compileToFragments(o);
        o.scope.parameter(fragmentsToText(params[i]));
      }
      uniqs = [];
      this.eachParamName(function(name, node) {
        if (__indexOf.call(uniqs, name) >= 0) {
          node.error("multiple parameters named '" + name + "'");
        }
        return uniqs.push(name);
      });
      if (this.icedIsAutocbCode) {
        wasEmpty = false;
      }
      if (!(wasEmpty || this.noReturn)) {
        this.body.makeReturn();
      }
      code = 'function';
      if (this.isGenerator) {
        code += '*';
      }
      if (this.ctor) {
        code += ' ' + this.name;
      }
      code += '(';
      answer = [this.makeCode(code)];
      for (i = _n = 0, _len5 = params.length; _n < _len5; i = ++_n) {
        p = params[i];
        if (i) {
          answer.push(this.makeCode(", "));
        }
        answer.push.apply(answer, p);
      }
      answer.push(this.makeCode(') {'));
      this.icedPatchBody(o);
      if (!this.body.isEmpty()) {
        answer = answer.concat(this.makeCode("\n"), this.body.compileWithDeclarations(o), this.makeCode("\n" + this.tab));
      }
      answer.push(this.makeCode('}'));
      if (this.ctor) {
        return [this.makeCode(this.tab)].concat(__slice.call(answer));
      }
      if (this.front || (o.level >= LEVEL_ACCESS)) {
        return this.wrapInBraces(answer);
      } else {
        return answer;
      }
    };

    Code.prototype.eachParamName = function(iterator) {
      var param, _i, _len, _ref2, _results;
      _ref2 = this.params;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        param = _ref2[_i];
        _results.push(param.eachName(iterator));
      }
      return _results;
    };

    Code.prototype.traverseChildren = function(crossScope, func) {
      if (crossScope) {
        return Code.__super__.traverseChildren.call(this, crossScope, func);
      }
    };

    Code.prototype.icedPatchBody = function(o) {
      var f, lhs, r, rhs;
      if (this.icedFoundArguments && this.icedNodeFlag) {
        o.scope.assign('_arguments', 'arguments');
      }
      if (this.icedNodeFlag && !this.icedgen) {
        this.icedPassedDeferral = o.scope.freeVariable(iced["const"].passed_deferral);
        lhs = new Value(new Literal(this.icedPassedDeferral));
        f = new Value(new Literal(iced["const"].ns));
        f.add(new Access(new Value(new Literal(iced["const"].findDeferral))));
        rhs = new Call(f, [new Value(new Literal('arguments'))]);
        this.body.unshift(new Assign(lhs, rhs));
      }
      if (this.icedNodeFlag && !this.icedgen) {
        r = this.icedIsAutocbCode ? iced["const"].autocb : iced["const"].k_noop;
        rhs = new Value(new Literal(r));
        lhs = new Value(new Literal(iced["const"].k));
        return this.body.unshift(new Assign(lhs, rhs, null, {
          icedlocal: true
        }));
      }
    };

    Code.prototype.icedWalkAst = function(parent, o) {
      var cf_prev, fa_prev, faf_prev, fg_prev, param, _i, _len, _ref2;
      this.icedParentAwait = parent;
      fa_prev = o.foundAutocb;
      cf_prev = o.currFunc;
      fg_prev = o.foundArguments;
      faf_prev = o.foundAwaitFunc;
      o.foundAutocb = false;
      o.foundArguments = false;
      o.foundAwaitFunc = false;
      o.currFunc = this;
      _ref2 = this.params;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        param = _ref2[_i];
        if (param.name instanceof Literal && param.name.value === iced["const"].autocb) {
          o.foundAutocb = true;
          break;
        }
      }
      Code.__super__.icedWalkAst.call(this, parent, o);
      this.icedHasAutocbFlag = fa_prev;
      this.icedIsAutocbCode = o.foundAutocb;
      this.icedFoundArguments = o.foundArguments;
      o.foundAwaitFunc = faf_prev;
      o.foundArguments = fg_prev;
      o.foundAutocb = fa_prev;
      o.currFunc = cf_prev;
      return false;
    };

    Code.prototype.icedWalkAstLoops = function(flood) {
      if (Code.__super__.icedWalkAstLoops.call(this, false)) {
        this.icedLoopFlag = true;
      }
      return false;
    };

    Code.prototype.icedWalkCpsPivots = function() {
      Code.__super__.icedWalkCpsPivots.call(this);
      return this.icedCpsPivotFlag = false;
    };

    Code.prototype.icedTraceName = function() {
      var parts;
      parts = [];
      if (this.klass) {
        parts.push(this.klass);
      }
      if (this.name) {
        parts.push(this.name);
      }
      return parts.join('.');
    };

    return Code;

  })(Base);

  exports.Param = Param = (function(_super) {
    __extends(Param, _super);

    function Param(name, value, splat) {
      var _ref2;
      this.name = name;
      this.value = value;
      this.splat = splat;
      Param.__super__.constructor.call(this);
      if (_ref2 = (name = this.name.unwrapAll().value), __indexOf.call(STRICT_PROSCRIBED, _ref2) >= 0) {
        this.name.error("parameter name \"" + name + "\" is not allowed");
      }
    }

    Param.prototype.children = ['name', 'value'];

    Param.prototype.compileToFragments = function(o) {
      return this.name.compileToFragments(o, LEVEL_LIST);
    };

    Param.prototype.asReference = function(o) {
      var node;
      if (this.reference) {
        return this.reference;
      }
      node = this.name;
      if (node["this"]) {
        node = node.properties[0].name;
        if (node.value.reserved) {
          node = new Literal(o.scope.freeVariable(node.value));
        }
      } else if (node.isComplex()) {
        node = new Literal(o.scope.freeVariable('arg'));
      }
      node = new Value(node);
      if (this.splat) {
        node = new Splat(node);
      }
      node.updateLocationDataIfMissing(this.locationData);
      return this.reference = node;
    };

    Param.prototype.isComplex = function() {
      return this.name.isComplex();
    };

    Param.prototype.eachName = function(iterator, name) {
      var atParam, node, obj, _i, _len, _ref2;
      if (name == null) {
        name = this.name;
      }
      atParam = function(obj) {
        var node;
        node = obj.properties[0].name;
        if (!node.value.reserved) {
          return iterator(node.value, node);
        }
      };
      if (name instanceof Literal) {
        return iterator(name.value, name);
      }
      if (name instanceof Value) {
        return atParam(name);
      }
      _ref2 = name.objects;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        obj = _ref2[_i];
        if (obj instanceof Assign) {
          this.eachName(iterator, obj.value.unwrap());
        } else if (obj instanceof Splat) {
          node = obj.name.unwrap();
          iterator(node.value, node);
        } else if (obj instanceof Value) {
          if (obj.isArray() || obj.isObject()) {
            this.eachName(iterator, obj.base);
          } else if (obj["this"]) {
            atParam(obj);
          } else {
            iterator(obj.base.value, obj.base);
          }
        } else if (!(obj instanceof Expansion)) {
          obj.error("illegal parameter " + (obj.compile()));
        }
      }
    };

    return Param;

  })(Base);

  exports.Splat = Splat = (function(_super) {
    __extends(Splat, _super);

    Splat.prototype.children = ['name'];

    Splat.prototype.isAssignable = YES;

    function Splat(name) {
      Splat.__super__.constructor.call(this);
      this.name = name.compile ? name : new Literal(name);
    }

    Splat.prototype.assigns = function(name) {
      return this.name.assigns(name);
    };

    Splat.prototype.compileToFragments = function(o) {
      return this.name.compileToFragments(o);
    };

    Splat.prototype.unwrap = function() {
      return this.name;
    };

    Splat.compileSplattedArray = function(o, list, apply) {
      var args, base, compiledNode, concatPart, fragments, i, index, node, _i, _len;
      index = -1;
      while ((node = list[++index]) && !(node instanceof Splat)) {
        continue;
      }
      if (index >= list.length) {
        return [];
      }
      if (list.length === 1) {
        node = list[0];
        fragments = node.compileToFragments(o, LEVEL_LIST);
        if (apply) {
          return fragments;
        }
        return [].concat(node.makeCode("" + (utility('slice')) + ".call("), fragments, node.makeCode(")"));
      }
      args = list.slice(index);
      for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
        node = args[i];
        compiledNode = node.compileToFragments(o, LEVEL_LIST);
        args[i] = node instanceof Splat ? [].concat(node.makeCode("" + (utility('slice')) + ".call("), compiledNode, node.makeCode(")")) : [].concat(node.makeCode("["), compiledNode, node.makeCode("]"));
      }
      if (index === 0) {
        node = list[0];
        concatPart = node.joinFragmentArrays(args.slice(1), ', ');
        return args[0].concat(node.makeCode(".concat("), concatPart, node.makeCode(")"));
      }
      base = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = list.slice(0, index);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          node = _ref2[_j];
          _results.push(node.compileToFragments(o, LEVEL_LIST));
        }
        return _results;
      })();
      base = list[0].joinFragmentArrays(base, ', ');
      concatPart = list[index].joinFragmentArrays(args, ', ');
      return [].concat(list[0].makeCode("["), base, list[index].makeCode("].concat("), concatPart, (last(list)).makeCode(")"));
    };

    Splat.prototype.icedToSlot = function(i) {
      return new Slot(i, new Value(this.name), null, true);
    };

    return Splat;

  })(Base);

  exports.Expansion = Expansion = (function(_super) {
    __extends(Expansion, _super);

    function Expansion() {
      return Expansion.__super__.constructor.apply(this, arguments);
    }

    Expansion.prototype.isComplex = NO;

    Expansion.prototype.compileNode = function(o) {
      return this.error('Expansion must be used inside a destructuring assignment or parameter list');
    };

    Expansion.prototype.asReference = function(o) {
      return this;
    };

    Expansion.prototype.eachName = function(iterator) {};

    return Expansion;

  })(Base);

  exports.While = While = (function(_super) {
    __extends(While, _super);

    function While(condition, options) {
      this.condition = (options != null ? options.invert : void 0) ? condition.invert() : condition;
      this.guard = options != null ? options.guard : void 0;
    }

    While.prototype.children = ['condition', 'guard', 'body'];

    While.prototype.isStatement = YES;

    While.prototype.isLoop = YES;

    While.prototype.makeReturn = function(res) {
      if (res) {
        return While.__super__.makeReturn.apply(this, arguments);
      } else {
        this.returns = !this.jumps({
          loop: true
        });
        return this;
      }
    };

    While.prototype.addBody = function(body) {
      this.body = body;
      return this;
    };

    While.prototype.jumps = function() {
      var expressions, jumpNode, node, _i, _len;
      expressions = this.body.expressions;
      if (!expressions.length) {
        return false;
      }
      for (_i = 0, _len = expressions.length; _i < _len; _i++) {
        node = expressions[_i];
        if (jumpNode = node.jumps({
          loop: true
        })) {
          return jumpNode;
        }
      }
      return false;
    };

    While.prototype.compileNode = function(o) {
      var answer, body, rvar, set;
      this.condition.icedStatementAssertion();
      if (this.icedNodeFlag) {
        return this.icedCompileIced(o);
      }
      o.indent += TAB;
      set = '';
      body = this.body;
      if (body.isEmpty()) {
        body = this.makeCode('');
      } else {
        if (this.returns) {
          body.makeReturn(rvar = o.scope.freeVariable('results'));
          set = "" + this.tab + rvar + " = [];\n";
        }
        if (this.guard) {
          if (body.expressions.length > 1) {
            body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal("continue")));
          } else {
            if (this.guard) {
              body = Block.wrap([new If(this.guard, body)]);
            }
          }
        }
        body = [].concat(this.makeCode("\n"), body.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab));
      }
      answer = [].concat(this.makeCode(set + this.tab + "while ("), this.condition.compileToFragments(o, LEVEL_PAREN), this.makeCode(") {"), body, this.makeCode("}"));
      if (this.returns) {
        if (this.icedHasAutocbFlag) {
          answer.push(this.makeCode("\n" + this.tab + iced["const"].autocb + "(" + rvar + ");"));
          answer.push(this.makeCode("\n" + this.tab + "return;"));
        } else {
          answer.push(this.makeCode("\n" + this.tab + "return " + rvar + ";"));
        }
      }
      return answer;
    };

    While.prototype.icedWrap = function(d) {
      var body, break_assign, break_id, cond, condition, continue_assign, continue_block, continue_block_inner, continue_body, continue_fn, continue_id, guard_if, k_id, k_param, next_assign, next_id, outStatements, top_assign, top_block, top_body, top_call, top_func, top_id, top_statements, tramp;
      condition = d.condition;
      body = d.body;
      outStatements = [];
      top_id = new Value(new Literal(iced["const"].t_while));
      k_id = new Value(new Literal(iced["const"].k));
      k_param = new Param(new Literal(iced["const"].k));
      break_id = new Value(new Literal(iced["const"].b_while));
      break_assign = new Assign(break_id, k_id, null, {
        icedlocal: true
      });
      continue_id = new Value(new Literal(iced["const"].c_while));
      continue_block_inner = new Block([new Call(top_id, [k_id])]);
      if (d.step) {
        continue_block_inner.unshift(d.step);
      }
      continue_fn = new Code([], continue_block_inner);
      tramp = new Value(new Literal(iced["const"].ns));
      tramp.add(new Access(new Value(new Literal(iced["const"].trampoline))));
      continue_block = new Block([new Call(tramp, [continue_fn])]);
      continue_body = new Code([], continue_block, 'icedgen');
      continue_assign = new Assign(continue_id, continue_body, null, {
        icedlocal: true
      });
      next_id = new Value(new Literal(iced["const"].n_while));
      next_assign = new Assign(next_id, continue_id, null, {
        icedlocal: true
      });
      cond = new If(condition.invert(), new Block([new Call(break_id, [])]));
      if (d.guard) {
        continue_block = new Block([new Call(continue_id, [])]);
        guard_if = new If(d.guard, body);
        guard_if.addElse(continue_block);
        cond.addElse(new Block([d.pre_body, guard_if]));
      } else {
        cond.addElse(new Block([d.pre_body, body]));
      }
      top_body = new Block([break_assign, continue_assign, next_assign, cond]);
      top_func = new Code([k_param], top_body, 'icedgen');
      top_assign = new Assign(top_id, top_func, null, {
        icedlocal: true
      });
      top_call = new Call(top_id, [k_id]);
      top_statements = [];
      if (d.init) {
        top_statements = top_statements.concat(d.init);
      }
      top_statements = top_statements.concat([top_assign, top_call]);
      return top_block = new Block(top_statements);
    };

    While.prototype.icedCallContinuation = function() {
      return this.body.icedThreadReturn(new IcedTailCall(iced["const"].n_while));
    };

    While.prototype.icedCompileIced = function(o) {
      var b, opts;
      opts = {
        condition: this.condition,
        body: this.body,
        guard: this.guard
      };
      b = this.icedWrap(opts);
      return b.compileNode(o);
    };

    return While;

  })(Base);

  exports.Op = Op = (function(_super) {
    var CONVERSIONS, INVERSIONS;

    __extends(Op, _super);

    function Op(op, first, second, flip) {
      Op.__super__.constructor.call(this);
      if (op === 'in') {
        return new In(first, second);
      }
      if (op === 'do') {
        return this.generateDo(first);
      }
      if (op === 'new') {
        if (first instanceof Call && !first["do"] && !first.isNew) {
          return first.newInstance();
        }
        if (first instanceof Code && first.bound || first["do"]) {
          first = new Parens(first);
        }
      }
      this.operator = CONVERSIONS[op] || op;
      this.first = first;
      this.second = second;
      this.flip = !!flip;
      return this;
    }

    CONVERSIONS = {
      '==': '===',
      '!=': '!==',
      'of': 'in',
      'yieldfrom': 'yield*'
    };

    INVERSIONS = {
      '!==': '===',
      '===': '!=='
    };

    Op.prototype.children = ['first', 'second'];

    Op.prototype.isSimpleNumber = NO;

    Op.prototype.isYield = function() {
      var _ref2;
      return (_ref2 = this.operator) === 'yield' || _ref2 === 'yield*';
    };

    Op.prototype.isUnary = function() {
      return !this.second;
    };

    Op.prototype.isComplex = function() {
      var _ref2;
      return !(this.isUnary() && ((_ref2 = this.operator) === '+' || _ref2 === '-')) || this.first.isComplex();
    };

    Op.prototype.isChainable = function() {
      var _ref2;
      return (_ref2 = this.operator) === '<' || _ref2 === '>' || _ref2 === '>=' || _ref2 === '<=' || _ref2 === '===' || _ref2 === '!==';
    };

    Op.prototype.invert = function() {
      var allInvertable, curr, fst, op, _ref2;
      if (this.isChainable() && this.first.isChainable()) {
        allInvertable = true;
        curr = this;
        while (curr && curr.operator) {
          allInvertable && (allInvertable = curr.operator in INVERSIONS);
          curr = curr.first;
        }
        if (!allInvertable) {
          return new Parens(this).invert();
        }
        curr = this;
        while (curr && curr.operator) {
          curr.invert = !curr.invert;
          curr.operator = INVERSIONS[curr.operator];
          curr = curr.first;
        }
        return this;
      } else if (op = INVERSIONS[this.operator]) {
        this.operator = op;
        if (this.first.unwrap() instanceof Op) {
          this.first.invert();
        }
        return this;
      } else if (this.second) {
        return new Parens(this).invert();
      } else if (this.operator === '!' && (fst = this.first.unwrap()) instanceof Op && ((_ref2 = fst.operator) === '!' || _ref2 === 'in' || _ref2 === 'instanceof')) {
        return fst;
      } else {
        return new Op('!', this);
      }
    };

    Op.prototype.unfoldSoak = function(o) {
      var _ref2;
      return ((_ref2 = this.operator) === '++' || _ref2 === '--' || _ref2 === 'delete') && unfoldSoak(o, this, 'first');
    };

    Op.prototype.generateDo = function(exp) {
      var call, func, param, passedParams, ref, _i, _len, _ref2;
      passedParams = [];
      func = exp instanceof Assign && (ref = exp.value.unwrap()) instanceof Code ? ref : exp;
      _ref2 = func.params || [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        param = _ref2[_i];
        if (param.value) {
          passedParams.push(param.value);
          delete param.value;
        } else {
          passedParams.push(param);
        }
      }
      call = new Call(exp, passedParams);
      call["do"] = true;
      return call;
    };

    Op.prototype.compileNode = function(o) {
      var answer, isChain, lhs, rhs, _ref2, _ref3;
      isChain = this.isChainable() && this.first.isChainable();
      if (!isChain) {
        this.first.front = this.front;
      }
      if (this.operator === 'delete' && o.scope.check(this.first.unwrapAll().value)) {
        this.error('delete operand may not be argument or var');
      }
      if (((_ref2 = this.operator) === '--' || _ref2 === '++') && (_ref3 = this.first.unwrapAll().value, __indexOf.call(STRICT_PROSCRIBED, _ref3) >= 0)) {
        this.error("cannot increment/decrement \"" + (this.first.unwrapAll().value) + "\"");
      }
      if (this.isYield()) {
        return this.compileYield(o);
      }
      if (this.isUnary()) {
        return this.compileUnary(o);
      }
      if (isChain) {
        return this.compileChain(o);
      }
      switch (this.operator) {
        case '?':
          return this.compileExistence(o);
        case '**':
          return this.compilePower(o);
        case '//':
          return this.compileFloorDivision(o);
        case '%%':
          return this.compileModulo(o);
        default:
          lhs = this.first.compileToFragments(o, LEVEL_OP);
          rhs = this.second.compileToFragments(o, LEVEL_OP);
          answer = [].concat(lhs, this.makeCode(" " + this.operator + " "), rhs);
          if (o.level <= LEVEL_OP) {
            return answer;
          } else {
            return this.wrapInBraces(answer);
          }
      }
    };

    Op.prototype.compileChain = function(o) {
      var fragments, fst, shared, _ref2;
      _ref2 = this.first.second.cache(o), this.first.second = _ref2[0], shared = _ref2[1];
      fst = this.first.compileToFragments(o, LEVEL_OP);
      fragments = fst.concat(this.makeCode(" " + (this.invert ? '&&' : '||') + " "), shared.compileToFragments(o), this.makeCode(" " + this.operator + " "), this.second.compileToFragments(o, LEVEL_OP));
      return this.wrapInBraces(fragments);
    };

    Op.prototype.compileExistence = function(o) {
      var fst, ref;
      if (this.first.isComplex()) {
        ref = new Literal(o.scope.freeVariable('ref'));
        fst = new Parens(new Assign(ref, this.first));
      } else {
        fst = this.first;
        ref = fst;
      }
      return new If(new Existence(fst), ref, {
        type: 'if'
      }).addElse(this.second).compileToFragments(o);
    };

    Op.prototype.compileUnary = function(o) {
      var op, parts, plusMinus;
      parts = [];
      op = this.operator;
      parts.push([this.makeCode(op)]);
      if (op === '!' && this.first instanceof Existence) {
        this.first.negated = !this.first.negated;
        return this.first.compileToFragments(o);
      }
      if (o.level >= LEVEL_ACCESS) {
        return (new Parens(this)).compileToFragments(o);
      }
      plusMinus = op === '+' || op === '-';
      if ((op === 'new' || op === 'typeof' || op === 'delete') || plusMinus && this.first instanceof Op && this.first.operator === op) {
        parts.push([this.makeCode(' ')]);
      }
      if ((plusMinus && this.first instanceof Op) || (op === 'new' && this.first.isStatement(o))) {
        this.first = new Parens(this.first);
      }
      parts.push(this.first.compileToFragments(o, LEVEL_OP));
      if (this.flip) {
        parts.reverse();
      }
      return this.joinFragmentArrays(parts, '');
    };

    Op.prototype.compileYield = function(o) {
      var op, parts;
      parts = [];
      op = this.operator;
      if (o.scope.parent == null) {
        this.error('yield statements must occur within a function generator.');
      }
      if (__indexOf.call(Object.keys(this.first), 'expression') >= 0) {
        if (this.first.expression != null) {
          parts.push(this.first.expression.compileToFragments(o, LEVEL_OP));
        }
      } else {
        parts.push([this.makeCode("(" + op + " ")]);
        parts.push(this.first.compileToFragments(o, LEVEL_OP));
        parts.push([this.makeCode(")")]);
      }
      return this.joinFragmentArrays(parts, '');
    };

    Op.prototype.compilePower = function(o) {
      var pow;
      pow = new Value(new Literal('Math'), [new Access(new Literal('pow'))]);
      return new Call(pow, [this.first, this.second]).compileToFragments(o);
    };

    Op.prototype.compileFloorDivision = function(o) {
      var div, floor;
      floor = new Value(new Literal('Math'), [new Access(new Literal('floor'))]);
      div = new Op('/', this.first, this.second);
      return new Call(floor, [div]).compileToFragments(o);
    };

    Op.prototype.compileModulo = function(o) {
      var mod;
      mod = new Value(new Literal(utility('modulo')));
      return new Call(mod, [this.first, this.second]).compileToFragments(o);
    };

    Op.prototype.toString = function(idt) {
      return Op.__super__.toString.call(this, idt, this.constructor.name + ' ' + this.operator);
    };

    Op.prototype.icedWrapContinuation = function() {
      return this.icedCallContinuationFlag;
    };

    return Op;

  })(Base);

  exports.In = In = (function(_super) {
    __extends(In, _super);

    function In(object, array) {
      this.object = object;
      this.array = array;
      In.__super__.constructor.call(this);
    }

    In.prototype.children = ['object', 'array'];

    In.prototype.invert = NEGATE;

    In.prototype.compileNode = function(o) {
      var hasSplat, obj, _i, _len, _ref2;
      if (this.array instanceof Value && this.array.isArray() && this.array.base.objects.length) {
        _ref2 = this.array.base.objects;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          obj = _ref2[_i];
          if (!(obj instanceof Splat)) {
            continue;
          }
          hasSplat = true;
          break;
        }
        if (!hasSplat) {
          return this.compileOrTest(o);
        }
      }
      return this.compileLoopTest(o);
    };

    In.prototype.compileOrTest = function(o) {
      var cmp, cnj, i, item, ref, sub, tests, _i, _len, _ref2, _ref3, _ref4;
      _ref2 = this.object.cache(o, LEVEL_OP), sub = _ref2[0], ref = _ref2[1];
      _ref3 = this.negated ? [' !== ', ' && '] : [' === ', ' || '], cmp = _ref3[0], cnj = _ref3[1];
      tests = [];
      _ref4 = this.array.base.objects;
      for (i = _i = 0, _len = _ref4.length; _i < _len; i = ++_i) {
        item = _ref4[i];
        if (i) {
          tests.push(this.makeCode(cnj));
        }
        tests = tests.concat((i ? ref : sub), this.makeCode(cmp), item.compileToFragments(o, LEVEL_ACCESS));
      }
      if (o.level < LEVEL_OP) {
        return tests;
      } else {
        return this.wrapInBraces(tests);
      }
    };

    In.prototype.compileLoopTest = function(o) {
      var fragments, ref, sub, _ref2;
      _ref2 = this.object.cache(o, LEVEL_LIST), sub = _ref2[0], ref = _ref2[1];
      fragments = [].concat(this.makeCode(utility('indexOf') + ".call("), this.array.compileToFragments(o, LEVEL_LIST), this.makeCode(", "), ref, this.makeCode(") " + (this.negated ? '< 0' : '>= 0')));
      if (fragmentsToText(sub) === fragmentsToText(ref)) {
        return fragments;
      }
      fragments = sub.concat(this.makeCode(', '), fragments);
      if (o.level < LEVEL_LIST) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    In.prototype.toString = function(idt) {
      return In.__super__.toString.call(this, idt, this.constructor.name + (this.negated ? '!' : ''));
    };

    return In;

  })(Base);

  exports.Slot = Slot = (function(_super) {
    __extends(Slot, _super);

    function Slot(index, value, suffix, splat) {
      Slot.__super__.constructor.call(this);
      this.index = index;
      this.value = value;
      this.suffix = suffix;
      this.splat = splat;
      this.access = null;
    }

    Slot.prototype.addAccess = function(a) {
      this.access = a;
      return this;
    };

    Slot.prototype.children = ['value', 'suffix'];

    return Slot;

  })(Base);

  exports.Defer = Defer = (function(_super) {
    __extends(Defer, _super);

    function Defer(args, lineno) {
      var a, i;
      this.lineno = lineno;
      Defer.__super__.constructor.call(this);
      this.slots = flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = args.length; _i < _len; i = ++_i) {
          a = args[i];
          _results.push(a.icedToSlot(i));
        }
        return _results;
      })());
      this.params = [];
      this.vars = [];
      this.custom = false;
    }

    Defer.prototype.children = ['slots'];

    Defer.prototype.setCustom = function() {
      this.custom = true;
      return this;
    };

    Defer.prototype.newParam = function() {
      var l;
      l = "" + iced["const"].slot + "_" + (this.params.length + 1);
      this.params.push(new Param(new Literal(l)));
      return new Value(new Literal(l));
    };

    Defer.prototype.makeAssignFn = function(o) {
      var a, args, assign, assignments, block, call, func, i, i_lit, inner_fn, lit, outer_block, outer_fn, prop, s, slot, _i, _len, _ref2;
      if (this.slots.length === 0) {
        return null;
      }
      assignments = [];
      args = [];
      i = 0;
      _ref2 = this.slots;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        s = _ref2[_i];
        i = s.index;
        a = new Value(new Literal("arguments"));
        i_lit = new Value(new Literal(i));
        if (s.splat) {
          func = new Value(new Literal(utility('slice')));
          func.add(new Access(new Value(new Literal('call'))));
          call = new Call(func, [a, i_lit]);
          slot = s.value;
          this.vars.push(slot);
          assign = new Assign(slot, call);
        } else {
          a.add(new Index(i_lit));
          if (s.access) {
            a.add(s.access);
          }
          if (!s.suffix) {
            lit = s.value.compile(o, LEVEL_TOP);
            if (lit === "_") {
              slot = new Value(new Literal(iced["const"].deferrals));
              slot.add(new Access(new Value(new Literal(iced["const"].retslot))));
            } else {
              slot = s.value;
              this.vars.push(slot);
            }
          } else {
            args.push(s.value);
            slot = this.newParam();
            if (s.suffix instanceof Index) {
              prop = new Index(this.newParam());
              args.push(s.suffix.index);
            } else {
              prop = s.suffix;
            }
            slot.add(prop);
          }
          assign = new Assign(slot, a);
        }
        assignments.push(assign);
      }
      block = new Block(assignments);
      inner_fn = new Code([], block, 'icedgen');
      outer_block = new Block([new Return(inner_fn)]);
      outer_fn = new Code(this.params, outer_block, 'icedgen');
      return call = new Call(outer_fn, args);
    };

    Defer.prototype.transform = function(o) {
      var assign_fn, assignments, context_assign, context_lhs, context_rhs, fn, ln_assign, ln_lhs, ln_rhs, meth;
      meth = new Value(new Literal(iced["const"].defer_method));
      if (this.custom) {
        fn = meth;
      } else {
        fn = new Value(new Literal(iced["const"].deferrals));
        fn.add(new Access(meth));
      }
      assignments = [];
      if ((assign_fn = this.makeAssignFn(o))) {
        assignments.push(new Assign(new Value(new Literal(iced["const"].assign_fn)), assign_fn, "object"));
      }
      ln_lhs = new Value(new Literal(iced["const"].lineno));
      ln_rhs = new Value(new Literal(this.lineno));
      ln_assign = new Assign(ln_lhs, ln_rhs, "object");
      assignments.push(ln_assign);
      if (this.custom) {
        context_lhs = new Value(new Literal(iced["const"].context));
        context_rhs = new Value(new Literal(iced["const"].deferrals));
        context_assign = new Assign(context_lhs, context_rhs, "object");
        assignments.push(context_assign);
      }
      o = new Obj(assignments);
      return new Call(fn, [new Value(o)]);
    };

    Defer.prototype.compileNode = function(o) {
      var call, name, scope, v, _i, _len, _ref2;
      call = this.transform(o);
      _ref2 = this.vars;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        v = _ref2[_i];
        name = v.compile(o, LEVEL_LIST);
        scope = o.scope;
        scope.find(name, 'var');
      }
      return call.compileNode(o);
    };

    Defer.prototype.icedWalkAst = function(p, o) {
      this.icedHasAutocbFlag = o.foundAutocb;
      o.foundDefer = true;
      this.parentFunc = o.currFunc;
      return Defer.__super__.icedWalkAst.call(this, p, o);
    };

    return Defer;

  })(Base);

  quote_path_for_emission = function(n) {
    return '"' + n.replace(/\\/g, '\\\\') + '"';
  };

  quote_funcname_for_debug = function(n) {
    return '"' + n.replace(/["']/g, '') + '"';
  };

  require_top_dir = function() {
    return quote_path_for_emission(pathmod.join(__dirname, "..", ".."));
  };

  exports.Await = Await = (function(_super) {
    __extends(Await, _super);

    function Await(body) {
      this.body = body;
      Await.__super__.constructor.call(this);
    }

    Await.prototype.transform = function(o) {
      var assign, assignments, body, call, cb_assignment, cb_lhs, cb_rhs, cls, fn_assignment, fn_lhs, fn_rhs, func_assignment, func_lhs, func_rhs, lhs, meth, n, name, rhs, trace, _ref2, _ref3;
      body = this.body;
      name = iced["const"].deferrals;
      o.scope.add(name, 'var');
      lhs = new Value(new Literal(name));
      cls = new Value(new Literal(iced["const"].ns));
      cls.add(new Access(new Value(new Literal(iced["const"].Deferrals))));
      assignments = [];
      if (n = (_ref2 = this.parentFunc) != null ? _ref2.icedPassedDeferral : void 0) {
        cb_lhs = new Value(new Literal(iced["const"].parent));
        cb_rhs = new Value(new Literal(n));
        cb_assignment = new Assign(cb_lhs, cb_rhs, "object");
        assignments.push(cb_assignment);
      }
      if (o.filename != null) {
        fn_lhs = new Value(new Literal(iced["const"].filename));
        fn_rhs = new Value(new Literal(quote_path_for_emission(o.filename)));
        fn_assignment = new Assign(fn_lhs, fn_rhs, "object");
        assignments.push(fn_assignment);
      }
      if (n = (_ref3 = this.parentFunc) != null ? _ref3.icedTraceName() : void 0) {
        func_lhs = new Value(new Literal(iced["const"].funcname));
        func_rhs = new Value(new Literal(quote_funcname_for_debug(n)));
        func_assignment = new Assign(func_lhs, func_rhs, "object");
        assignments.push(func_assignment);
      }
      trace = new Obj(assignments, true);
      call = new Call(cls, [new Value(new Literal(iced["const"].k)), trace]);
      rhs = new Op("new", call);
      assign = new Assign(lhs, rhs);
      body.unshift(assign);
      meth = lhs.copy().add(new Access(new Value(new Literal(iced["const"].fulfill))));
      call = new Call(meth, []);
      body.push(call);
      return this.body = body;
    };

    Await.prototype.children = ['body'];

    Await.prototype.isStatement = function() {
      return YES;
    };

    Await.prototype.makeReturn = THIS;

    Await.prototype.compileNode = function(o) {
      this.transform(o);
      return this.body.compileNode(o);
    };

    Await.prototype.icedWalkAst = function(p, o) {
      this.icedHasAutocbFlag = o.foundAutocb;
      this.parentFunc = o.currFunc;
      p = p || this;
      this.icedParentAwait = p;
      Await.__super__.icedWalkAst.call(this, p, o);
      return this.icedNodeFlag = o.foundAwaitFunc = o.foundAwait = true;
    };

    return Await;

  })(Base);

  IcedRuntime = (function(_super) {
    __extends(IcedRuntime, _super);

    function IcedRuntime(foundDefer, foundAwait) {
      this.foundDefer = foundDefer;
      this.foundAwait = foundAwait;
      IcedRuntime.__super__.constructor.call(this);
    }

    IcedRuntime.prototype.compileNode = function(o, level) {
      var access, accessname, assign, call, callv, file, inc, interp, k, klass, lhs_vec, ns, qmodname, req, rhs, v, val, window_mode, window_val, _i, _j, _len, _len1, _ref2;
      this.expressions = [];
      v = o.runtime ? o.runtime : o.bare ? "none" : this.foundDefer ? "node" : "none";
      if (o.runtime && !this.foundDefer && !o.runforce) {
        v = "none";
      }
      window_mode = false;
      window_val = null;
      inc = null;
      inc = (function() {
        switch (v) {
          case "inline":
          case "window":
            if (v === "window") {
              window_mode = true;
            }
            if (window_mode) {
              window_val = new Value(new Literal(v));
            }
            return InlineRuntime.generate(window_val ? window_val.copy() : null);
          case "node":
          case "browserify":
          case "interp":
            interp = v === "interp";
            qmodname = interp ? require_top_dir() : "'iced-runtime'";
            accessname = iced["const"].ns;
            file = new Literal(qmodname);
            access = new Access(new Literal(accessname));
            req = new Value(new Literal("require"));
            call = new Call(req, [file]);
            callv = new Value(call);
            if (interp) {
              callv.add(access);
            }
            ns = new Value(new Literal(iced["const"].ns));
            return new Assign(ns, callv);
          case "none":
            return null;
          default:
            throw SyntaxError("unexpected flag IcedRuntime " + v);
        }
      })();
      if (inc) {
        this.push(inc);
      }
      if (this.foundAwait) {
        rhs = new Code([], new Block([]));
        lhs_vec = [];
        _ref2 = [iced["const"].k_noop, iced["const"].k];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          k = _ref2[_i];
          val = new Value(new Literal(k));
          if (window_val) {
            klass = window_val.copy();
            klass.add(new Access(val));
            val = klass;
          }
          lhs_vec.push(val);
        }
        assign = rhs;
        for (_j = 0, _len1 = lhs_vec.length; _j < _len1; _j++) {
          v = lhs_vec[_j];
          assign = new Assign(v, assign);
        }
        this.push(assign);
      }
      if (this.isEmpty()) {
        return [];
      } else {
        return IcedRuntime.__super__.compileNode.call(this, o);
      }
    };

    IcedRuntime.prototype.icedWalkAst = function(p, o) {
      this.icedHasAutocbFlag = o.foundAutocb;
      return IcedRuntime.__super__.icedWalkAst.call(this, p, o);
    };

    return IcedRuntime;

  })(Block);

  exports.Try = Try = (function(_super) {
    __extends(Try, _super);

    function Try(attempt, errorVariable, recovery, ensure) {
      this.attempt = attempt;
      this.errorVariable = errorVariable;
      this.recovery = recovery;
      this.ensure = ensure;
    }

    Try.prototype.children = ['attempt', 'recovery', 'ensure'];

    Try.prototype.isStatement = YES;

    Try.prototype.jumps = function(o) {
      var _ref2;
      return this.attempt.jumps(o) || ((_ref2 = this.recovery) != null ? _ref2.jumps(o) : void 0);
    };

    Try.prototype.makeReturn = function(res) {
      if (this.attempt) {
        this.attempt = this.attempt.makeReturn(res);
      }
      if (this.recovery) {
        this.recovery = this.recovery.makeReturn(res);
      }
      return this;
    };

    Try.prototype.compileNode = function(o) {
      var catchPart, ensurePart, placeholder, tryPart;
      o.indent += TAB;
      tryPart = this.attempt.compileToFragments(o, LEVEL_TOP);
      catchPart = this.recovery ? (placeholder = new Literal('_error'), this.errorVariable ? this.recovery.unshift(new Assign(this.errorVariable, placeholder)) : void 0, [].concat(this.makeCode(" catch ("), placeholder.compileToFragments(o), this.makeCode(") {\n"), this.recovery.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}"))) : !(this.ensure || this.recovery) ? [this.makeCode(' catch (_error) {}')] : [];
      ensurePart = this.ensure ? [].concat(this.makeCode(" finally {\n"), this.ensure.compileToFragments(o, LEVEL_TOP), this.makeCode("\n" + this.tab + "}")) : [];
      return [].concat(this.makeCode("" + this.tab + "try {\n"), tryPart, this.makeCode("\n" + this.tab + "}"), catchPart, ensurePart);
    };

    return Try;

  })(Base);

  exports.Throw = Throw = (function(_super) {
    __extends(Throw, _super);

    function Throw(expression) {
      this.expression = expression;
      Throw.__super__.constructor.call(this);
    }

    Throw.prototype.children = ['expression'];

    Throw.prototype.isStatement = YES;

    Throw.prototype.jumps = NO;

    Throw.prototype.makeReturn = THIS;

    Throw.prototype.compileNode = function(o) {
      return [].concat(this.makeCode(this.tab + "throw "), this.expression.compileToFragments(o), this.makeCode(";"));
    };

    return Throw;

  })(Base);

  exports.Existence = Existence = (function(_super) {
    __extends(Existence, _super);

    function Existence(expression) {
      this.expression = expression;
      Existence.__super__.constructor.call(this);
    }

    Existence.prototype.children = ['expression'];

    Existence.prototype.invert = NEGATE;

    Existence.prototype.compileNode = function(o) {
      var cmp, cnj, code, _ref2;
      this.expression.front = this.front;
      code = this.expression.compile(o, LEVEL_OP);
      if (IDENTIFIER.test(code) && !o.scope.check(code)) {
        _ref2 = this.negated ? ['===', '||'] : ['!==', '&&'], cmp = _ref2[0], cnj = _ref2[1];
        code = "typeof " + code + " " + cmp + " \"undefined\" " + cnj + " " + code + " " + cmp + " null";
      } else {
        code = "" + code + " " + (this.negated ? '==' : '!=') + " null";
      }
      return [this.makeCode(o.level <= LEVEL_COND ? code : "(" + code + ")")];
    };

    return Existence;

  })(Base);

  exports.Parens = Parens = (function(_super) {
    __extends(Parens, _super);

    function Parens(body) {
      this.body = body;
      Parens.__super__.constructor.call(this);
    }

    Parens.prototype.children = ['body'];

    Parens.prototype.unwrap = function() {
      return this.body;
    };

    Parens.prototype.isComplex = function() {
      return this.body.isComplex();
    };

    Parens.prototype.compileNode = function(o) {
      var bare, expr, fragments;
      expr = this.body.unwrap();
      if (expr instanceof Value && expr.isAtomic()) {
        expr.front = this.front;
        return expr.compileToFragments(o);
      }
      fragments = expr.compileToFragments(o, LEVEL_PAREN);
      bare = o.level < LEVEL_OP && (expr instanceof Op || expr instanceof Call || (expr instanceof For && expr.returns));
      if (bare) {
        return fragments;
      } else {
        return this.wrapInBraces(fragments);
      }
    };

    return Parens;

  })(Base);

  exports.For = For = (function(_super) {
    __extends(For, _super);

    function For(body, source) {
      var _ref2;
      For.__super__.constructor.call(this);
      this.source = source.source, this.guard = source.guard, this.step = source.step, this.name = source.name, this.index = source.index;
      this.body = Block.wrap([body]);
      this.own = !!source.own;
      this.object = !!source.object;
      if (this.object) {
        _ref2 = [this.index, this.name], this.name = _ref2[0], this.index = _ref2[1];
      }
      if (this.index instanceof Value) {
        this.index.error('index cannot be a pattern matching expression');
      }
      this.range = this.source instanceof Value && this.source.base instanceof Range && !this.source.properties.length;
      this.pattern = this.name instanceof Value;
      if (this.range && this.index) {
        this.index.error('indexes do not apply to range loops');
      }
      if (this.range && this.pattern) {
        this.name.error('cannot pattern match over range loops');
      }
      if (this.own && !this.object) {
        this.name.error('cannot use own with for-in');
      }
      this.returns = false;
    }

    For.prototype.children = ['body', 'source', 'guard', 'step'];

    For.prototype.compileNode = function(o) {
      var body, bodyFragments, compare, compareDown, declare, declareDown, defPart, defPartFragments, down, forPartFragments, guardPart, idt1, increment, index, ivar, kvar, kvarAssign, lastJumps, lvar, name, namePart, ref, resultPart, returnResult, rvar, scope, source, step, stepNum, stepVar, svar, varPart, _ref2, _ref3;
      body = Block.wrap([this.body]);
      lastJumps = (_ref2 = last(body.expressions)) != null ? _ref2.jumps() : void 0;
      if (lastJumps && lastJumps instanceof Return) {
        this.returns = false;
      }
      source = this.range ? this.source.base : this.source;
      scope = o.scope;
      if (!this.pattern) {
        name = this.name && (this.name.compile(o, LEVEL_LIST));
      }
      index = this.index && (this.index.compile(o, LEVEL_LIST));
      if (name && !this.pattern) {
        scope.find(name);
      }
      if (index) {
        scope.find(index);
      }
      if (this.returns) {
        rvar = scope.freeVariable('results');
      }
      ivar = (this.object && index) || scope.freeVariable('i');
      kvar = (this.range && name) || index || ivar;
      kvarAssign = kvar !== ivar ? "" + kvar + " = " : "";
      if (this.step && !this.range) {
        _ref3 = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST)), step = _ref3[0], stepVar = _ref3[1];
        stepNum = stepVar.match(NUMBER);
      }
      if (this.pattern) {
        name = ivar;
      }
      varPart = '';
      guardPart = '';
      defPart = '';
      idt1 = this.tab + TAB;
      source.icedStatementAssertion();
      if (this.icedNodeFlag) {
        return this.icedCompileIced(o, {
          stepVar: stepVar,
          body: body,
          kvar: kvar,
          guard: this.guard
        });
      }
      if (this.range) {
        forPartFragments = source.compileToFragments(merge(o, {
          index: ivar,
          name: name,
          step: this.step
        }));
      } else {
        svar = this.source.compile(o, LEVEL_LIST);
        if ((name || this.own) && !IDENTIFIER.test(svar)) {
          defPart += "" + this.tab + (ref = scope.freeVariable('ref')) + " = " + svar + ";\n";
          svar = ref;
        }
        if (name && !this.pattern) {
          namePart = "" + name + " = " + svar + "[" + kvar + "]";
        }
        if (!this.object) {
          if (step !== stepVar) {
            defPart += "" + this.tab + step + ";\n";
          }
          if (!(this.step && stepNum && (down = parseNum(stepNum[0]) < 0))) {
            lvar = scope.freeVariable('len');
          }
          declare = "" + kvarAssign + ivar + " = 0, " + lvar + " = " + svar + ".length";
          declareDown = "" + kvarAssign + ivar + " = " + svar + ".length - 1";
          compare = "" + ivar + " < " + lvar;
          compareDown = "" + ivar + " >= 0";
          if (this.step) {
            if (stepNum) {
              if (down) {
                compare = compareDown;
                declare = declareDown;
              }
            } else {
              compare = "" + stepVar + " > 0 ? " + compare + " : " + compareDown;
              declare = "(" + stepVar + " > 0 ? (" + declare + ") : " + declareDown + ")";
            }
            increment = "" + ivar + " += " + stepVar;
          } else {
            increment = "" + (kvar !== ivar ? "++" + ivar : "" + ivar + "++");
          }
          forPartFragments = [this.makeCode("" + declare + "; " + compare + "; " + kvarAssign + increment)];
        }
      }
      if (this.returns) {
        resultPart = "" + this.tab + rvar + " = [];\n";
        returnResult = this.icedHasAutocbFlag ? "\n" + this.tab + iced["const"].autocb + "(" + rvar + "); return;" : "\n" + this.tab + "return " + rvar + ";";
        body.makeReturn(rvar);
      }
      if (this.guard) {
        if (body.expressions.length > 1) {
          body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal("continue")));
        } else {
          if (this.guard) {
            body = Block.wrap([new If(this.guard, body)]);
          }
        }
      }
      if (this.pattern) {
        body.expressions.unshift(new Assign(this.name, new Literal("" + svar + "[" + kvar + "]")));
      }
      defPartFragments = [].concat(this.makeCode(defPart), this.pluckDirectCall(o, body));
      if (namePart) {
        varPart = "\n" + idt1 + namePart + ";";
      }
      if (this.object) {
        forPartFragments = [this.makeCode("" + kvar + " in " + svar)];
        if (this.own) {
          guardPart = "\n" + idt1 + "if (!" + (utility('hasProp')) + ".call(" + svar + ", " + kvar + ")) continue;";
        }
      }
      bodyFragments = body.compileToFragments(merge(o, {
        indent: idt1
      }), LEVEL_TOP);
      if (bodyFragments && (bodyFragments.length > 0)) {
        bodyFragments = [].concat(this.makeCode("\n"), bodyFragments, this.makeCode("\n"));
      }
      return [].concat(defPartFragments, this.makeCode("" + (resultPart || '') + this.tab + "for ("), forPartFragments, this.makeCode(") {" + guardPart + varPart), bodyFragments, this.makeCode("" + this.tab + "}" + (returnResult || '')));
    };

    For.prototype.pluckDirectCall = function(o, body) {
      var base, defs, expr, fn, idx, ref, val, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      defs = [];
      _ref2 = body.expressions;
      for (idx = _i = 0, _len = _ref2.length; _i < _len; idx = ++_i) {
        expr = _ref2[idx];
        expr = expr.unwrapAll();
        if (!(expr instanceof Call)) {
          continue;
        }
        val = (_ref3 = expr.variable) != null ? _ref3.unwrapAll() : void 0;
        if (!((val instanceof Code) || (val instanceof Value && ((_ref4 = val.base) != null ? _ref4.unwrapAll() : void 0) instanceof Code && val.properties.length === 1 && ((_ref5 = (_ref6 = val.properties[0].name) != null ? _ref6.value : void 0) === 'call' || _ref5 === 'apply')))) {
          continue;
        }
        fn = ((_ref7 = val.base) != null ? _ref7.unwrapAll() : void 0) || val;
        ref = new Literal(o.scope.freeVariable('fn'));
        base = new Value(ref);
        if (val.base) {
          _ref8 = [base, val], val.base = _ref8[0], base = _ref8[1];
        }
        body.expressions[idx] = new Call(base, expr.args);
        defs = defs.concat(this.makeCode(this.tab), new Assign(ref, fn).compileToFragments(o, LEVEL_TOP), this.makeCode(';\n'));
      }
      return defs;
    };

    For.prototype.icedCompileIced = function(o, d) {
      var a1, a2, a3, a4, a5, a_positive, a_stepVal, b, begin, body, condition, down, empty_arr, end, excl, guard, iname, init, init_step, is_positive, is_step_positive, ival, key, key_lit, key_val, keys, keys_access, keys_len, keys_val, kval, len, len_rhs, len_val, loop_body, loop_keys, loop_source, neg, pos, positive, pre_body, ref, ref_val, ref_val_copy, scope, source_access, start_rhs, step, stepNum, stepVal, stepVar, step_var, step_var_val, _, _ref2;
      body = d.body;
      condition = null;
      init = [];
      step = null;
      scope = o.scope;
      pre_body = new Block([]);
      if (this.object) {
        ref = scope.freeVariable('ref');
        ref_val = new Value(new Literal(ref));
        a1 = new Assign(ref_val, this.source);
        keys = scope.freeVariable('keys');
        keys_val = new Value(new Literal(keys));
        key = scope.freeVariable('k');
        key_lit = new Literal(key);
        key_val = new Value(key_lit);
        empty_arr = new Value(new Arr);
        loop_body = new Block([key_val]);
        loop_source = {
          object: true,
          name: key_lit,
          source: ref_val
        };
        loop_keys = new For(loop_body, loop_source);
        a2 = new Assign(keys_val, loop_keys);
        iname = scope.freeVariable('i');
        ival = new Value(new Literal(iname));
        a3 = new Assign(ival, new Value(new Literal(0)));
        init = [a1, a2, a3];
        keys_len = keys_val.copy();
        keys_len.add(new Access(new Value(new Literal("length"))));
        condition = new Op('<', ival, keys_len);
        step = new Op('++', ival);
        if (this.name) {
          source_access = ref_val.copy();
          source_access.add(new Index(this.index));
          a5 = new Assign(this.name, source_access);
          pre_body.unshift(a5);
        }
        keys_access = keys_val.copy();
        keys_access.add(new Index(ival));
        a4 = new Assign(this.index, keys_access);
        pre_body.unshift(a4);
      } else if (this.range) {
        if (!this.name) {
          this.name = new Literal(d.kvar);
        }
        begin = new Value(new Literal(o.scope.freeVariable("begin")));
        end = new Value(new Literal(o.scope.freeVariable("end")));
        positive = new Value(new Literal(o.scope.freeVariable("positive")));
        stepVal = new Value(new Literal(o.scope.freeVariable("step")));
        if (this.step) {
          a_stepVal = new Assign(stepVal, this.step);
          a_positive = new Assign(positive, new Op(">", stepVal, new Literal(0)), null, {
            icedlocal: true
          });
        } else {
          is_positive = new Op(">", end, begin);
          a_stepVal = new If(is_positive, new Assign(stepVal, new Literal(1)));
          a_stepVal.addElse(new Assign(stepVal, new Literal(-1)));
          a_positive = new Assign(positive, is_positive, null, {
            icedlocal: true
          });
        }
        step = new Op('+=', this.name, stepVal);
        excl = this.source.base.exclusive ? "=" : '';
        pos = new Op("&&", new Op("===", positive, new Literal(true)), new Op(">" + excl, this.name, this.source.base.to));
        neg = new Op("&&", new Op("===", positive, new Literal(false)), new Op("<" + excl, this.name, this.source.base.to));
        condition = new Op("||", new Parens(pos), new Parens(neg));
        condition = condition.invert();
        init = [
          new Assign(this.name, this.source.base.from), new Assign(begin, this.source.base.from, null, {
            icedlocal: true
          }), new Assign(end, this.source.base.to, null, {
            icedlocal: true
          }), a_stepVal, a_positive
        ];
      } else if (!this.range && this.name) {
        kval = new Value(new Literal(d.kvar));
        len = scope.freeVariable('len');
        ref = scope.freeVariable('ref');
        ref_val = new Value(new Literal(ref));
        len_val = new Value(new Literal(len));
        a1 = new Assign(ref_val, this.source);
        len_rhs = ref_val.copy().add(new Access(new Value(new Literal("length"))));
        a2 = new Assign(len_val, len_rhs);
        init = [a1, a2];
        if (!this.step) {
          a3 = new Assign(kval, new Literal(0));
          step = new Op('++', kval);
          condition = new Op('<', kval, len_val);
          init.push(a3);
        } else {
          _ref2 = this.cacheToCodeFragments(this.step.cache(o, LEVEL_LIST)), _ = _ref2[0], stepVar = _ref2[1];
          stepNum = stepVar.match(NUMBER);
          if (stepNum) {
            step = new Assign(kval, new Op('+', kval, this.step));
            down = parseNum(stepNum[0]) < 0;
            if (down) {
              a3 = new Assign(kval, new Op('-', len_val, new Literal(1)));
              condition = new Op('>=', kval, new Literal(0));
            } else {
              a3 = new Assign(kval, new Literal(0));
              condition = new Op('<', kval, len_val);
            }
            init.push(a3);
          } else {
            step_var = scope.freeVariable('step');
            step_var_val = new Value(new Literal(step_var));
            init_step = new Assign(step_var_val, new Value(this.step));
            is_step_positive = new Op('>', step_var_val, new Literal(0));
            start_rhs = new If(is_step_positive, new Value(new Literal(0)));
            start_rhs.addElse(new Op('-', len_val, new Literal(1)));
            step = new Assign(kval, new Op('+', kval, step_var_val));
            a3 = new Assign(kval, start_rhs);
            condition = new Op('&&', new Op('>=', kval, new Literal(0)), new Op('<', kval, len_val));
            init.push(init_step, a3);
          }
        }
        ref_val_copy = ref_val.copy();
        ref_val_copy.add(new Index(kval));
        a4 = new Assign(this.name, ref_val_copy);
        pre_body.unshift(a4);
      }
      guard = d.guard;
      b = this.icedWrap({
        condition: condition,
        body: body,
        init: init,
        step: step,
        guard: guard,
        pre_body: pre_body
      });
      return b.compileNode(o);
    };

    return For;

  })(While);

  exports.Switch = Switch = (function(_super) {
    __extends(Switch, _super);

    function Switch(subject, cases, otherwise) {
      this.subject = subject;
      this.cases = cases;
      this.otherwise = otherwise;
      Switch.__super__.constructor.call(this);
    }

    Switch.prototype.children = ['subject', 'cases', 'otherwise'];

    Switch.prototype.isStatement = YES;

    Switch.prototype.jumps = function(o) {
      var block, conds, jumpNode, _i, _len, _ref2, _ref3, _ref4;
      if (o == null) {
        o = {
          block: true
        };
      }
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], conds = _ref3[0], block = _ref3[1];
        if (jumpNode = block.jumps(o)) {
          return jumpNode;
        }
      }
      return (_ref4 = this.otherwise) != null ? _ref4.jumps(o) : void 0;
    };

    Switch.prototype.makeReturn = function(res) {
      var pair, _i, _len, _ref2, _ref3;
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        pair = _ref2[_i];
        pair[1].makeReturn(res);
      }
      if (res) {
        this.otherwise || (this.otherwise = new Block([new Literal('void 0')]));
      }
      if ((_ref3 = this.otherwise) != null) {
        _ref3.makeReturn(res);
      }
      return this;
    };

    Switch.prototype.compileNode = function(o) {
      var block, body, cond, conditions, expr, fragments, i, idt1, idt2, _i, _j, _len, _len1, _ref2, _ref3, _ref4;
      if (this.subject) {
        this.subject.icedStatementAssertion();
      }
      idt1 = o.indent + TAB;
      idt2 = o.indent = idt1 + TAB;
      fragments = [].concat(this.makeCode(this.tab + "switch ("), (this.subject ? this.subject.compileToFragments(o, LEVEL_PAREN) : this.makeCode("false")), this.makeCode(") {\n"));
      _ref2 = this.cases;
      for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {
        _ref3 = _ref2[i], conditions = _ref3[0], block = _ref3[1];
        _ref4 = flatten([conditions]);
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          cond = _ref4[_j];
          if (!this.subject) {
            cond = cond.invert();
          }
          fragments = fragments.concat(this.makeCode(idt1 + "case "), cond.compileToFragments(o, LEVEL_PAREN), this.makeCode(":\n"));
        }
        if ((body = block.compileToFragments(o, LEVEL_TOP)).length > 0) {
          fragments = fragments.concat(body, this.makeCode('\n'));
        }
        if (i === this.cases.length - 1 && !this.otherwise) {
          break;
        }
        expr = this.lastNonComment(block.expressions);
        if (expr instanceof Return || (expr instanceof Literal && expr.jumps() && expr.value !== 'debugger')) {
          continue;
        }
        fragments.push(cond.makeCode(idt2 + 'break;\n'));
      }
      if (this.otherwise && this.otherwise.expressions.length) {
        fragments.push.apply(fragments, [this.makeCode(idt1 + "default:\n")].concat(__slice.call(this.otherwise.compileToFragments(o, LEVEL_TOP)), [this.makeCode("\n")]));
      }
      fragments.push(this.makeCode(this.tab + '}'));
      return fragments;
    };

    Switch.prototype.icedCallContinuation = function() {
      var block, condition, _i, _len, _ref2, _ref3;
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], condition = _ref3[0], block = _ref3[1];
        block.icedThreadReturn();
      }
      if (this.otherwise != null) {
        return this.otherwise.icedThreadReturn();
      } else {
        return this.otherwise = new Block([new IcedTailCall]);
      }
    };

    return Switch;

  })(Base);

  exports.If = If = (function(_super) {
    __extends(If, _super);

    function If(condition, body, options) {
      this.body = body;
      if (options == null) {
        options = {};
      }
      If.__super__.constructor.call(this);
      this.condition = options.type === 'unless' ? condition.invert() : condition;
      this.elseBody = null;
      this.isChain = false;
      this.soak = options.soak;
    }

    If.prototype.children = ['condition', 'body', 'elseBody'];

    If.prototype.bodyNode = function() {
      var _ref2;
      return (_ref2 = this.body) != null ? _ref2.unwrap() : void 0;
    };

    If.prototype.elseBodyNode = function() {
      var _ref2;
      return (_ref2 = this.elseBody) != null ? _ref2.unwrap() : void 0;
    };

    If.prototype.addElse = function(elseBody) {
      if (this.isChain) {
        this.elseBodyNode().addElse(elseBody);
      } else {
        this.isChain = elseBody instanceof If;
        this.elseBody = this.ensureBlock(elseBody);
        this.elseBody.updateLocationDataIfMissing(elseBody.locationData);
      }
      return this;
    };

    If.prototype.isStatement = function(o) {
      var _ref2;
      return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((_ref2 = this.elseBodyNode()) != null ? _ref2.isStatement(o) : void 0);
    };

    If.prototype.jumps = function(o) {
      var _ref2;
      return this.body.jumps(o) || ((_ref2 = this.elseBody) != null ? _ref2.jumps(o) : void 0);
    };

    If.prototype.compileNode = function(o) {
      this.condition.icedStatementAssertion();
      if (this.isStatement(o || this.icedIsCpsPivot())) {
        return this.compileStatement(o);
      } else {
        return this.compileExpression(o);
      }
    };

    If.prototype.makeReturn = function(res) {
      if (res) {
        this.elseBody || (this.elseBody = new Block([new Literal('void 0')]));
      }
      this.body && (this.body = new Block([this.body.makeReturn(res)]));
      this.elseBody && (this.elseBody = new Block([this.elseBody.makeReturn(res)]));
      return this;
    };

    If.prototype.ensureBlock = function(node) {
      if (node instanceof Block) {
        return node;
      } else {
        return new Block([node]);
      }
    };

    If.prototype.compileStatement = function(o) {
      var answer, body, child, cond, exeq, ifPart, indent;
      child = del(o, 'chainChild');
      exeq = del(o, 'isExistentialEquals');
      if (exeq) {
        return new If(this.condition.invert(), this.elseBodyNode(), {
          type: 'if'
        }).compileToFragments(o);
      }
      indent = o.indent + TAB;
      cond = this.condition.compileToFragments(o, LEVEL_PAREN);
      body = this.ensureBlock(this.body).compileToFragments(merge(o, {
        indent: indent
      }));
      ifPart = [].concat(this.makeCode("if ("), cond, this.makeCode(") {\n"), body, this.makeCode("\n" + this.tab + "}"));
      if (!child) {
        ifPart.unshift(this.makeCode(this.tab));
      }
      if (!this.elseBody) {
        return ifPart;
      }
      answer = ifPart.concat(this.makeCode(' else '));
      if (this.isChain) {
        o.chainChild = true;
        answer = answer.concat(this.elseBody.unwrap().compileToFragments(o, LEVEL_TOP));
      } else {
        answer = answer.concat(this.makeCode("{\n"), this.elseBody.compileToFragments(merge(o, {
          indent: indent
        }), LEVEL_TOP), this.makeCode("\n" + this.tab + "}"));
      }
      return answer;
    };

    If.prototype.compileExpression = function(o) {
      var alt, body, cond, fragments;
      cond = this.condition.compileToFragments(o, LEVEL_COND);
      body = this.bodyNode().compileToFragments(o, LEVEL_LIST);
      alt = this.elseBodyNode() ? this.elseBodyNode().compileToFragments(o, LEVEL_LIST) : [this.makeCode('void 0')];
      fragments = cond.concat(this.makeCode(" ? "), body, this.makeCode(" : "), alt);
      if (o.level >= LEVEL_COND) {
        return this.wrapInBraces(fragments);
      } else {
        return fragments;
      }
    };

    If.prototype.unfoldSoak = function() {
      return this.soak && this;
    };

    If.prototype.icedCallContinuation = function() {
      if (this.elseBody) {
        this.elseBody.icedThreadReturn();
        this.isChain = false;
      } else {
        this.addElse(new IcedTailCall);
      }
      return this.body.icedThreadReturn();
    };

    return If;

  })(Base);

  Closure = {
    wrap: function(expressions, statement, noReturn) {
      var args, argumentsNode, call, func, meth;
      if (expressions.jumps()) {
        return expressions;
      }
      func = new Code([], Block.wrap([expressions]));
      args = [];
      argumentsNode = expressions.contains(this.isLiteralArguments);
      if (argumentsNode && expressions.classBody) {
        argumentsNode.error("Class bodies shouldn't reference arguments");
      }
      if (argumentsNode || expressions.contains(this.isLiteralThis)) {
        meth = new Literal(argumentsNode ? 'apply' : 'call');
        args = [new Literal('this')];
        if (argumentsNode) {
          args.push(new Literal('arguments'));
        }
        func = new Value(func, [new Access(meth)]);
      }
      func.noReturn = noReturn;
      call = new Call(func, args);
      if (statement) {
        return Block.wrap([call]);
      } else {
        return call;
      }
    },
    isLiteralArguments: function(node) {
      return node instanceof Literal && node.value === 'arguments' && !node.asKey;
    },
    isLiteralThis: function(node) {
      return (node instanceof Literal && node.value === 'this' && !node.asKey) || (node instanceof Code && node.bound) || (node instanceof Call && node.isSuper);
    }
  };

  unfoldSoak = function(o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };

  CpsCascade = {
    wrap: function(statement, rest, returnValue, o) {
      var args, block, call, cont, e, func;
      func = new Code([new Param(new Literal(iced["const"].k))], Block.wrap([statement]), 'icedgen');
      args = [];
      if (returnValue) {
        returnValue.bindName(o);
        args.push(returnValue);
      }
      block = Block.wrap([rest]);
      if ((e = block.icedGetSingle()) && e instanceof IcedTailCall && e.canInline()) {
        cont = e.extractFunc();
      } else {
        cont = new Code(args, block, 'icedgen');
      }
      call = new Call(func, [cont]);
      return new Block([call]);
    }
  };

  IcedTailCall = (function(_super) {
    __extends(IcedTailCall, _super);

    function IcedTailCall(func, val) {
      this.func = func;
      if (val == null) {
        val = null;
      }
      IcedTailCall.__super__.constructor.call(this);
      if (!this.func) {
        this.func = iced["const"].k;
      }
      this.value = val;
    }

    IcedTailCall.prototype.children = ['value'];

    IcedTailCall.prototype.assignValue = function(v) {
      return this.value = v;
    };

    IcedTailCall.prototype.canInline = function() {
      return !this.value || this.value instanceof IcedReturnValue;
    };

    IcedTailCall.prototype.literalFunc = function() {
      return new Literal(this.func);
    };

    IcedTailCall.prototype.extractFunc = function() {
      return new Value(this.literalFunc());
    };

    IcedTailCall.prototype.compileNode = function(o) {
      var args, f, out;
      f = this.literalFunc();
      out = o.level === LEVEL_TOP ? this.value ? new Block([this.value, new Call(f)]) : new Call(f) : (args = this.value ? [this.value] : [], new Call(f, args));
      return out.compileNode(o);
    };

    return IcedTailCall;

  })(Base);

  IcedReturnValue = (function(_super) {
    __extends(IcedReturnValue, _super);

    IcedReturnValue.counter = 0;

    function IcedReturnValue() {
      IcedReturnValue.__super__.constructor.call(this, null, null, false);
    }

    IcedReturnValue.prototype.bindName = function(o) {
      var l;
      l = "" + (o.scope.freeVariable(iced["const"].param, false)) + "_" + (IcedReturnValue.counter++);
      return this.name = new Literal(l);
    };

    IcedReturnValue.prototype.compile = function(o) {
      if (!this.name) {
        this.bindName(o);
      }
      return IcedReturnValue.__super__.compile.call(this, o);
    };

    return IcedReturnValue;

  })(Param);

  InlineRuntime = {
    generate: function(ns_window) {
      var a1, a2, af, apply_call, assignments, body, call_meth, cn, cnt, cnt_member, constructor_assign, constructor_body, constructor_code, constructor_name, constructor_params, decr, defer_assign, defer_body, defer_code, defer_name, defer_params, dp, dp_value, fn, fn_assign, fn_code, fn_name, if_body, if_cond, if_expr, inc, inner_body, inner_code, inner_params, ip, k, k_member, klass, klass_assign, my_apply, my_if, my_null, ns, ns_obj, ns_val, obj, outer_block, p1, ret_member, tr_assign, tr_block, tr_code, tr_name, tr_params, _fulfill_assign, _fulfill_body, _fulfill_call, _fulfill_code, _fulfill_method, _fulfill_name;
      k = new Literal("continuation");
      cnt = new Literal("count");
      cn = new Value(new Literal(iced["const"].Deferrals));
      ns = new Value(new Literal(iced["const"].ns));
      if (ns_window) {
        ns_window.add(new Access(ns));
        ns = ns_window;
      }
      k_member = new Value(new Literal("this"));
      k_member.add(new Access(k));
      p1 = new Param(k_member);
      cnt_member = new Value(new Literal("this"));
      cnt_member.add(new Access(cnt));
      ret_member = new Value(new Literal("this"));
      ret_member.add(new Access(new Value(new Literal(iced["const"].retslot))));
      a1 = new Assign(cnt_member, new Value(new Literal(1)));
      a2 = new Assign(ret_member, NULL());
      constructor_params = [p1];
      constructor_body = new Block([a1, a2]);
      constructor_code = new Code(constructor_params, constructor_body);
      constructor_name = new Value(new Literal("constructor"));
      constructor_assign = new Assign(constructor_name, constructor_code);
      if_expr = new Call(k_member, [ret_member]);
      if_body = new Block([if_expr]);
      decr = new Op('--', cnt_member);
      if_cond = new Op('!', decr);
      my_if = new If(if_cond, if_body);
      _fulfill_body = new Block([my_if]);
      _fulfill_code = new Code([], _fulfill_body);
      _fulfill_name = new Value(new Literal(iced["const"].fulfill));
      _fulfill_assign = new Assign(_fulfill_name, _fulfill_code);
      inc = new Op("++", cnt_member);
      ip = new Literal("inner_params");
      dp = new Literal("defer_params");
      dp_value = new Value(dp);
      call_meth = new Value(dp);
      af = new Literal(iced["const"].assign_fn);
      call_meth.add(new Access(af, "soak"));
      my_apply = new Literal("apply");
      call_meth.add(new Access(my_apply, "soak"));
      my_null = NULL();
      apply_call = new Call(call_meth, [my_null, new Value(ip)]);
      _fulfill_method = new Value(new Literal("this"));
      _fulfill_method.add(new Access(new Literal(iced["const"].fulfill)));
      _fulfill_call = new Call(_fulfill_method, []);
      inner_body = new Block([apply_call, _fulfill_call]);
      inner_params = [new Param(ip, null, true)];
      inner_code = new Code(inner_params, inner_body, "boundfunc");
      defer_body = new Block([inc, inner_code]);
      defer_params = [new Param(dp)];
      defer_code = new Code(defer_params, defer_body);
      defer_name = new Value(new Literal(iced["const"].defer_method));
      defer_assign = new Assign(defer_name, defer_code);
      assignments = [constructor_assign, _fulfill_assign, defer_assign];
      obj = new Obj(assignments, true);
      body = new Block([new Value(obj)]);
      klass = new Class(null, null, body);
      klass_assign = new Assign(cn, klass, "object");
      outer_block = new Block([NULL()]);
      fn_code = new Code([], outer_block);
      fn_name = new Value(new Literal(iced["const"].findDeferral));
      fn_assign = new Assign(fn_name, fn_code, "object");
      fn = new Literal("_fn");
      tr_block = new Block([new Call(new Value(fn), [])]);
      tr_params = [new Param(fn)];
      tr_code = new Code(tr_params, tr_block);
      tr_name = new Value(new Literal(iced["const"].trampoline));
      tr_assign = new Assign(tr_name, tr_code, "object");
      ns_obj = new Obj([klass_assign, fn_assign, tr_assign], true);
      ns_val = new Value(ns_obj);
      return new Assign(ns, ns_val);
    }
  };

  UTILITIES = {
    "extends": function() {
      return "function(child, parent) { for (var key in parent) { if (" + (utility('hasProp')) + ".call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }";
    },
    bind: function() {
      return 'function(fn, me){ return function(){ return fn.apply(me, arguments); }; }';
    },
    indexOf: function() {
      return "[].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }";
    },
    modulo: function() {
      return "function(a, b) { return (+a % (b = +b) + b) % b; }";
    },
    hasProp: function() {
      return '{}.hasOwnProperty';
    },
    slice: function() {
      return '[].slice';
    }
  };

  LEVEL_TOP = 1;

  LEVEL_PAREN = 2;

  LEVEL_LIST = 3;

  LEVEL_COND = 4;

  LEVEL_OP = 5;

  LEVEL_ACCESS = 6;

  TAB = '  ';

  IDENTIFIER_STR = "[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*";

  IDENTIFIER = RegExp("^" + IDENTIFIER_STR + "$");

  SIMPLENUM = /^[+-]?\d+$/;

  HEXNUM = /^[+-]?0x[\da-f]+/i;

  NUMBER = /^[+-]?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)$/i;

  METHOD_DEF = RegExp("^(" + IDENTIFIER_STR + ")(\\.prototype)?(?:\\.(" + IDENTIFIER_STR + ")|\\[(\"(?:[^\\\\\"\\r\\n]|\\\\.)*\"|'(?:[^\\\\'\\r\\n]|\\\\.)*')\\]|\\[(0x[\\da-fA-F]+|\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\])$");

  IS_STRING = /^['"]/;

  IS_REGEX = /^\//;

  utility = function(name) {
    var ref;
    ref = "__" + name;
    Scope.root.assign(ref, UTILITIES[name]());
    return ref;
  };

  multident = function(code, tab) {
    code = code.replace(/\n/g, '$&' + tab);
    return code.replace(/\s+$/, '');
  };

  parseNum = function(x) {
    if (x == null) {
      return 0;
    } else if (x.match(HEXNUM)) {
      return parseInt(x, 16);
    } else {
      return parseFloat(x);
    }
  };

  isLiteralArguments = function(node) {
    return node instanceof Literal && node.value === 'arguments' && !node.asKey;
  };

  isLiteralThis = function(node) {
    return (node instanceof Literal && node.value === 'this' && !node.asKey) || (node instanceof Code && node.bound) || (node instanceof Call && node.isSuper);
  };

  unfoldSoak = function(o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };

}).call(this);

}).call(this,"/lib/coffee-script")
},{"./helpers":3,"./lexer":5,"./scope":10,"iced-runtime":18,"path":21}],7:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.13 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var parser = {trace: function trace () { },
yy: {},
symbols_: {"error":2,"Root":3,"Body":4,"Line":5,"TERMINATOR":6,"Expression":7,"Statement":8,"Return":9,"Comment":10,"STATEMENT":11,"Await":12,"AWAIT":13,"Block":14,"Value":15,"Invocation":16,"Code":17,"Operation":18,"Assign":19,"If":20,"Try":21,"While":22,"For":23,"Switch":24,"Class":25,"Throw":26,"Defer":27,"INDENT":28,"OUTDENT":29,"Identifier":30,"IDENTIFIER":31,"AlphaNumeric":32,"NUMBER":33,"STRING":34,"Literal":35,"JS":36,"REGEX":37,"DEBUGGER":38,"UNDEFINED":39,"NULL":40,"BOOL":41,"Assignable":42,"=":43,"AssignObj":44,"ObjAssignable":45,":":46,"ThisProperty":47,"RETURN":48,"HERECOMMENT":49,"PARAM_START":50,"ParamList":51,"PARAM_END":52,"FuncGlyph":53,"->":54,"=>":55,"OptComma":56,",":57,"Param":58,"ParamVar":59,"...":60,"Array":61,"Object":62,"Splat":63,"SimpleAssignable":64,"Accessor":65,"Parenthetical":66,"Range":67,"This":68,".":69,"?.":70,"::":71,"?::":72,"Index":73,"INDEX_START":74,"IndexValue":75,"INDEX_END":76,"INDEX_SOAK":77,"Slice":78,"{":79,"AssignList":80,"}":81,"CLASS":82,"EXTENDS":83,"OptFuncExist":84,"Arguments":85,"SUPER":86,"DEFER":87,"FUNC_EXIST":88,"CALL_START":89,"CALL_END":90,"ArgList":91,"THIS":92,"@":93,"[":94,"]":95,"RangeDots":96,"..":97,"Arg":98,"SimpleArgs":99,"TRY":100,"Catch":101,"FINALLY":102,"CATCH":103,"THROW":104,"(":105,")":106,"WhileSource":107,"WHILE":108,"WHEN":109,"UNTIL":110,"Loop":111,"LOOP":112,"ForBody":113,"FOR":114,"ForStart":115,"ForSource":116,"ForVariables":117,"OWN":118,"ForValue":119,"FORIN":120,"FOROF":121,"BY":122,"SWITCH":123,"Whens":124,"ELSE":125,"When":126,"LEADING_WHEN":127,"IfBlock":128,"IF":129,"POST_IF":130,"UNARY":131,"UNARY_MATH":132,"-":133,"+":134,"YIELD":135,"FROM":136,"--":137,"++":138,"?":139,"MATH":140,"**":141,"SHIFT":142,"COMPARE":143,"LOGIC":144,"RELATION":145,"COMPOUND_ASSIGN":146,"$accept":0,"$end":1},
terminals_: {2:"error",6:"TERMINATOR",11:"STATEMENT",13:"AWAIT",28:"INDENT",29:"OUTDENT",31:"IDENTIFIER",33:"NUMBER",34:"STRING",36:"JS",37:"REGEX",38:"DEBUGGER",39:"UNDEFINED",40:"NULL",41:"BOOL",43:"=",46:":",48:"RETURN",49:"HERECOMMENT",50:"PARAM_START",52:"PARAM_END",54:"->",55:"=>",57:",",60:"...",69:".",70:"?.",71:"::",72:"?::",74:"INDEX_START",76:"INDEX_END",77:"INDEX_SOAK",79:"{",81:"}",82:"CLASS",83:"EXTENDS",86:"SUPER",87:"DEFER",88:"FUNC_EXIST",89:"CALL_START",90:"CALL_END",92:"THIS",93:"@",94:"[",95:"]",97:"..",100:"TRY",102:"FINALLY",103:"CATCH",104:"THROW",105:"(",106:")",108:"WHILE",109:"WHEN",110:"UNTIL",112:"LOOP",114:"FOR",118:"OWN",120:"FORIN",121:"FOROF",122:"BY",123:"SWITCH",125:"ELSE",127:"LEADING_WHEN",129:"IF",130:"POST_IF",131:"UNARY",132:"UNARY_MATH",133:"-",134:"+",135:"YIELD",136:"FROM",137:"--",138:"++",139:"?",140:"MATH",141:"**",142:"SHIFT",143:"COMPARE",144:"LOGIC",145:"RELATION",146:"COMPOUND_ASSIGN"},
productions_: [0,[3,0],[3,1],[4,1],[4,3],[4,2],[5,1],[5,1],[8,1],[8,1],[8,1],[8,1],[12,2],[12,2],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[7,1],[14,2],[14,3],[30,1],[32,1],[32,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[35,1],[19,3],[19,4],[19,5],[44,1],[44,3],[44,5],[44,1],[45,1],[45,1],[45,1],[9,2],[9,1],[10,1],[17,5],[17,2],[53,1],[53,1],[56,0],[56,1],[51,0],[51,1],[51,3],[51,4],[51,6],[58,1],[58,2],[58,3],[58,1],[59,1],[59,1],[59,1],[59,1],[63,2],[64,1],[64,2],[64,2],[64,1],[42,1],[42,1],[42,1],[15,1],[15,1],[15,1],[15,1],[15,1],[65,2],[65,2],[65,2],[65,2],[65,2],[65,1],[65,1],[73,3],[73,2],[75,1],[75,1],[62,4],[80,0],[80,1],[80,3],[80,4],[80,6],[25,1],[25,2],[25,3],[25,4],[25,2],[25,3],[25,4],[25,5],[16,3],[16,3],[16,1],[16,2],[27,2],[84,0],[84,1],[85,2],[85,4],[68,1],[68,1],[47,2],[61,2],[61,4],[96,1],[96,1],[67,5],[78,3],[78,2],[78,2],[78,1],[91,1],[91,3],[91,4],[91,4],[91,6],[98,1],[98,1],[98,1],[99,1],[99,3],[21,2],[21,3],[21,4],[21,5],[101,3],[101,3],[101,2],[26,2],[66,3],[66,5],[107,2],[107,4],[107,2],[107,4],[22,2],[22,2],[22,2],[22,1],[111,2],[111,2],[23,2],[23,2],[23,2],[113,2],[113,2],[115,2],[115,3],[119,1],[119,1],[119,1],[119,1],[117,1],[117,3],[116,2],[116,2],[116,4],[116,4],[116,4],[116,6],[116,6],[24,5],[24,7],[24,4],[24,6],[124,1],[124,2],[126,3],[126,4],[128,3],[128,5],[20,1],[20,3],[20,3],[20,3],[18,2],[18,2],[18,2],[18,2],[18,2],[18,2],[18,3],[18,2],[18,2],[18,2],[18,2],[18,2],[18,3],[18,3],[18,3],[18,3],[18,3],[18,3],[18,3],[18,3],[18,3],[18,5],[18,4],[18,3]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */
) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:return this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Block);
break;
case 2:return this.$ = $$[$0];
break;
case 3:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(yy.Block.wrap([$$[$0]]));
break;
case 4:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].push($$[$0]));
break;
case 5:this.$ = $$[$0-1];
break;
case 6:this.$ = $$[$0];
break;
case 7:this.$ = $$[$0];
break;
case 8:this.$ = $$[$0];
break;
case 9:this.$ = $$[$0];
break;
case 10:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0]));
break;
case 11:this.$ = $$[$0];
break;
case 12:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Await($$[$0]));
break;
case 13:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Await(yy.Block.wrap([$$[$0]])));
break;
case 14:this.$ = $$[$0];
break;
case 15:this.$ = $$[$0];
break;
case 16:this.$ = $$[$0];
break;
case 17:this.$ = $$[$0];
break;
case 18:this.$ = $$[$0];
break;
case 19:this.$ = $$[$0];
break;
case 20:this.$ = $$[$0];
break;
case 21:this.$ = $$[$0];
break;
case 22:this.$ = $$[$0];
break;
case 23:this.$ = $$[$0];
break;
case 24:this.$ = $$[$0];
break;
case 25:this.$ = $$[$0];
break;
case 26:this.$ = $$[$0];
break;
case 27:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Block);
break;
case 28:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-1]);
break;
case 29:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0]));
break;
case 30:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0]));
break;
case 31:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0]));
break;
case 32:this.$ = $$[$0];
break;
case 33:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0]));
break;
case 34:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0]));
break;
case 35:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Literal($$[$0]));
break;
case 36:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Undefined);
break;
case 37:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Null);
break;
case 38:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Bool($$[$0]));
break;
case 39:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign($$[$0-2], $$[$0]));
break;
case 40:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Assign($$[$0-3], $$[$0]));
break;
case 41:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign($$[$0-4], $$[$0-1]));
break;
case 42:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 43:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0-2])(new yy.Value($$[$0-2])), $$[$0], 'object'));
break;
case 44:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign(yy.addLocationDataFn(_$[$0-4])(new yy.Value($$[$0-4])), $$[$0-1], 'object'));
break;
case 45:this.$ = $$[$0];
break;
case 46:this.$ = $$[$0];
break;
case 47:this.$ = $$[$0];
break;
case 48:this.$ = $$[$0];
break;
case 49:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Return($$[$0]));
break;
case 50:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Return);
break;
case 51:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Comment($$[$0]));
break;
case 52:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Code($$[$0-3], $$[$0], $$[$0-1]));
break;
case 53:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Code([], $$[$0], $$[$0-1]));
break;
case 54:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('func');
break;
case 55:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('boundfunc');
break;
case 56:this.$ = $$[$0];
break;
case 57:this.$ = $$[$0];
break;
case 58:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([]);
break;
case 59:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([$$[$0]]);
break;
case 60:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].concat($$[$0]));
break;
case 61:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])($$[$0-3].concat($$[$0]));
break;
case 62:this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])($$[$0-5].concat($$[$0-2]));
break;
case 63:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Param($$[$0]));
break;
case 64:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Param($$[$0-1], null, true));
break;
case 65:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Param($$[$0-2], $$[$0]));
break;
case 66:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Expansion);
break;
case 67:this.$ = $$[$0];
break;
case 68:this.$ = $$[$0];
break;
case 69:this.$ = $$[$0];
break;
case 70:this.$ = $$[$0];
break;
case 71:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Splat($$[$0-1]));
break;
case 72:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 73:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0-1].add($$[$0]));
break;
case 74:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Value($$[$0-1], [].concat($$[$0])));
break;
case 75:this.$ = $$[$0];
break;
case 76:this.$ = $$[$0];
break;
case 77:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 78:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 79:this.$ = $$[$0];
break;
case 80:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 81:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 82:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 83:this.$ = $$[$0];
break;
case 84:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Access($$[$0]));
break;
case 85:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Access($$[$0].setCustom()));
break;
case 86:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Access($$[$0], 'soak'));
break;
case 87:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([yy.addLocationDataFn(_$[$0-1])(new yy.Access(new yy.Literal('prototype'))), yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))]);
break;
case 88:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([yy.addLocationDataFn(_$[$0-1])(new yy.Access(new yy.Literal('prototype'), 'soak')), yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))]);
break;
case 89:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Access(new yy.Literal('prototype')));
break;
case 90:this.$ = $$[$0];
break;
case 91:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-1]);
break;
case 92:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(yy.extend($$[$0], {
          soak: true
        }));
break;
case 93:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Index($$[$0]));
break;
case 94:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Slice($$[$0]));
break;
case 95:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Obj($$[$0-2], $$[$0-3].generated));
break;
case 96:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([]);
break;
case 97:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([$$[$0]]);
break;
case 98:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].concat($$[$0]));
break;
case 99:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])($$[$0-3].concat($$[$0]));
break;
case 100:this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])($$[$0-5].concat($$[$0-2]));
break;
case 101:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Class);
break;
case 102:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Class(null, null, $$[$0]));
break;
case 103:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Class(null, $$[$0]));
break;
case 104:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Class(null, $$[$0-1], $$[$0]));
break;
case 105:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Class($$[$0]));
break;
case 106:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Class($$[$0-1], null, $$[$0]));
break;
case 107:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Class($$[$0-2], $$[$0]));
break;
case 108:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Class($$[$0-3], $$[$0-1], $$[$0]));
break;
case 109:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Call($$[$0-2], $$[$0], $$[$0-1]));
break;
case 110:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Call($$[$0-2], $$[$0], $$[$0-1]));
break;
case 111:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Call('super', [new yy.Splat(new yy.Literal('arguments'))]));
break;
case 112:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Call('super', $$[$0]));
break;
case 113:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Defer($$[$0], yylineno));
break;
case 114:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(false);
break;
case 115:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(true);
break;
case 116:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([]);
break;
case 117:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])($$[$0-2]);
break;
case 118:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value(new yy.Literal('this')));
break;
case 119:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value(new yy.Literal('this')));
break;
case 120:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Value(yy.addLocationDataFn(_$[$0-1])(new yy.Literal('this')), [yy.addLocationDataFn(_$[$0])(new yy.Access($$[$0]))], 'this'));
break;
case 121:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Arr([]));
break;
case 122:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Arr($$[$0-2]));
break;
case 123:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('inclusive');
break;
case 124:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])('exclusive');
break;
case 125:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Range($$[$0-3], $$[$0-1], $$[$0-2]));
break;
case 126:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Range($$[$0-2], $$[$0], $$[$0-1]));
break;
case 127:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Range($$[$0-1], null, $$[$0]));
break;
case 128:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Range(null, $$[$0], $$[$0-1]));
break;
case 129:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Range(null, null, $$[$0]));
break;
case 130:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([$$[$0]]);
break;
case 131:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].concat($$[$0]));
break;
case 132:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])($$[$0-3].concat($$[$0]));
break;
case 133:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])($$[$0-2]);
break;
case 134:this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])($$[$0-5].concat($$[$0-2]));
break;
case 135:this.$ = $$[$0];
break;
case 136:this.$ = $$[$0];
break;
case 137:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Expansion);
break;
case 138:this.$ = $$[$0];
break;
case 139:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([].concat($$[$0-2], $$[$0]));
break;
case 140:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Try($$[$0]));
break;
case 141:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Try($$[$0-1], $$[$0][0], $$[$0][1]));
break;
case 142:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Try($$[$0-2], null, null, $$[$0]));
break;
case 143:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Try($$[$0-3], $$[$0-2][0], $$[$0-2][1], $$[$0]));
break;
case 144:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([$$[$0-1], $$[$0]]);
break;
case 145:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([yy.addLocationDataFn(_$[$0-1])(new yy.Value($$[$0-1])), $$[$0]]);
break;
case 146:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])([null, $$[$0]]);
break;
case 147:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Throw($$[$0]));
break;
case 148:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Parens($$[$0-1]));
break;
case 149:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Parens($$[$0-2]));
break;
case 150:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While($$[$0]));
break;
case 151:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.While($$[$0-2], {
          guard: $$[$0]
        }));
break;
case 152:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While($$[$0], {
          invert: true
        }));
break;
case 153:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.While($$[$0-2], {
          invert: true,
          guard: $$[$0]
        }));
break;
case 154:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0-1].addBody($$[$0]));
break;
case 155:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0].addBody(yy.addLocationDataFn(_$[$0-1])(yy.Block.wrap([$$[$0-1]]))));
break;
case 156:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0].addBody(yy.addLocationDataFn(_$[$0-1])(yy.Block.wrap([$$[$0-1]]))));
break;
case 157:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])($$[$0]);
break;
case 158:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While(yy.addLocationDataFn(_$[$0-1])(new yy.Literal('true'))).addBody($$[$0]));
break;
case 159:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.While(yy.addLocationDataFn(_$[$0-1])(new yy.Literal('true'))).addBody(yy.addLocationDataFn(_$[$0])(yy.Block.wrap([$$[$0]]))));
break;
case 160:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.For($$[$0-1], $$[$0]));
break;
case 161:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.For($$[$0-1], $$[$0]));
break;
case 162:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.For($$[$0], $$[$0-1]));
break;
case 163:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])({
          source: yy.addLocationDataFn(_$[$0])(new yy.Value($$[$0]))
        });
break;
case 164:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])((function() {
        $$[$0].own = $$[$0-1].own;
        $$[$0].name = $$[$0-1][0];
        $$[$0].index = $$[$0-1][1];
        return $$[$0];
      }()));
break;
case 165:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0]);
break;
case 166:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function() {
        $$[$0].own = true;
        return $$[$0];
      }()));
break;
case 167:this.$ = $$[$0];
break;
case 168:this.$ = $$[$0];
break;
case 169:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 170:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])(new yy.Value($$[$0]));
break;
case 171:this.$ = yy.addLocationDataFn(_$[$0], _$[$0])([$$[$0]]);
break;
case 172:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([$$[$0-2], $$[$0]]);
break;
case 173:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])({
          source: $$[$0]
        });
break;
case 174:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])({
          source: $$[$0],
          object: true
        });
break;
case 175:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: $$[$0-2],
          guard: $$[$0]
        });
break;
case 176:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: $$[$0-2],
          guard: $$[$0],
          object: true
        });
break;
case 177:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])({
          source: $$[$0-2],
          step: $$[$0]
        });
break;
case 178:this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])({
          source: $$[$0-4],
          guard: $$[$0-2],
          step: $$[$0]
        });
break;
case 179:this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])({
          source: $$[$0-4],
          step: $$[$0-2],
          guard: $$[$0]
        });
break;
case 180:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Switch($$[$0-3], $$[$0-1]));
break;
case 181:this.$ = yy.addLocationDataFn(_$[$0-6], _$[$0])(new yy.Switch($$[$0-5], $$[$0-3], $$[$0-1]));
break;
case 182:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Switch(null, $$[$0-1]));
break;
case 183:this.$ = yy.addLocationDataFn(_$[$0-5], _$[$0])(new yy.Switch(null, $$[$0-3], $$[$0-1]));
break;
case 184:this.$ = $$[$0];
break;
case 185:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])($$[$0-1].concat($$[$0]));
break;
case 186:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])([[$$[$0-1], $$[$0]]]);
break;
case 187:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])([[$$[$0-2], $$[$0-1]]]);
break;
case 188:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0-1], $$[$0], {
          type: $$[$0-2]
        }));
break;
case 189:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])($$[$0-4].addElse(yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0-1], $$[$0], {
          type: $$[$0-2]
        }))));
break;
case 190:this.$ = $$[$0];
break;
case 191:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])($$[$0-2].addElse($$[$0]));
break;
case 192:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0], yy.addLocationDataFn(_$[$0-2])(yy.Block.wrap([$$[$0-2]])), {
          type: $$[$0-1],
          statement: true
        }));
break;
case 193:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.If($$[$0], yy.addLocationDataFn(_$[$0-2])(yy.Block.wrap([$$[$0-2]])), {
          type: $$[$0-1],
          statement: true
        }));
break;
case 194:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op($$[$0-1], $$[$0]));
break;
case 195:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op($$[$0-1], $$[$0]));
break;
case 196:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('-', $$[$0]));
break;
case 197:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('+', $$[$0]));
break;
case 198:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op($$[$0-1], $$[$0]));
break;
case 199:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op($$[$0-1], $$[$0]));
break;
case 200:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-2].concat($$[$0-1]), $$[$0]));
break;
case 201:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('--', $$[$0]));
break;
case 202:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('++', $$[$0]));
break;
case 203:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('--', $$[$0-1], null, true));
break;
case 204:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Op('++', $$[$0-1], null, true));
break;
case 205:this.$ = yy.addLocationDataFn(_$[$0-1], _$[$0])(new yy.Existence($$[$0-1]));
break;
case 206:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op('+', $$[$0-2], $$[$0]));
break;
case 207:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op('-', $$[$0-2], $$[$0]));
break;
case 208:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-1], $$[$0-2], $$[$0]));
break;
case 209:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-1], $$[$0-2], $$[$0]));
break;
case 210:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-1], $$[$0-2], $$[$0]));
break;
case 211:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-1], $$[$0-2], $$[$0]));
break;
case 212:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Op($$[$0-1], $$[$0-2], $$[$0]));
break;
case 213:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])((function() {
        if ($$[$0-1].charAt(0) === '!') {
          return new yy.Op($$[$0-1].slice(1), $$[$0-2], $$[$0]).invert();
        } else {
          return new yy.Op($$[$0-1], $$[$0-2], $$[$0]);
        }
      }()));
break;
case 214:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Assign($$[$0-2], $$[$0], $$[$0-1]));
break;
case 215:this.$ = yy.addLocationDataFn(_$[$0-4], _$[$0])(new yy.Assign($$[$0-4], $$[$0-1], $$[$0-3]));
break;
case 216:this.$ = yy.addLocationDataFn(_$[$0-3], _$[$0])(new yy.Assign($$[$0-3], $$[$0], $$[$0-2]));
break;
case 217:this.$ = yy.addLocationDataFn(_$[$0-2], _$[$0])(new yy.Extends($$[$0-2], $$[$0]));
break;
}
},
table: [{1:[2,1],3:1,4:2,5:3,7:4,8:5,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[3]},{1:[2,2],6:[1,78]},{1:[2,3],6:[2,3],29:[2,3],106:[2,3]},{1:[2,6],6:[2,6],29:[2,6],106:[2,6],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,7],6:[2,7],29:[2,7],106:[2,7],107:92,108:[1,69],110:[1,70],113:93,114:[1,72],115:73,130:[1,91]},{1:[2,14],6:[2,14],28:[2,14],29:[2,14],52:[2,14],57:[2,14],60:[2,14],65:95,69:[1,97],70:[1,98],71:[1,99],72:[1,100],73:101,74:[1,102],76:[2,14],77:[1,103],81:[2,14],84:94,88:[1,96],89:[2,114],90:[2,14],95:[2,14],97:[2,14],106:[2,14],108:[2,14],109:[2,14],110:[2,14],114:[2,14],122:[2,14],130:[2,14],133:[2,14],134:[2,14],139:[2,14],140:[2,14],141:[2,14],142:[2,14],143:[2,14],144:[2,14],145:[2,14]},{1:[2,15],6:[2,15],28:[2,15],29:[2,15],52:[2,15],57:[2,15],60:[2,15],65:105,69:[1,97],70:[1,98],71:[1,99],72:[1,100],73:101,74:[1,102],76:[2,15],77:[1,103],81:[2,15],84:104,88:[1,96],89:[2,114],90:[2,15],95:[2,15],97:[2,15],106:[2,15],108:[2,15],109:[2,15],110:[2,15],114:[2,15],122:[2,15],130:[2,15],133:[2,15],134:[2,15],139:[2,15],140:[2,15],141:[2,15],142:[2,15],143:[2,15],144:[2,15],145:[2,15]},{1:[2,16],6:[2,16],28:[2,16],29:[2,16],52:[2,16],57:[2,16],60:[2,16],76:[2,16],81:[2,16],90:[2,16],95:[2,16],97:[2,16],106:[2,16],108:[2,16],109:[2,16],110:[2,16],114:[2,16],122:[2,16],130:[2,16],133:[2,16],134:[2,16],139:[2,16],140:[2,16],141:[2,16],142:[2,16],143:[2,16],144:[2,16],145:[2,16]},{1:[2,17],6:[2,17],28:[2,17],29:[2,17],52:[2,17],57:[2,17],60:[2,17],76:[2,17],81:[2,17],90:[2,17],95:[2,17],97:[2,17],106:[2,17],108:[2,17],109:[2,17],110:[2,17],114:[2,17],122:[2,17],130:[2,17],133:[2,17],134:[2,17],139:[2,17],140:[2,17],141:[2,17],142:[2,17],143:[2,17],144:[2,17],145:[2,17]},{1:[2,18],6:[2,18],28:[2,18],29:[2,18],52:[2,18],57:[2,18],60:[2,18],76:[2,18],81:[2,18],90:[2,18],95:[2,18],97:[2,18],106:[2,18],108:[2,18],109:[2,18],110:[2,18],114:[2,18],122:[2,18],130:[2,18],133:[2,18],134:[2,18],139:[2,18],140:[2,18],141:[2,18],142:[2,18],143:[2,18],144:[2,18],145:[2,18]},{1:[2,19],6:[2,19],28:[2,19],29:[2,19],52:[2,19],57:[2,19],60:[2,19],76:[2,19],81:[2,19],90:[2,19],95:[2,19],97:[2,19],106:[2,19],108:[2,19],109:[2,19],110:[2,19],114:[2,19],122:[2,19],130:[2,19],133:[2,19],134:[2,19],139:[2,19],140:[2,19],141:[2,19],142:[2,19],143:[2,19],144:[2,19],145:[2,19]},{1:[2,20],6:[2,20],28:[2,20],29:[2,20],52:[2,20],57:[2,20],60:[2,20],76:[2,20],81:[2,20],90:[2,20],95:[2,20],97:[2,20],106:[2,20],108:[2,20],109:[2,20],110:[2,20],114:[2,20],122:[2,20],130:[2,20],133:[2,20],134:[2,20],139:[2,20],140:[2,20],141:[2,20],142:[2,20],143:[2,20],144:[2,20],145:[2,20]},{1:[2,21],6:[2,21],28:[2,21],29:[2,21],52:[2,21],57:[2,21],60:[2,21],76:[2,21],81:[2,21],90:[2,21],95:[2,21],97:[2,21],106:[2,21],108:[2,21],109:[2,21],110:[2,21],114:[2,21],122:[2,21],130:[2,21],133:[2,21],134:[2,21],139:[2,21],140:[2,21],141:[2,21],142:[2,21],143:[2,21],144:[2,21],145:[2,21]},{1:[2,22],6:[2,22],28:[2,22],29:[2,22],52:[2,22],57:[2,22],60:[2,22],76:[2,22],81:[2,22],90:[2,22],95:[2,22],97:[2,22],106:[2,22],108:[2,22],109:[2,22],110:[2,22],114:[2,22],122:[2,22],130:[2,22],133:[2,22],134:[2,22],139:[2,22],140:[2,22],141:[2,22],142:[2,22],143:[2,22],144:[2,22],145:[2,22]},{1:[2,23],6:[2,23],28:[2,23],29:[2,23],52:[2,23],57:[2,23],60:[2,23],76:[2,23],81:[2,23],90:[2,23],95:[2,23],97:[2,23],106:[2,23],108:[2,23],109:[2,23],110:[2,23],114:[2,23],122:[2,23],130:[2,23],133:[2,23],134:[2,23],139:[2,23],140:[2,23],141:[2,23],142:[2,23],143:[2,23],144:[2,23],145:[2,23]},{1:[2,24],6:[2,24],28:[2,24],29:[2,24],52:[2,24],57:[2,24],60:[2,24],76:[2,24],81:[2,24],90:[2,24],95:[2,24],97:[2,24],106:[2,24],108:[2,24],109:[2,24],110:[2,24],114:[2,24],122:[2,24],130:[2,24],133:[2,24],134:[2,24],139:[2,24],140:[2,24],141:[2,24],142:[2,24],143:[2,24],144:[2,24],145:[2,24]},{1:[2,25],6:[2,25],28:[2,25],29:[2,25],52:[2,25],57:[2,25],60:[2,25],76:[2,25],81:[2,25],90:[2,25],95:[2,25],97:[2,25],106:[2,25],108:[2,25],109:[2,25],110:[2,25],114:[2,25],122:[2,25],130:[2,25],133:[2,25],134:[2,25],139:[2,25],140:[2,25],141:[2,25],142:[2,25],143:[2,25],144:[2,25],145:[2,25]},{1:[2,26],6:[2,26],28:[2,26],29:[2,26],52:[2,26],57:[2,26],60:[2,26],76:[2,26],81:[2,26],90:[2,26],95:[2,26],97:[2,26],106:[2,26],108:[2,26],109:[2,26],110:[2,26],114:[2,26],122:[2,26],130:[2,26],133:[2,26],134:[2,26],139:[2,26],140:[2,26],141:[2,26],142:[2,26],143:[2,26],144:[2,26],145:[2,26]},{1:[2,8],6:[2,8],28:[2,8],29:[2,8],52:[2,8],57:[2,8],60:[2,8],76:[2,8],81:[2,8],90:[2,8],95:[2,8],97:[2,8],106:[2,8],108:[2,8],109:[2,8],110:[2,8],114:[2,8],122:[2,8],130:[2,8],133:[2,8],134:[2,8],139:[2,8],140:[2,8],141:[2,8],142:[2,8],143:[2,8],144:[2,8],145:[2,8]},{1:[2,9],6:[2,9],28:[2,9],29:[2,9],52:[2,9],57:[2,9],60:[2,9],76:[2,9],81:[2,9],90:[2,9],95:[2,9],97:[2,9],106:[2,9],108:[2,9],109:[2,9],110:[2,9],114:[2,9],122:[2,9],130:[2,9],133:[2,9],134:[2,9],139:[2,9],140:[2,9],141:[2,9],142:[2,9],143:[2,9],144:[2,9],145:[2,9]},{1:[2,10],6:[2,10],28:[2,10],29:[2,10],52:[2,10],57:[2,10],60:[2,10],76:[2,10],81:[2,10],90:[2,10],95:[2,10],97:[2,10],106:[2,10],108:[2,10],109:[2,10],110:[2,10],114:[2,10],122:[2,10],130:[2,10],133:[2,10],134:[2,10],139:[2,10],140:[2,10],141:[2,10],142:[2,10],143:[2,10],144:[2,10],145:[2,10]},{1:[2,11],6:[2,11],28:[2,11],29:[2,11],52:[2,11],57:[2,11],60:[2,11],76:[2,11],81:[2,11],90:[2,11],95:[2,11],97:[2,11],106:[2,11],108:[2,11],109:[2,11],110:[2,11],114:[2,11],122:[2,11],130:[2,11],133:[2,11],134:[2,11],139:[2,11],140:[2,11],141:[2,11],142:[2,11],143:[2,11],144:[2,11],145:[2,11]},{1:[2,79],6:[2,79],28:[2,79],29:[2,79],43:[1,106],52:[2,79],57:[2,79],60:[2,79],69:[2,79],70:[2,79],71:[2,79],72:[2,79],74:[2,79],76:[2,79],77:[2,79],81:[2,79],88:[2,79],89:[2,79],90:[2,79],95:[2,79],97:[2,79],106:[2,79],108:[2,79],109:[2,79],110:[2,79],114:[2,79],122:[2,79],130:[2,79],133:[2,79],134:[2,79],139:[2,79],140:[2,79],141:[2,79],142:[2,79],143:[2,79],144:[2,79],145:[2,79]},{1:[2,80],6:[2,80],28:[2,80],29:[2,80],52:[2,80],57:[2,80],60:[2,80],69:[2,80],70:[2,80],71:[2,80],72:[2,80],74:[2,80],76:[2,80],77:[2,80],81:[2,80],88:[2,80],89:[2,80],90:[2,80],95:[2,80],97:[2,80],106:[2,80],108:[2,80],109:[2,80],110:[2,80],114:[2,80],122:[2,80],130:[2,80],133:[2,80],134:[2,80],139:[2,80],140:[2,80],141:[2,80],142:[2,80],143:[2,80],144:[2,80],145:[2,80]},{1:[2,81],6:[2,81],28:[2,81],29:[2,81],52:[2,81],57:[2,81],60:[2,81],69:[2,81],70:[2,81],71:[2,81],72:[2,81],74:[2,81],76:[2,81],77:[2,81],81:[2,81],88:[2,81],89:[2,81],90:[2,81],95:[2,81],97:[2,81],106:[2,81],108:[2,81],109:[2,81],110:[2,81],114:[2,81],122:[2,81],130:[2,81],133:[2,81],134:[2,81],139:[2,81],140:[2,81],141:[2,81],142:[2,81],143:[2,81],144:[2,81],145:[2,81]},{1:[2,82],6:[2,82],28:[2,82],29:[2,82],52:[2,82],57:[2,82],60:[2,82],69:[2,82],70:[2,82],71:[2,82],72:[2,82],74:[2,82],76:[2,82],77:[2,82],81:[2,82],88:[2,82],89:[2,82],90:[2,82],95:[2,82],97:[2,82],106:[2,82],108:[2,82],109:[2,82],110:[2,82],114:[2,82],122:[2,82],130:[2,82],133:[2,82],134:[2,82],139:[2,82],140:[2,82],141:[2,82],142:[2,82],143:[2,82],144:[2,82],145:[2,82]},{1:[2,83],6:[2,83],28:[2,83],29:[2,83],52:[2,83],57:[2,83],60:[2,83],69:[2,83],70:[2,83],71:[2,83],72:[2,83],74:[2,83],76:[2,83],77:[2,83],81:[2,83],88:[2,83],89:[2,83],90:[2,83],95:[2,83],97:[2,83],106:[2,83],108:[2,83],109:[2,83],110:[2,83],114:[2,83],122:[2,83],130:[2,83],133:[2,83],134:[2,83],139:[2,83],140:[2,83],141:[2,83],142:[2,83],143:[2,83],144:[2,83],145:[2,83]},{1:[2,111],6:[2,111],28:[2,111],29:[2,111],52:[2,111],57:[2,111],60:[2,111],69:[2,111],70:[2,111],71:[2,111],72:[2,111],74:[2,111],76:[2,111],77:[2,111],81:[2,111],85:107,88:[2,111],89:[1,108],90:[2,111],95:[2,111],97:[2,111],106:[2,111],108:[2,111],109:[2,111],110:[2,111],114:[2,111],122:[2,111],130:[2,111],133:[2,111],134:[2,111],139:[2,111],140:[2,111],141:[2,111],142:[2,111],143:[2,111],144:[2,111],145:[2,111]},{6:[2,58],28:[2,58],30:113,31:[1,77],47:114,51:109,52:[2,58],57:[2,58],58:110,59:111,60:[1,112],61:115,62:116,79:[1,74],93:[1,117],94:[1,118]},{14:119,28:[1,120]},{7:121,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:123,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:124,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:125,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:127,8:126,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],136:[1,128],137:[1,36],138:[1,37]},{15:130,16:131,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:132,47:67,61:51,62:52,64:129,66:25,67:26,68:27,79:[1,74],86:[1,28],92:[1,62],93:[1,63],94:[1,61],105:[1,60]},{15:130,16:131,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:132,47:67,61:51,62:52,64:133,66:25,67:26,68:27,79:[1,74],86:[1,28],92:[1,62],93:[1,63],94:[1,61],105:[1,60]},{1:[2,76],6:[2,76],28:[2,76],29:[2,76],43:[2,76],52:[2,76],57:[2,76],60:[2,76],69:[2,76],70:[2,76],71:[2,76],72:[2,76],74:[2,76],76:[2,76],77:[2,76],81:[2,76],83:[1,137],88:[2,76],89:[2,76],90:[2,76],95:[2,76],97:[2,76],106:[2,76],108:[2,76],109:[2,76],110:[2,76],114:[2,76],122:[2,76],130:[2,76],133:[2,76],134:[2,76],137:[1,134],138:[1,135],139:[2,76],140:[2,76],141:[2,76],142:[2,76],143:[2,76],144:[2,76],145:[2,76],146:[1,136]},{1:[2,190],6:[2,190],28:[2,190],29:[2,190],52:[2,190],57:[2,190],60:[2,190],76:[2,190],81:[2,190],90:[2,190],95:[2,190],97:[2,190],106:[2,190],108:[2,190],109:[2,190],110:[2,190],114:[2,190],122:[2,190],125:[1,138],130:[2,190],133:[2,190],134:[2,190],139:[2,190],140:[2,190],141:[2,190],142:[2,190],143:[2,190],144:[2,190],145:[2,190]},{14:139,28:[1,120]},{14:140,28:[1,120]},{1:[2,157],6:[2,157],28:[2,157],29:[2,157],52:[2,157],57:[2,157],60:[2,157],76:[2,157],81:[2,157],90:[2,157],95:[2,157],97:[2,157],106:[2,157],108:[2,157],109:[2,157],110:[2,157],114:[2,157],122:[2,157],130:[2,157],133:[2,157],134:[2,157],139:[2,157],140:[2,157],141:[2,157],142:[2,157],143:[2,157],144:[2,157],145:[2,157]},{14:141,28:[1,120]},{7:142,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,143],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,101],6:[2,101],14:144,15:130,16:131,28:[1,120],29:[2,101],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:132,47:67,52:[2,101],57:[2,101],60:[2,101],61:51,62:52,64:146,66:25,67:26,68:27,76:[2,101],79:[1,74],81:[2,101],83:[1,145],86:[1,28],90:[2,101],92:[1,62],93:[1,63],94:[1,61],95:[2,101],97:[2,101],105:[1,60],106:[2,101],108:[2,101],109:[2,101],110:[2,101],114:[2,101],122:[2,101],130:[2,101],133:[2,101],134:[2,101],139:[2,101],140:[2,101],141:[2,101],142:[2,101],143:[2,101],144:[2,101],145:[2,101]},{7:147,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{85:148,89:[1,108]},{1:[2,50],6:[2,50],7:149,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[2,50],29:[2,50],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],52:[2,50],53:30,54:[1,64],55:[1,65],57:[2,50],60:[2,50],61:51,62:52,64:38,66:25,67:26,68:27,76:[2,50],79:[1,74],81:[2,50],82:[1,45],86:[1,28],87:[1,47],90:[2,50],92:[1,62],93:[1,63],94:[1,61],95:[2,50],97:[2,50],100:[1,40],104:[1,46],105:[1,60],106:[2,50],107:41,108:[2,50],109:[2,50],110:[2,50],111:42,112:[1,71],113:43,114:[2,50],115:73,122:[2,50],123:[1,44],128:39,129:[1,68],130:[2,50],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37],139:[2,50],140:[2,50],141:[2,50],142:[2,50],143:[2,50],144:[2,50],145:[2,50]},{1:[2,51],6:[2,51],28:[2,51],29:[2,51],52:[2,51],57:[2,51],60:[2,51],76:[2,51],81:[2,51],90:[2,51],95:[2,51],97:[2,51],106:[2,51],108:[2,51],109:[2,51],110:[2,51],114:[2,51],122:[2,51],130:[2,51],133:[2,51],134:[2,51],139:[2,51],140:[2,51],141:[2,51],142:[2,51],143:[2,51],144:[2,51],145:[2,51]},{7:151,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],14:150,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,120],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,77],6:[2,77],28:[2,77],29:[2,77],43:[2,77],52:[2,77],57:[2,77],60:[2,77],69:[2,77],70:[2,77],71:[2,77],72:[2,77],74:[2,77],76:[2,77],77:[2,77],81:[2,77],88:[2,77],89:[2,77],90:[2,77],95:[2,77],97:[2,77],106:[2,77],108:[2,77],109:[2,77],110:[2,77],114:[2,77],122:[2,77],130:[2,77],133:[2,77],134:[2,77],139:[2,77],140:[2,77],141:[2,77],142:[2,77],143:[2,77],144:[2,77],145:[2,77]},{1:[2,78],6:[2,78],28:[2,78],29:[2,78],43:[2,78],52:[2,78],57:[2,78],60:[2,78],69:[2,78],70:[2,78],71:[2,78],72:[2,78],74:[2,78],76:[2,78],77:[2,78],81:[2,78],88:[2,78],89:[2,78],90:[2,78],95:[2,78],97:[2,78],106:[2,78],108:[2,78],109:[2,78],110:[2,78],114:[2,78],122:[2,78],130:[2,78],133:[2,78],134:[2,78],139:[2,78],140:[2,78],141:[2,78],142:[2,78],143:[2,78],144:[2,78],145:[2,78]},{1:[2,32],6:[2,32],28:[2,32],29:[2,32],52:[2,32],57:[2,32],60:[2,32],69:[2,32],70:[2,32],71:[2,32],72:[2,32],74:[2,32],76:[2,32],77:[2,32],81:[2,32],88:[2,32],89:[2,32],90:[2,32],95:[2,32],97:[2,32],106:[2,32],108:[2,32],109:[2,32],110:[2,32],114:[2,32],122:[2,32],130:[2,32],133:[2,32],134:[2,32],139:[2,32],140:[2,32],141:[2,32],142:[2,32],143:[2,32],144:[2,32],145:[2,32]},{1:[2,33],6:[2,33],28:[2,33],29:[2,33],52:[2,33],57:[2,33],60:[2,33],69:[2,33],70:[2,33],71:[2,33],72:[2,33],74:[2,33],76:[2,33],77:[2,33],81:[2,33],88:[2,33],89:[2,33],90:[2,33],95:[2,33],97:[2,33],106:[2,33],108:[2,33],109:[2,33],110:[2,33],114:[2,33],122:[2,33],130:[2,33],133:[2,33],134:[2,33],139:[2,33],140:[2,33],141:[2,33],142:[2,33],143:[2,33],144:[2,33],145:[2,33]},{1:[2,34],6:[2,34],28:[2,34],29:[2,34],52:[2,34],57:[2,34],60:[2,34],69:[2,34],70:[2,34],71:[2,34],72:[2,34],74:[2,34],76:[2,34],77:[2,34],81:[2,34],88:[2,34],89:[2,34],90:[2,34],95:[2,34],97:[2,34],106:[2,34],108:[2,34],109:[2,34],110:[2,34],114:[2,34],122:[2,34],130:[2,34],133:[2,34],134:[2,34],139:[2,34],140:[2,34],141:[2,34],142:[2,34],143:[2,34],144:[2,34],145:[2,34]},{1:[2,35],6:[2,35],28:[2,35],29:[2,35],52:[2,35],57:[2,35],60:[2,35],69:[2,35],70:[2,35],71:[2,35],72:[2,35],74:[2,35],76:[2,35],77:[2,35],81:[2,35],88:[2,35],89:[2,35],90:[2,35],95:[2,35],97:[2,35],106:[2,35],108:[2,35],109:[2,35],110:[2,35],114:[2,35],122:[2,35],130:[2,35],133:[2,35],134:[2,35],139:[2,35],140:[2,35],141:[2,35],142:[2,35],143:[2,35],144:[2,35],145:[2,35]},{1:[2,36],6:[2,36],28:[2,36],29:[2,36],52:[2,36],57:[2,36],60:[2,36],69:[2,36],70:[2,36],71:[2,36],72:[2,36],74:[2,36],76:[2,36],77:[2,36],81:[2,36],88:[2,36],89:[2,36],90:[2,36],95:[2,36],97:[2,36],106:[2,36],108:[2,36],109:[2,36],110:[2,36],114:[2,36],122:[2,36],130:[2,36],133:[2,36],134:[2,36],139:[2,36],140:[2,36],141:[2,36],142:[2,36],143:[2,36],144:[2,36],145:[2,36]},{1:[2,37],6:[2,37],28:[2,37],29:[2,37],52:[2,37],57:[2,37],60:[2,37],69:[2,37],70:[2,37],71:[2,37],72:[2,37],74:[2,37],76:[2,37],77:[2,37],81:[2,37],88:[2,37],89:[2,37],90:[2,37],95:[2,37],97:[2,37],106:[2,37],108:[2,37],109:[2,37],110:[2,37],114:[2,37],122:[2,37],130:[2,37],133:[2,37],134:[2,37],139:[2,37],140:[2,37],141:[2,37],142:[2,37],143:[2,37],144:[2,37],145:[2,37]},{1:[2,38],6:[2,38],28:[2,38],29:[2,38],52:[2,38],57:[2,38],60:[2,38],69:[2,38],70:[2,38],71:[2,38],72:[2,38],74:[2,38],76:[2,38],77:[2,38],81:[2,38],88:[2,38],89:[2,38],90:[2,38],95:[2,38],97:[2,38],106:[2,38],108:[2,38],109:[2,38],110:[2,38],114:[2,38],122:[2,38],130:[2,38],133:[2,38],134:[2,38],139:[2,38],140:[2,38],141:[2,38],142:[2,38],143:[2,38],144:[2,38],145:[2,38]},{4:152,5:3,7:4,8:5,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,153],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:154,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,158],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],60:[1,160],61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],91:156,92:[1,62],93:[1,63],94:[1,61],95:[1,155],98:157,100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,118],6:[2,118],28:[2,118],29:[2,118],52:[2,118],57:[2,118],60:[2,118],69:[2,118],70:[2,118],71:[2,118],72:[2,118],74:[2,118],76:[2,118],77:[2,118],81:[2,118],88:[2,118],89:[2,118],90:[2,118],95:[2,118],97:[2,118],106:[2,118],108:[2,118],109:[2,118],110:[2,118],114:[2,118],122:[2,118],130:[2,118],133:[2,118],134:[2,118],139:[2,118],140:[2,118],141:[2,118],142:[2,118],143:[2,118],144:[2,118],145:[2,118]},{1:[2,119],6:[2,119],28:[2,119],29:[2,119],30:161,31:[1,77],52:[2,119],57:[2,119],60:[2,119],69:[2,119],70:[2,119],71:[2,119],72:[2,119],74:[2,119],76:[2,119],77:[2,119],81:[2,119],88:[2,119],89:[2,119],90:[2,119],95:[2,119],97:[2,119],106:[2,119],108:[2,119],109:[2,119],110:[2,119],114:[2,119],122:[2,119],130:[2,119],133:[2,119],134:[2,119],139:[2,119],140:[2,119],141:[2,119],142:[2,119],143:[2,119],144:[2,119],145:[2,119]},{28:[2,54]},{28:[2,55]},{1:[2,72],6:[2,72],28:[2,72],29:[2,72],43:[2,72],52:[2,72],57:[2,72],60:[2,72],69:[2,72],70:[2,72],71:[2,72],72:[2,72],74:[2,72],76:[2,72],77:[2,72],81:[2,72],83:[2,72],88:[2,72],89:[2,72],90:[2,72],95:[2,72],97:[2,72],106:[2,72],108:[2,72],109:[2,72],110:[2,72],114:[2,72],122:[2,72],130:[2,72],133:[2,72],134:[2,72],137:[2,72],138:[2,72],139:[2,72],140:[2,72],141:[2,72],142:[2,72],143:[2,72],144:[2,72],145:[2,72],146:[2,72]},{1:[2,75],6:[2,75],28:[2,75],29:[2,75],43:[2,75],52:[2,75],57:[2,75],60:[2,75],69:[2,75],70:[2,75],71:[2,75],72:[2,75],74:[2,75],76:[2,75],77:[2,75],81:[2,75],83:[2,75],88:[2,75],89:[2,75],90:[2,75],95:[2,75],97:[2,75],106:[2,75],108:[2,75],109:[2,75],110:[2,75],114:[2,75],122:[2,75],130:[2,75],133:[2,75],134:[2,75],137:[2,75],138:[2,75],139:[2,75],140:[2,75],141:[2,75],142:[2,75],143:[2,75],144:[2,75],145:[2,75],146:[2,75]},{7:162,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:163,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:164,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:166,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],14:165,15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,120],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{30:171,31:[1,77],47:172,61:173,62:174,67:167,79:[1,74],93:[1,117],94:[1,61],117:168,118:[1,169],119:170},{116:175,120:[1,176],121:[1,177]},{6:[2,96],10:181,28:[2,96],30:182,31:[1,77],32:183,33:[1,75],34:[1,76],44:179,45:180,47:184,49:[1,49],57:[2,96],80:178,81:[2,96],93:[1,117]},{1:[2,30],6:[2,30],28:[2,30],29:[2,30],46:[2,30],52:[2,30],57:[2,30],60:[2,30],69:[2,30],70:[2,30],71:[2,30],72:[2,30],74:[2,30],76:[2,30],77:[2,30],81:[2,30],88:[2,30],89:[2,30],90:[2,30],95:[2,30],97:[2,30],106:[2,30],108:[2,30],109:[2,30],110:[2,30],114:[2,30],122:[2,30],130:[2,30],133:[2,30],134:[2,30],139:[2,30],140:[2,30],141:[2,30],142:[2,30],143:[2,30],144:[2,30],145:[2,30]},{1:[2,31],6:[2,31],28:[2,31],29:[2,31],46:[2,31],52:[2,31],57:[2,31],60:[2,31],69:[2,31],70:[2,31],71:[2,31],72:[2,31],74:[2,31],76:[2,31],77:[2,31],81:[2,31],88:[2,31],89:[2,31],90:[2,31],95:[2,31],97:[2,31],106:[2,31],108:[2,31],109:[2,31],110:[2,31],114:[2,31],122:[2,31],130:[2,31],133:[2,31],134:[2,31],139:[2,31],140:[2,31],141:[2,31],142:[2,31],143:[2,31],144:[2,31],145:[2,31]},{1:[2,29],6:[2,29],28:[2,29],29:[2,29],43:[2,29],46:[2,29],52:[2,29],57:[2,29],60:[2,29],69:[2,29],70:[2,29],71:[2,29],72:[2,29],74:[2,29],76:[2,29],77:[2,29],81:[2,29],83:[2,29],88:[2,29],89:[2,29],90:[2,29],95:[2,29],97:[2,29],106:[2,29],108:[2,29],109:[2,29],110:[2,29],114:[2,29],120:[2,29],121:[2,29],122:[2,29],130:[2,29],133:[2,29],134:[2,29],137:[2,29],138:[2,29],139:[2,29],140:[2,29],141:[2,29],142:[2,29],143:[2,29],144:[2,29],145:[2,29],146:[2,29]},{1:[2,5],5:185,6:[2,5],7:4,8:5,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,29:[2,5],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],106:[2,5],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,205],6:[2,205],28:[2,205],29:[2,205],52:[2,205],57:[2,205],60:[2,205],76:[2,205],81:[2,205],90:[2,205],95:[2,205],97:[2,205],106:[2,205],108:[2,205],109:[2,205],110:[2,205],114:[2,205],122:[2,205],130:[2,205],133:[2,205],134:[2,205],139:[2,205],140:[2,205],141:[2,205],142:[2,205],143:[2,205],144:[2,205],145:[2,205]},{7:186,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:187,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:188,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:189,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:190,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:191,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:192,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:193,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:194,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,156],6:[2,156],28:[2,156],29:[2,156],52:[2,156],57:[2,156],60:[2,156],76:[2,156],81:[2,156],90:[2,156],95:[2,156],97:[2,156],106:[2,156],108:[2,156],109:[2,156],110:[2,156],114:[2,156],122:[2,156],130:[2,156],133:[2,156],134:[2,156],139:[2,156],140:[2,156],141:[2,156],142:[2,156],143:[2,156],144:[2,156],145:[2,156]},{1:[2,161],6:[2,161],28:[2,161],29:[2,161],52:[2,161],57:[2,161],60:[2,161],76:[2,161],81:[2,161],90:[2,161],95:[2,161],97:[2,161],106:[2,161],108:[2,161],109:[2,161],110:[2,161],114:[2,161],122:[2,161],130:[2,161],133:[2,161],134:[2,161],139:[2,161],140:[2,161],141:[2,161],142:[2,161],143:[2,161],144:[2,161],145:[2,161]},{7:195,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,155],6:[2,155],28:[2,155],29:[2,155],52:[2,155],57:[2,155],60:[2,155],76:[2,155],81:[2,155],90:[2,155],95:[2,155],97:[2,155],106:[2,155],108:[2,155],109:[2,155],110:[2,155],114:[2,155],122:[2,155],130:[2,155],133:[2,155],134:[2,155],139:[2,155],140:[2,155],141:[2,155],142:[2,155],143:[2,155],144:[2,155],145:[2,155]},{1:[2,160],6:[2,160],28:[2,160],29:[2,160],52:[2,160],57:[2,160],60:[2,160],76:[2,160],81:[2,160],90:[2,160],95:[2,160],97:[2,160],106:[2,160],108:[2,160],109:[2,160],110:[2,160],114:[2,160],122:[2,160],130:[2,160],133:[2,160],134:[2,160],139:[2,160],140:[2,160],141:[2,160],142:[2,160],143:[2,160],144:[2,160],145:[2,160]},{85:196,89:[1,108]},{1:[2,73],6:[2,73],28:[2,73],29:[2,73],43:[2,73],52:[2,73],57:[2,73],60:[2,73],69:[2,73],70:[2,73],71:[2,73],72:[2,73],74:[2,73],76:[2,73],77:[2,73],81:[2,73],83:[2,73],88:[2,73],89:[2,73],90:[2,73],95:[2,73],97:[2,73],106:[2,73],108:[2,73],109:[2,73],110:[2,73],114:[2,73],122:[2,73],130:[2,73],133:[2,73],134:[2,73],137:[2,73],138:[2,73],139:[2,73],140:[2,73],141:[2,73],142:[2,73],143:[2,73],144:[2,73],145:[2,73],146:[2,73]},{89:[2,115]},{27:198,30:197,31:[1,77],87:[1,47]},{30:199,31:[1,77]},{1:[2,89],6:[2,89],28:[2,89],29:[2,89],30:200,31:[1,77],43:[2,89],52:[2,89],57:[2,89],60:[2,89],69:[2,89],70:[2,89],71:[2,89],72:[2,89],74:[2,89],76:[2,89],77:[2,89],81:[2,89],83:[2,89],88:[2,89],89:[2,89],90:[2,89],95:[2,89],97:[2,89],106:[2,89],108:[2,89],109:[2,89],110:[2,89],114:[2,89],122:[2,89],130:[2,89],133:[2,89],134:[2,89],137:[2,89],138:[2,89],139:[2,89],140:[2,89],141:[2,89],142:[2,89],143:[2,89],144:[2,89],145:[2,89],146:[2,89]},{30:201,31:[1,77]},{1:[2,90],6:[2,90],28:[2,90],29:[2,90],43:[2,90],52:[2,90],57:[2,90],60:[2,90],69:[2,90],70:[2,90],71:[2,90],72:[2,90],74:[2,90],76:[2,90],77:[2,90],81:[2,90],83:[2,90],88:[2,90],89:[2,90],90:[2,90],95:[2,90],97:[2,90],106:[2,90],108:[2,90],109:[2,90],110:[2,90],114:[2,90],122:[2,90],130:[2,90],133:[2,90],134:[2,90],137:[2,90],138:[2,90],139:[2,90],140:[2,90],141:[2,90],142:[2,90],143:[2,90],144:[2,90],145:[2,90],146:[2,90]},{7:203,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],60:[1,207],61:51,62:52,64:38,66:25,67:26,68:27,75:202,78:204,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],96:205,97:[1,206],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{73:208,74:[1,102],77:[1,103]},{85:209,89:[1,108]},{1:[2,74],6:[2,74],28:[2,74],29:[2,74],43:[2,74],52:[2,74],57:[2,74],60:[2,74],69:[2,74],70:[2,74],71:[2,74],72:[2,74],74:[2,74],76:[2,74],77:[2,74],81:[2,74],83:[2,74],88:[2,74],89:[2,74],90:[2,74],95:[2,74],97:[2,74],106:[2,74],108:[2,74],109:[2,74],110:[2,74],114:[2,74],122:[2,74],130:[2,74],133:[2,74],134:[2,74],137:[2,74],138:[2,74],139:[2,74],140:[2,74],141:[2,74],142:[2,74],143:[2,74],144:[2,74],145:[2,74],146:[2,74]},{6:[1,211],7:210,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,212],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,112],6:[2,112],28:[2,112],29:[2,112],52:[2,112],57:[2,112],60:[2,112],69:[2,112],70:[2,112],71:[2,112],72:[2,112],74:[2,112],76:[2,112],77:[2,112],81:[2,112],88:[2,112],89:[2,112],90:[2,112],95:[2,112],97:[2,112],106:[2,112],108:[2,112],109:[2,112],110:[2,112],114:[2,112],122:[2,112],130:[2,112],133:[2,112],134:[2,112],139:[2,112],140:[2,112],141:[2,112],142:[2,112],143:[2,112],144:[2,112],145:[2,112]},{7:215,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,158],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],60:[1,160],61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],90:[1,213],91:214,92:[1,62],93:[1,63],94:[1,61],98:157,100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{6:[2,56],28:[2,56],52:[1,216],56:218,57:[1,217]},{6:[2,59],28:[2,59],29:[2,59],52:[2,59],57:[2,59]},{6:[2,63],28:[2,63],29:[2,63],43:[1,220],52:[2,63],57:[2,63],60:[1,219]},{6:[2,66],28:[2,66],29:[2,66],52:[2,66],57:[2,66]},{6:[2,67],28:[2,67],29:[2,67],43:[2,67],52:[2,67],57:[2,67],60:[2,67]},{6:[2,68],28:[2,68],29:[2,68],43:[2,68],52:[2,68],57:[2,68],60:[2,68]},{6:[2,69],28:[2,69],29:[2,69],43:[2,69],52:[2,69],57:[2,69],60:[2,69]},{6:[2,70],28:[2,70],29:[2,70],43:[2,70],52:[2,70],57:[2,70],60:[2,70]},{30:161,31:[1,77]},{7:215,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,158],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],60:[1,160],61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],91:156,92:[1,62],93:[1,63],94:[1,61],95:[1,155],98:157,100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,53],6:[2,53],28:[2,53],29:[2,53],52:[2,53],57:[2,53],60:[2,53],76:[2,53],81:[2,53],90:[2,53],95:[2,53],97:[2,53],106:[2,53],108:[2,53],109:[2,53],110:[2,53],114:[2,53],122:[2,53],130:[2,53],133:[2,53],134:[2,53],139:[2,53],140:[2,53],141:[2,53],142:[2,53],143:[2,53],144:[2,53],145:[2,53]},{4:222,5:3,7:4,8:5,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,29:[1,221],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,194],6:[2,194],28:[2,194],29:[2,194],52:[2,194],57:[2,194],60:[2,194],76:[2,194],81:[2,194],90:[2,194],95:[2,194],97:[2,194],106:[2,194],107:89,108:[2,194],109:[2,194],110:[2,194],113:90,114:[2,194],115:73,122:[2,194],130:[2,194],133:[2,194],134:[2,194],139:[1,79],140:[2,194],141:[2,194],142:[2,194],143:[2,194],144:[2,194],145:[2,194]},{107:92,108:[1,69],110:[1,70],113:93,114:[1,72],115:73,130:[1,91]},{1:[2,195],6:[2,195],28:[2,195],29:[2,195],52:[2,195],57:[2,195],60:[2,195],76:[2,195],81:[2,195],90:[2,195],95:[2,195],97:[2,195],106:[2,195],107:89,108:[2,195],109:[2,195],110:[2,195],113:90,114:[2,195],115:73,122:[2,195],130:[2,195],133:[2,195],134:[2,195],139:[1,79],140:[2,195],141:[1,83],142:[2,195],143:[2,195],144:[2,195],145:[2,195]},{1:[2,196],6:[2,196],28:[2,196],29:[2,196],52:[2,196],57:[2,196],60:[2,196],76:[2,196],81:[2,196],90:[2,196],95:[2,196],97:[2,196],106:[2,196],107:89,108:[2,196],109:[2,196],110:[2,196],113:90,114:[2,196],115:73,122:[2,196],130:[2,196],133:[2,196],134:[2,196],139:[1,79],140:[2,196],141:[1,83],142:[2,196],143:[2,196],144:[2,196],145:[2,196]},{1:[2,197],6:[2,197],28:[2,197],29:[2,197],52:[2,197],57:[2,197],60:[2,197],76:[2,197],81:[2,197],90:[2,197],95:[2,197],97:[2,197],106:[2,197],107:89,108:[2,197],109:[2,197],110:[2,197],113:90,114:[2,197],115:73,122:[2,197],130:[2,197],133:[2,197],134:[2,197],139:[1,79],140:[2,197],141:[1,83],142:[2,197],143:[2,197],144:[2,197],145:[2,197]},{1:[2,198],6:[2,198],28:[2,198],29:[2,198],52:[2,198],57:[2,198],60:[2,198],76:[2,198],81:[2,198],90:[2,198],95:[2,198],97:[2,198],106:[2,198],107:92,108:[2,198],109:[2,198],110:[2,198],113:93,114:[2,198],115:73,122:[2,198],130:[2,198],133:[2,198],134:[2,198],139:[2,198],140:[2,198],141:[2,198],142:[2,198],143:[2,198],144:[2,198],145:[2,198]},{1:[2,199],6:[2,199],28:[2,199],29:[2,199],52:[2,199],57:[2,199],60:[2,199],76:[2,199],81:[2,199],90:[2,199],95:[2,199],97:[2,199],106:[2,199],107:89,108:[2,199],109:[2,199],110:[2,199],113:90,114:[2,199],115:73,122:[2,199],130:[2,199],133:[2,199],134:[2,199],139:[1,79],140:[2,199],141:[2,199],142:[2,199],143:[2,199],144:[2,199],145:[2,199]},{7:223,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,201],6:[2,201],28:[2,201],29:[2,201],52:[2,201],57:[2,201],60:[2,201],69:[2,76],70:[2,76],71:[2,76],72:[2,76],74:[2,76],76:[2,201],77:[2,76],81:[2,201],88:[2,76],89:[2,76],90:[2,201],95:[2,201],97:[2,201],106:[2,201],108:[2,201],109:[2,201],110:[2,201],114:[2,201],122:[2,201],130:[2,201],133:[2,201],134:[2,201],139:[2,201],140:[2,201],141:[2,201],142:[2,201],143:[2,201],144:[2,201],145:[2,201]},{65:95,69:[1,97],70:[1,98],71:[1,99],72:[1,100],73:101,74:[1,102],77:[1,103],84:94,88:[1,96],89:[2,114]},{65:105,69:[1,97],70:[1,98],71:[1,99],72:[1,100],73:101,74:[1,102],77:[1,103],84:104,88:[1,96],89:[2,114]},{69:[2,79],70:[2,79],71:[2,79],72:[2,79],74:[2,79],77:[2,79],88:[2,79],89:[2,79]},{1:[2,202],6:[2,202],28:[2,202],29:[2,202],52:[2,202],57:[2,202],60:[2,202],69:[2,76],70:[2,76],71:[2,76],72:[2,76],74:[2,76],76:[2,202],77:[2,76],81:[2,202],88:[2,76],89:[2,76],90:[2,202],95:[2,202],97:[2,202],106:[2,202],108:[2,202],109:[2,202],110:[2,202],114:[2,202],122:[2,202],130:[2,202],133:[2,202],134:[2,202],139:[2,202],140:[2,202],141:[2,202],142:[2,202],143:[2,202],144:[2,202],145:[2,202]},{1:[2,203],6:[2,203],28:[2,203],29:[2,203],52:[2,203],57:[2,203],60:[2,203],76:[2,203],81:[2,203],90:[2,203],95:[2,203],97:[2,203],106:[2,203],108:[2,203],109:[2,203],110:[2,203],114:[2,203],122:[2,203],130:[2,203],133:[2,203],134:[2,203],139:[2,203],140:[2,203],141:[2,203],142:[2,203],143:[2,203],144:[2,203],145:[2,203]},{1:[2,204],6:[2,204],28:[2,204],29:[2,204],52:[2,204],57:[2,204],60:[2,204],76:[2,204],81:[2,204],90:[2,204],95:[2,204],97:[2,204],106:[2,204],108:[2,204],109:[2,204],110:[2,204],114:[2,204],122:[2,204],130:[2,204],133:[2,204],134:[2,204],139:[2,204],140:[2,204],141:[2,204],142:[2,204],143:[2,204],144:[2,204],145:[2,204]},{6:[1,226],7:224,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,225],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:227,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{14:228,28:[1,120],129:[1,229]},{1:[2,140],6:[2,140],28:[2,140],29:[2,140],52:[2,140],57:[2,140],60:[2,140],76:[2,140],81:[2,140],90:[2,140],95:[2,140],97:[2,140],101:230,102:[1,231],103:[1,232],106:[2,140],108:[2,140],109:[2,140],110:[2,140],114:[2,140],122:[2,140],130:[2,140],133:[2,140],134:[2,140],139:[2,140],140:[2,140],141:[2,140],142:[2,140],143:[2,140],144:[2,140],145:[2,140]},{1:[2,154],6:[2,154],28:[2,154],29:[2,154],52:[2,154],57:[2,154],60:[2,154],76:[2,154],81:[2,154],90:[2,154],95:[2,154],97:[2,154],106:[2,154],108:[2,154],109:[2,154],110:[2,154],114:[2,154],122:[2,154],130:[2,154],133:[2,154],134:[2,154],139:[2,154],140:[2,154],141:[2,154],142:[2,154],143:[2,154],144:[2,154],145:[2,154]},{1:[2,162],6:[2,162],28:[2,162],29:[2,162],52:[2,162],57:[2,162],60:[2,162],76:[2,162],81:[2,162],90:[2,162],95:[2,162],97:[2,162],106:[2,162],108:[2,162],109:[2,162],110:[2,162],114:[2,162],122:[2,162],130:[2,162],133:[2,162],134:[2,162],139:[2,162],140:[2,162],141:[2,162],142:[2,162],143:[2,162],144:[2,162],145:[2,162]},{28:[1,233],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{124:234,126:235,127:[1,236]},{1:[2,102],6:[2,102],28:[2,102],29:[2,102],52:[2,102],57:[2,102],60:[2,102],76:[2,102],81:[2,102],90:[2,102],95:[2,102],97:[2,102],106:[2,102],108:[2,102],109:[2,102],110:[2,102],114:[2,102],122:[2,102],130:[2,102],133:[2,102],134:[2,102],139:[2,102],140:[2,102],141:[2,102],142:[2,102],143:[2,102],144:[2,102],145:[2,102]},{7:237,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,105],6:[2,105],14:238,28:[1,120],29:[2,105],52:[2,105],57:[2,105],60:[2,105],69:[2,76],70:[2,76],71:[2,76],72:[2,76],74:[2,76],76:[2,105],77:[2,76],81:[2,105],83:[1,239],88:[2,76],89:[2,76],90:[2,105],95:[2,105],97:[2,105],106:[2,105],108:[2,105],109:[2,105],110:[2,105],114:[2,105],122:[2,105],130:[2,105],133:[2,105],134:[2,105],139:[2,105],140:[2,105],141:[2,105],142:[2,105],143:[2,105],144:[2,105],145:[2,105]},{1:[2,147],6:[2,147],28:[2,147],29:[2,147],52:[2,147],57:[2,147],60:[2,147],76:[2,147],81:[2,147],90:[2,147],95:[2,147],97:[2,147],106:[2,147],107:89,108:[2,147],109:[2,147],110:[2,147],113:90,114:[2,147],115:73,122:[2,147],130:[2,147],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,113],6:[2,113],28:[2,113],29:[2,113],43:[2,113],52:[2,113],57:[2,113],60:[2,113],69:[2,113],70:[2,113],71:[2,113],72:[2,113],74:[2,113],76:[2,113],77:[2,113],81:[2,113],83:[2,113],88:[2,113],89:[2,113],90:[2,113],95:[2,113],97:[2,113],106:[2,113],108:[2,113],109:[2,113],110:[2,113],114:[2,113],122:[2,113],130:[2,113],133:[2,113],134:[2,113],137:[2,113],138:[2,113],139:[2,113],140:[2,113],141:[2,113],142:[2,113],143:[2,113],144:[2,113],145:[2,113],146:[2,113]},{1:[2,49],6:[2,49],28:[2,49],29:[2,49],52:[2,49],57:[2,49],60:[2,49],76:[2,49],81:[2,49],90:[2,49],95:[2,49],97:[2,49],106:[2,49],107:89,108:[2,49],109:[2,49],110:[2,49],113:90,114:[2,49],115:73,122:[2,49],130:[2,49],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,12],6:[2,12],28:[2,12],29:[2,12],52:[2,12],57:[2,12],60:[2,12],76:[2,12],81:[2,12],90:[2,12],95:[2,12],97:[2,12],106:[2,12],108:[2,12],109:[2,12],110:[2,12],114:[2,12],122:[2,12],130:[2,12],133:[2,12],134:[2,12],139:[2,12],140:[2,12],141:[2,12],142:[2,12],143:[2,12],144:[2,12],145:[2,12]},{1:[2,13],6:[2,13],28:[2,13],29:[2,13],52:[2,13],57:[2,13],60:[2,13],76:[2,13],81:[2,13],90:[2,13],95:[2,13],97:[2,13],106:[2,13],107:89,108:[1,69],109:[2,13],110:[1,70],113:90,114:[1,72],115:73,122:[2,13],130:[2,13],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{6:[1,78],106:[1,240]},{4:241,5:3,7:4,8:5,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{6:[2,135],28:[2,135],57:[2,135],60:[1,243],95:[2,135],96:242,97:[1,206],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,121],6:[2,121],28:[2,121],29:[2,121],43:[2,121],52:[2,121],57:[2,121],60:[2,121],69:[2,121],70:[2,121],71:[2,121],72:[2,121],74:[2,121],76:[2,121],77:[2,121],81:[2,121],88:[2,121],89:[2,121],90:[2,121],95:[2,121],97:[2,121],106:[2,121],108:[2,121],109:[2,121],110:[2,121],114:[2,121],120:[2,121],121:[2,121],122:[2,121],130:[2,121],133:[2,121],134:[2,121],139:[2,121],140:[2,121],141:[2,121],142:[2,121],143:[2,121],144:[2,121],145:[2,121]},{6:[2,56],28:[2,56],56:244,57:[1,245],95:[2,56]},{6:[2,130],28:[2,130],29:[2,130],57:[2,130],90:[2,130],95:[2,130]},{7:215,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,158],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],60:[1,160],61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],91:246,92:[1,62],93:[1,63],94:[1,61],98:157,100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{6:[2,136],28:[2,136],29:[2,136],57:[2,136],90:[2,136],95:[2,136]},{6:[2,137],28:[2,137],29:[2,137],57:[2,137],90:[2,137],95:[2,137]},{1:[2,120],6:[2,120],28:[2,120],29:[2,120],43:[2,120],46:[2,120],52:[2,120],57:[2,120],60:[2,120],69:[2,120],70:[2,120],71:[2,120],72:[2,120],74:[2,120],76:[2,120],77:[2,120],81:[2,120],83:[2,120],88:[2,120],89:[2,120],90:[2,120],95:[2,120],97:[2,120],106:[2,120],108:[2,120],109:[2,120],110:[2,120],114:[2,120],120:[2,120],121:[2,120],122:[2,120],130:[2,120],133:[2,120],134:[2,120],137:[2,120],138:[2,120],139:[2,120],140:[2,120],141:[2,120],142:[2,120],143:[2,120],144:[2,120],145:[2,120],146:[2,120]},{14:247,28:[1,120],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,150],6:[2,150],28:[2,150],29:[2,150],52:[2,150],57:[2,150],60:[2,150],76:[2,150],81:[2,150],90:[2,150],95:[2,150],97:[2,150],106:[2,150],107:89,108:[1,69],109:[1,248],110:[1,70],113:90,114:[1,72],115:73,122:[2,150],130:[2,150],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,152],6:[2,152],28:[2,152],29:[2,152],52:[2,152],57:[2,152],60:[2,152],76:[2,152],81:[2,152],90:[2,152],95:[2,152],97:[2,152],106:[2,152],107:89,108:[1,69],109:[1,249],110:[1,70],113:90,114:[1,72],115:73,122:[2,152],130:[2,152],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,158],6:[2,158],28:[2,158],29:[2,158],52:[2,158],57:[2,158],60:[2,158],76:[2,158],81:[2,158],90:[2,158],95:[2,158],97:[2,158],106:[2,158],108:[2,158],109:[2,158],110:[2,158],114:[2,158],122:[2,158],130:[2,158],133:[2,158],134:[2,158],139:[2,158],140:[2,158],141:[2,158],142:[2,158],143:[2,158],144:[2,158],145:[2,158]},{1:[2,159],6:[2,159],28:[2,159],29:[2,159],52:[2,159],57:[2,159],60:[2,159],76:[2,159],81:[2,159],90:[2,159],95:[2,159],97:[2,159],106:[2,159],107:89,108:[1,69],109:[2,159],110:[1,70],113:90,114:[1,72],115:73,122:[2,159],130:[2,159],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,163],6:[2,163],28:[2,163],29:[2,163],52:[2,163],57:[2,163],60:[2,163],76:[2,163],81:[2,163],90:[2,163],95:[2,163],97:[2,163],106:[2,163],108:[2,163],109:[2,163],110:[2,163],114:[2,163],122:[2,163],130:[2,163],133:[2,163],134:[2,163],139:[2,163],140:[2,163],141:[2,163],142:[2,163],143:[2,163],144:[2,163],145:[2,163]},{120:[2,165],121:[2,165]},{30:171,31:[1,77],47:172,61:173,62:174,79:[1,74],93:[1,117],94:[1,118],117:250,119:170},{57:[1,251],120:[2,171],121:[2,171]},{57:[2,167],120:[2,167],121:[2,167]},{57:[2,168],120:[2,168],121:[2,168]},{57:[2,169],120:[2,169],121:[2,169]},{57:[2,170],120:[2,170],121:[2,170]},{1:[2,164],6:[2,164],28:[2,164],29:[2,164],52:[2,164],57:[2,164],60:[2,164],76:[2,164],81:[2,164],90:[2,164],95:[2,164],97:[2,164],106:[2,164],108:[2,164],109:[2,164],110:[2,164],114:[2,164],122:[2,164],130:[2,164],133:[2,164],134:[2,164],139:[2,164],140:[2,164],141:[2,164],142:[2,164],143:[2,164],144:[2,164],145:[2,164]},{7:252,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:253,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{6:[2,56],28:[2,56],56:254,57:[1,255],81:[2,56]},{6:[2,97],28:[2,97],29:[2,97],57:[2,97],81:[2,97]},{6:[2,42],28:[2,42],29:[2,42],46:[1,256],57:[2,42],81:[2,42]},{6:[2,45],28:[2,45],29:[2,45],57:[2,45],81:[2,45]},{6:[2,46],28:[2,46],29:[2,46],46:[2,46],57:[2,46],81:[2,46]},{6:[2,47],28:[2,47],29:[2,47],46:[2,47],57:[2,47],81:[2,47]},{6:[2,48],28:[2,48],29:[2,48],46:[2,48],57:[2,48],81:[2,48]},{1:[2,4],6:[2,4],29:[2,4],106:[2,4]},{1:[2,206],6:[2,206],28:[2,206],29:[2,206],52:[2,206],57:[2,206],60:[2,206],76:[2,206],81:[2,206],90:[2,206],95:[2,206],97:[2,206],106:[2,206],107:89,108:[2,206],109:[2,206],110:[2,206],113:90,114:[2,206],115:73,122:[2,206],130:[2,206],133:[2,206],134:[2,206],139:[1,79],140:[1,82],141:[1,83],142:[2,206],143:[2,206],144:[2,206],145:[2,206]},{1:[2,207],6:[2,207],28:[2,207],29:[2,207],52:[2,207],57:[2,207],60:[2,207],76:[2,207],81:[2,207],90:[2,207],95:[2,207],97:[2,207],106:[2,207],107:89,108:[2,207],109:[2,207],110:[2,207],113:90,114:[2,207],115:73,122:[2,207],130:[2,207],133:[2,207],134:[2,207],139:[1,79],140:[1,82],141:[1,83],142:[2,207],143:[2,207],144:[2,207],145:[2,207]},{1:[2,208],6:[2,208],28:[2,208],29:[2,208],52:[2,208],57:[2,208],60:[2,208],76:[2,208],81:[2,208],90:[2,208],95:[2,208],97:[2,208],106:[2,208],107:89,108:[2,208],109:[2,208],110:[2,208],113:90,114:[2,208],115:73,122:[2,208],130:[2,208],133:[2,208],134:[2,208],139:[1,79],140:[2,208],141:[1,83],142:[2,208],143:[2,208],144:[2,208],145:[2,208]},{1:[2,209],6:[2,209],28:[2,209],29:[2,209],52:[2,209],57:[2,209],60:[2,209],76:[2,209],81:[2,209],90:[2,209],95:[2,209],97:[2,209],106:[2,209],107:89,108:[2,209],109:[2,209],110:[2,209],113:90,114:[2,209],115:73,122:[2,209],130:[2,209],133:[2,209],134:[2,209],139:[1,79],140:[2,209],141:[1,83],142:[2,209],143:[2,209],144:[2,209],145:[2,209]},{1:[2,210],6:[2,210],28:[2,210],29:[2,210],52:[2,210],57:[2,210],60:[2,210],76:[2,210],81:[2,210],90:[2,210],95:[2,210],97:[2,210],106:[2,210],107:89,108:[2,210],109:[2,210],110:[2,210],113:90,114:[2,210],115:73,122:[2,210],130:[2,210],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[2,210],143:[2,210],144:[2,210],145:[2,210]},{1:[2,211],6:[2,211],28:[2,211],29:[2,211],52:[2,211],57:[2,211],60:[2,211],76:[2,211],81:[2,211],90:[2,211],95:[2,211],97:[2,211],106:[2,211],107:89,108:[2,211],109:[2,211],110:[2,211],113:90,114:[2,211],115:73,122:[2,211],130:[2,211],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[2,211],144:[2,211],145:[1,87]},{1:[2,212],6:[2,212],28:[2,212],29:[2,212],52:[2,212],57:[2,212],60:[2,212],76:[2,212],81:[2,212],90:[2,212],95:[2,212],97:[2,212],106:[2,212],107:89,108:[2,212],109:[2,212],110:[2,212],113:90,114:[2,212],115:73,122:[2,212],130:[2,212],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[2,212],145:[1,87]},{1:[2,213],6:[2,213],28:[2,213],29:[2,213],52:[2,213],57:[2,213],60:[2,213],76:[2,213],81:[2,213],90:[2,213],95:[2,213],97:[2,213],106:[2,213],107:89,108:[2,213],109:[2,213],110:[2,213],113:90,114:[2,213],115:73,122:[2,213],130:[2,213],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[2,213],144:[2,213],145:[2,213]},{1:[2,193],6:[2,193],28:[2,193],29:[2,193],52:[2,193],57:[2,193],60:[2,193],76:[2,193],81:[2,193],90:[2,193],95:[2,193],97:[2,193],106:[2,193],107:89,108:[1,69],109:[2,193],110:[1,70],113:90,114:[1,72],115:73,122:[2,193],130:[2,193],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,192],6:[2,192],28:[2,192],29:[2,192],52:[2,192],57:[2,192],60:[2,192],76:[2,192],81:[2,192],90:[2,192],95:[2,192],97:[2,192],106:[2,192],107:89,108:[1,69],109:[2,192],110:[1,70],113:90,114:[1,72],115:73,122:[2,192],130:[2,192],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,109],6:[2,109],28:[2,109],29:[2,109],52:[2,109],57:[2,109],60:[2,109],69:[2,109],70:[2,109],71:[2,109],72:[2,109],74:[2,109],76:[2,109],77:[2,109],81:[2,109],88:[2,109],89:[2,109],90:[2,109],95:[2,109],97:[2,109],106:[2,109],108:[2,109],109:[2,109],110:[2,109],114:[2,109],122:[2,109],130:[2,109],133:[2,109],134:[2,109],139:[2,109],140:[2,109],141:[2,109],142:[2,109],143:[2,109],144:[2,109],145:[2,109]},{1:[2,84],6:[2,84],28:[2,84],29:[2,84],43:[2,84],52:[2,84],57:[2,84],60:[2,84],69:[2,84],70:[2,84],71:[2,84],72:[2,84],74:[2,84],76:[2,84],77:[2,84],81:[2,84],83:[2,84],88:[2,84],89:[2,84],90:[2,84],95:[2,84],97:[2,84],106:[2,84],108:[2,84],109:[2,84],110:[2,84],114:[2,84],122:[2,84],130:[2,84],133:[2,84],134:[2,84],137:[2,84],138:[2,84],139:[2,84],140:[2,84],141:[2,84],142:[2,84],143:[2,84],144:[2,84],145:[2,84],146:[2,84]},{1:[2,85],6:[2,85],28:[2,85],29:[2,85],43:[2,85],52:[2,85],57:[2,85],60:[2,85],69:[2,85],70:[2,85],71:[2,85],72:[2,85],74:[2,85],76:[2,85],77:[2,85],81:[2,85],83:[2,85],88:[2,85],89:[2,85],90:[2,85],95:[2,85],97:[2,85],106:[2,85],108:[2,85],109:[2,85],110:[2,85],114:[2,85],122:[2,85],130:[2,85],133:[2,85],134:[2,85],137:[2,85],138:[2,85],139:[2,85],140:[2,85],141:[2,85],142:[2,85],143:[2,85],144:[2,85],145:[2,85],146:[2,85]},{1:[2,86],6:[2,86],28:[2,86],29:[2,86],43:[2,86],52:[2,86],57:[2,86],60:[2,86],69:[2,86],70:[2,86],71:[2,86],72:[2,86],74:[2,86],76:[2,86],77:[2,86],81:[2,86],83:[2,86],88:[2,86],89:[2,86],90:[2,86],95:[2,86],97:[2,86],106:[2,86],108:[2,86],109:[2,86],110:[2,86],114:[2,86],122:[2,86],130:[2,86],133:[2,86],134:[2,86],137:[2,86],138:[2,86],139:[2,86],140:[2,86],141:[2,86],142:[2,86],143:[2,86],144:[2,86],145:[2,86],146:[2,86]},{1:[2,87],6:[2,87],28:[2,87],29:[2,87],43:[2,87],52:[2,87],57:[2,87],60:[2,87],69:[2,87],70:[2,87],71:[2,87],72:[2,87],74:[2,87],76:[2,87],77:[2,87],81:[2,87],83:[2,87],88:[2,87],89:[2,87],90:[2,87],95:[2,87],97:[2,87],106:[2,87],108:[2,87],109:[2,87],110:[2,87],114:[2,87],122:[2,87],130:[2,87],133:[2,87],134:[2,87],137:[2,87],138:[2,87],139:[2,87],140:[2,87],141:[2,87],142:[2,87],143:[2,87],144:[2,87],145:[2,87],146:[2,87]},{1:[2,88],6:[2,88],28:[2,88],29:[2,88],43:[2,88],52:[2,88],57:[2,88],60:[2,88],69:[2,88],70:[2,88],71:[2,88],72:[2,88],74:[2,88],76:[2,88],77:[2,88],81:[2,88],83:[2,88],88:[2,88],89:[2,88],90:[2,88],95:[2,88],97:[2,88],106:[2,88],108:[2,88],109:[2,88],110:[2,88],114:[2,88],122:[2,88],130:[2,88],133:[2,88],134:[2,88],137:[2,88],138:[2,88],139:[2,88],140:[2,88],141:[2,88],142:[2,88],143:[2,88],144:[2,88],145:[2,88],146:[2,88]},{76:[1,257]},{60:[1,207],76:[2,93],96:258,97:[1,206],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{76:[2,94]},{7:259,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,76:[2,129],79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{11:[2,123],13:[2,123],31:[2,123],33:[2,123],34:[2,123],36:[2,123],37:[2,123],38:[2,123],39:[2,123],40:[2,123],41:[2,123],48:[2,123],49:[2,123],50:[2,123],54:[2,123],55:[2,123],76:[2,123],79:[2,123],82:[2,123],86:[2,123],87:[2,123],92:[2,123],93:[2,123],94:[2,123],100:[2,123],104:[2,123],105:[2,123],108:[2,123],110:[2,123],112:[2,123],114:[2,123],123:[2,123],129:[2,123],131:[2,123],132:[2,123],133:[2,123],134:[2,123],135:[2,123],137:[2,123],138:[2,123]},{11:[2,124],13:[2,124],31:[2,124],33:[2,124],34:[2,124],36:[2,124],37:[2,124],38:[2,124],39:[2,124],40:[2,124],41:[2,124],48:[2,124],49:[2,124],50:[2,124],54:[2,124],55:[2,124],76:[2,124],79:[2,124],82:[2,124],86:[2,124],87:[2,124],92:[2,124],93:[2,124],94:[2,124],100:[2,124],104:[2,124],105:[2,124],108:[2,124],110:[2,124],112:[2,124],114:[2,124],123:[2,124],129:[2,124],131:[2,124],132:[2,124],133:[2,124],134:[2,124],135:[2,124],137:[2,124],138:[2,124]},{1:[2,92],6:[2,92],28:[2,92],29:[2,92],43:[2,92],52:[2,92],57:[2,92],60:[2,92],69:[2,92],70:[2,92],71:[2,92],72:[2,92],74:[2,92],76:[2,92],77:[2,92],81:[2,92],83:[2,92],88:[2,92],89:[2,92],90:[2,92],95:[2,92],97:[2,92],106:[2,92],108:[2,92],109:[2,92],110:[2,92],114:[2,92],122:[2,92],130:[2,92],133:[2,92],134:[2,92],137:[2,92],138:[2,92],139:[2,92],140:[2,92],141:[2,92],142:[2,92],143:[2,92],144:[2,92],145:[2,92],146:[2,92]},{1:[2,110],6:[2,110],28:[2,110],29:[2,110],52:[2,110],57:[2,110],60:[2,110],69:[2,110],70:[2,110],71:[2,110],72:[2,110],74:[2,110],76:[2,110],77:[2,110],81:[2,110],88:[2,110],89:[2,110],90:[2,110],95:[2,110],97:[2,110],106:[2,110],108:[2,110],109:[2,110],110:[2,110],114:[2,110],122:[2,110],130:[2,110],133:[2,110],134:[2,110],139:[2,110],140:[2,110],141:[2,110],142:[2,110],143:[2,110],144:[2,110],145:[2,110]},{1:[2,39],6:[2,39],28:[2,39],29:[2,39],52:[2,39],57:[2,39],60:[2,39],76:[2,39],81:[2,39],90:[2,39],95:[2,39],97:[2,39],106:[2,39],107:89,108:[2,39],109:[2,39],110:[2,39],113:90,114:[2,39],115:73,122:[2,39],130:[2,39],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{7:260,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:261,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,116],6:[2,116],28:[2,116],29:[2,116],43:[2,116],52:[2,116],57:[2,116],60:[2,116],69:[2,116],70:[2,116],71:[2,116],72:[2,116],74:[2,116],76:[2,116],77:[2,116],81:[2,116],83:[2,116],88:[2,116],89:[2,116],90:[2,116],95:[2,116],97:[2,116],106:[2,116],108:[2,116],109:[2,116],110:[2,116],114:[2,116],122:[2,116],130:[2,116],133:[2,116],134:[2,116],137:[2,116],138:[2,116],139:[2,116],140:[2,116],141:[2,116],142:[2,116],143:[2,116],144:[2,116],145:[2,116],146:[2,116]},{6:[2,56],28:[2,56],56:262,57:[1,245],90:[2,56]},{6:[2,135],28:[2,135],29:[2,135],57:[2,135],60:[1,263],90:[2,135],95:[2,135],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{53:264,54:[1,64],55:[1,65]},{6:[2,57],28:[2,57],29:[2,57],30:113,31:[1,77],47:114,58:265,59:111,60:[1,112],61:115,62:116,79:[1,74],93:[1,117],94:[1,118]},{6:[1,266],28:[1,267]},{6:[2,64],28:[2,64],29:[2,64],52:[2,64],57:[2,64]},{7:268,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,27],6:[2,27],28:[2,27],29:[2,27],52:[2,27],57:[2,27],60:[2,27],76:[2,27],81:[2,27],90:[2,27],95:[2,27],97:[2,27],102:[2,27],103:[2,27],106:[2,27],108:[2,27],109:[2,27],110:[2,27],114:[2,27],122:[2,27],125:[2,27],127:[2,27],130:[2,27],133:[2,27],134:[2,27],139:[2,27],140:[2,27],141:[2,27],142:[2,27],143:[2,27],144:[2,27],145:[2,27]},{6:[1,78],29:[1,269]},{1:[2,200],6:[2,200],28:[2,200],29:[2,200],52:[2,200],57:[2,200],60:[2,200],76:[2,200],81:[2,200],90:[2,200],95:[2,200],97:[2,200],106:[2,200],107:89,108:[2,200],109:[2,200],110:[2,200],113:90,114:[2,200],115:73,122:[2,200],130:[2,200],133:[2,200],134:[2,200],139:[1,79],140:[2,200],141:[2,200],142:[2,200],143:[2,200],144:[2,200],145:[2,200]},{1:[2,214],6:[2,214],28:[2,214],29:[2,214],52:[2,214],57:[2,214],60:[2,214],76:[2,214],81:[2,214],90:[2,214],95:[2,214],97:[2,214],106:[2,214],107:89,108:[2,214],109:[2,214],110:[2,214],113:90,114:[2,214],115:73,122:[2,214],130:[2,214],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{7:270,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:271,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,217],6:[2,217],28:[2,217],29:[2,217],52:[2,217],57:[2,217],60:[2,217],76:[2,217],81:[2,217],90:[2,217],95:[2,217],97:[2,217],106:[2,217],107:89,108:[2,217],109:[2,217],110:[2,217],113:90,114:[2,217],115:73,122:[2,217],130:[2,217],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,191],6:[2,191],28:[2,191],29:[2,191],52:[2,191],57:[2,191],60:[2,191],76:[2,191],81:[2,191],90:[2,191],95:[2,191],97:[2,191],106:[2,191],108:[2,191],109:[2,191],110:[2,191],114:[2,191],122:[2,191],130:[2,191],133:[2,191],134:[2,191],139:[2,191],140:[2,191],141:[2,191],142:[2,191],143:[2,191],144:[2,191],145:[2,191]},{7:272,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,141],6:[2,141],28:[2,141],29:[2,141],52:[2,141],57:[2,141],60:[2,141],76:[2,141],81:[2,141],90:[2,141],95:[2,141],97:[2,141],102:[1,273],106:[2,141],108:[2,141],109:[2,141],110:[2,141],114:[2,141],122:[2,141],130:[2,141],133:[2,141],134:[2,141],139:[2,141],140:[2,141],141:[2,141],142:[2,141],143:[2,141],144:[2,141],145:[2,141]},{14:274,28:[1,120]},{14:277,28:[1,120],30:275,31:[1,77],62:276,79:[1,74]},{124:278,126:235,127:[1,236]},{29:[1,279],125:[1,280],126:281,127:[1,236]},{29:[2,184],125:[2,184],127:[2,184]},{7:283,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],99:282,100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,103],6:[2,103],14:284,28:[1,120],29:[2,103],52:[2,103],57:[2,103],60:[2,103],76:[2,103],81:[2,103],90:[2,103],95:[2,103],97:[2,103],106:[2,103],107:89,108:[1,69],109:[2,103],110:[1,70],113:90,114:[1,72],115:73,122:[2,103],130:[2,103],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,106],6:[2,106],28:[2,106],29:[2,106],52:[2,106],57:[2,106],60:[2,106],76:[2,106],81:[2,106],90:[2,106],95:[2,106],97:[2,106],106:[2,106],108:[2,106],109:[2,106],110:[2,106],114:[2,106],122:[2,106],130:[2,106],133:[2,106],134:[2,106],139:[2,106],140:[2,106],141:[2,106],142:[2,106],143:[2,106],144:[2,106],145:[2,106]},{7:285,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,148],6:[2,148],28:[2,148],29:[2,148],52:[2,148],57:[2,148],60:[2,148],69:[2,148],70:[2,148],71:[2,148],72:[2,148],74:[2,148],76:[2,148],77:[2,148],81:[2,148],88:[2,148],89:[2,148],90:[2,148],95:[2,148],97:[2,148],106:[2,148],108:[2,148],109:[2,148],110:[2,148],114:[2,148],122:[2,148],130:[2,148],133:[2,148],134:[2,148],139:[2,148],140:[2,148],141:[2,148],142:[2,148],143:[2,148],144:[2,148],145:[2,148]},{6:[1,78],29:[1,286]},{7:287,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{6:[2,71],11:[2,124],13:[2,124],28:[2,71],31:[2,124],33:[2,124],34:[2,124],36:[2,124],37:[2,124],38:[2,124],39:[2,124],40:[2,124],41:[2,124],48:[2,124],49:[2,124],50:[2,124],54:[2,124],55:[2,124],57:[2,71],79:[2,124],82:[2,124],86:[2,124],87:[2,124],92:[2,124],93:[2,124],94:[2,124],95:[2,71],100:[2,124],104:[2,124],105:[2,124],108:[2,124],110:[2,124],112:[2,124],114:[2,124],123:[2,124],129:[2,124],131:[2,124],132:[2,124],133:[2,124],134:[2,124],135:[2,124],137:[2,124],138:[2,124]},{6:[1,289],28:[1,290],95:[1,288]},{6:[2,57],7:215,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[2,57],29:[2,57],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],60:[1,160],61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],90:[2,57],92:[1,62],93:[1,63],94:[1,61],95:[2,57],98:291,100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{6:[2,56],28:[2,56],29:[2,56],56:292,57:[1,245]},{1:[2,188],6:[2,188],28:[2,188],29:[2,188],52:[2,188],57:[2,188],60:[2,188],76:[2,188],81:[2,188],90:[2,188],95:[2,188],97:[2,188],106:[2,188],108:[2,188],109:[2,188],110:[2,188],114:[2,188],122:[2,188],125:[2,188],130:[2,188],133:[2,188],134:[2,188],139:[2,188],140:[2,188],141:[2,188],142:[2,188],143:[2,188],144:[2,188],145:[2,188]},{7:293,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:294,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{120:[2,166],121:[2,166]},{30:171,31:[1,77],47:172,61:173,62:174,79:[1,74],93:[1,117],94:[1,118],119:295},{1:[2,173],6:[2,173],28:[2,173],29:[2,173],52:[2,173],57:[2,173],60:[2,173],76:[2,173],81:[2,173],90:[2,173],95:[2,173],97:[2,173],106:[2,173],107:89,108:[2,173],109:[1,296],110:[2,173],113:90,114:[2,173],115:73,122:[1,297],130:[2,173],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,174],6:[2,174],28:[2,174],29:[2,174],52:[2,174],57:[2,174],60:[2,174],76:[2,174],81:[2,174],90:[2,174],95:[2,174],97:[2,174],106:[2,174],107:89,108:[2,174],109:[1,298],110:[2,174],113:90,114:[2,174],115:73,122:[2,174],130:[2,174],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{6:[1,300],28:[1,301],81:[1,299]},{6:[2,57],10:181,28:[2,57],29:[2,57],30:182,31:[1,77],32:183,33:[1,75],34:[1,76],44:302,45:180,47:184,49:[1,49],81:[2,57],93:[1,117]},{7:303,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,304],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,91],6:[2,91],28:[2,91],29:[2,91],43:[2,91],52:[2,91],57:[2,91],60:[2,91],69:[2,91],70:[2,91],71:[2,91],72:[2,91],74:[2,91],76:[2,91],77:[2,91],81:[2,91],83:[2,91],88:[2,91],89:[2,91],90:[2,91],95:[2,91],97:[2,91],106:[2,91],108:[2,91],109:[2,91],110:[2,91],114:[2,91],122:[2,91],130:[2,91],133:[2,91],134:[2,91],137:[2,91],138:[2,91],139:[2,91],140:[2,91],141:[2,91],142:[2,91],143:[2,91],144:[2,91],145:[2,91],146:[2,91]},{7:305,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,76:[2,127],79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{76:[2,128],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,40],6:[2,40],28:[2,40],29:[2,40],52:[2,40],57:[2,40],60:[2,40],76:[2,40],81:[2,40],90:[2,40],95:[2,40],97:[2,40],106:[2,40],107:89,108:[2,40],109:[2,40],110:[2,40],113:90,114:[2,40],115:73,122:[2,40],130:[2,40],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{29:[1,306],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{6:[1,289],28:[1,290],90:[1,307]},{6:[2,71],28:[2,71],29:[2,71],57:[2,71],90:[2,71],95:[2,71]},{14:308,28:[1,120]},{6:[2,60],28:[2,60],29:[2,60],52:[2,60],57:[2,60]},{30:113,31:[1,77],47:114,58:309,59:111,60:[1,112],61:115,62:116,79:[1,74],93:[1,117],94:[1,118]},{6:[2,58],28:[2,58],29:[2,58],30:113,31:[1,77],47:114,51:310,57:[2,58],58:110,59:111,60:[1,112],61:115,62:116,79:[1,74],93:[1,117],94:[1,118]},{6:[2,65],28:[2,65],29:[2,65],52:[2,65],57:[2,65],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,28],6:[2,28],28:[2,28],29:[2,28],52:[2,28],57:[2,28],60:[2,28],76:[2,28],81:[2,28],90:[2,28],95:[2,28],97:[2,28],102:[2,28],103:[2,28],106:[2,28],108:[2,28],109:[2,28],110:[2,28],114:[2,28],122:[2,28],125:[2,28],127:[2,28],130:[2,28],133:[2,28],134:[2,28],139:[2,28],140:[2,28],141:[2,28],142:[2,28],143:[2,28],144:[2,28],145:[2,28]},{29:[1,311],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,216],6:[2,216],28:[2,216],29:[2,216],52:[2,216],57:[2,216],60:[2,216],76:[2,216],81:[2,216],90:[2,216],95:[2,216],97:[2,216],106:[2,216],107:89,108:[2,216],109:[2,216],110:[2,216],113:90,114:[2,216],115:73,122:[2,216],130:[2,216],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{14:312,28:[1,120],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{14:313,28:[1,120]},{1:[2,142],6:[2,142],28:[2,142],29:[2,142],52:[2,142],57:[2,142],60:[2,142],76:[2,142],81:[2,142],90:[2,142],95:[2,142],97:[2,142],106:[2,142],108:[2,142],109:[2,142],110:[2,142],114:[2,142],122:[2,142],130:[2,142],133:[2,142],134:[2,142],139:[2,142],140:[2,142],141:[2,142],142:[2,142],143:[2,142],144:[2,142],145:[2,142]},{14:314,28:[1,120]},{14:315,28:[1,120]},{1:[2,146],6:[2,146],28:[2,146],29:[2,146],52:[2,146],57:[2,146],60:[2,146],76:[2,146],81:[2,146],90:[2,146],95:[2,146],97:[2,146],102:[2,146],106:[2,146],108:[2,146],109:[2,146],110:[2,146],114:[2,146],122:[2,146],130:[2,146],133:[2,146],134:[2,146],139:[2,146],140:[2,146],141:[2,146],142:[2,146],143:[2,146],144:[2,146],145:[2,146]},{29:[1,316],125:[1,317],126:281,127:[1,236]},{1:[2,182],6:[2,182],28:[2,182],29:[2,182],52:[2,182],57:[2,182],60:[2,182],76:[2,182],81:[2,182],90:[2,182],95:[2,182],97:[2,182],106:[2,182],108:[2,182],109:[2,182],110:[2,182],114:[2,182],122:[2,182],130:[2,182],133:[2,182],134:[2,182],139:[2,182],140:[2,182],141:[2,182],142:[2,182],143:[2,182],144:[2,182],145:[2,182]},{14:318,28:[1,120]},{29:[2,185],125:[2,185],127:[2,185]},{14:319,28:[1,120],57:[1,320]},{28:[2,138],57:[2,138],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,104],6:[2,104],28:[2,104],29:[2,104],52:[2,104],57:[2,104],60:[2,104],76:[2,104],81:[2,104],90:[2,104],95:[2,104],97:[2,104],106:[2,104],108:[2,104],109:[2,104],110:[2,104],114:[2,104],122:[2,104],130:[2,104],133:[2,104],134:[2,104],139:[2,104],140:[2,104],141:[2,104],142:[2,104],143:[2,104],144:[2,104],145:[2,104]},{1:[2,107],6:[2,107],14:321,28:[1,120],29:[2,107],52:[2,107],57:[2,107],60:[2,107],76:[2,107],81:[2,107],90:[2,107],95:[2,107],97:[2,107],106:[2,107],107:89,108:[1,69],109:[2,107],110:[1,70],113:90,114:[1,72],115:73,122:[2,107],130:[2,107],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{106:[1,322]},{95:[1,323],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,122],6:[2,122],28:[2,122],29:[2,122],43:[2,122],52:[2,122],57:[2,122],60:[2,122],69:[2,122],70:[2,122],71:[2,122],72:[2,122],74:[2,122],76:[2,122],77:[2,122],81:[2,122],88:[2,122],89:[2,122],90:[2,122],95:[2,122],97:[2,122],106:[2,122],108:[2,122],109:[2,122],110:[2,122],114:[2,122],120:[2,122],121:[2,122],122:[2,122],130:[2,122],133:[2,122],134:[2,122],139:[2,122],140:[2,122],141:[2,122],142:[2,122],143:[2,122],144:[2,122],145:[2,122]},{7:215,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],60:[1,160],61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],98:324,100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:215,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,28:[1,158],30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],60:[1,160],61:51,62:52,63:159,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],91:325,92:[1,62],93:[1,63],94:[1,61],98:157,100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{6:[2,131],28:[2,131],29:[2,131],57:[2,131],90:[2,131],95:[2,131]},{6:[1,289],28:[1,290],29:[1,326]},{1:[2,151],6:[2,151],28:[2,151],29:[2,151],52:[2,151],57:[2,151],60:[2,151],76:[2,151],81:[2,151],90:[2,151],95:[2,151],97:[2,151],106:[2,151],107:89,108:[1,69],109:[2,151],110:[1,70],113:90,114:[1,72],115:73,122:[2,151],130:[2,151],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,153],6:[2,153],28:[2,153],29:[2,153],52:[2,153],57:[2,153],60:[2,153],76:[2,153],81:[2,153],90:[2,153],95:[2,153],97:[2,153],106:[2,153],107:89,108:[1,69],109:[2,153],110:[1,70],113:90,114:[1,72],115:73,122:[2,153],130:[2,153],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{120:[2,172],121:[2,172]},{7:327,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:328,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:329,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,95],6:[2,95],28:[2,95],29:[2,95],43:[2,95],52:[2,95],57:[2,95],60:[2,95],69:[2,95],70:[2,95],71:[2,95],72:[2,95],74:[2,95],76:[2,95],77:[2,95],81:[2,95],88:[2,95],89:[2,95],90:[2,95],95:[2,95],97:[2,95],106:[2,95],108:[2,95],109:[2,95],110:[2,95],114:[2,95],120:[2,95],121:[2,95],122:[2,95],130:[2,95],133:[2,95],134:[2,95],139:[2,95],140:[2,95],141:[2,95],142:[2,95],143:[2,95],144:[2,95],145:[2,95]},{10:181,30:182,31:[1,77],32:183,33:[1,75],34:[1,76],44:330,45:180,47:184,49:[1,49],93:[1,117]},{6:[2,96],10:181,28:[2,96],29:[2,96],30:182,31:[1,77],32:183,33:[1,75],34:[1,76],44:179,45:180,47:184,49:[1,49],57:[2,96],80:331,93:[1,117]},{6:[2,98],28:[2,98],29:[2,98],57:[2,98],81:[2,98]},{6:[2,43],28:[2,43],29:[2,43],57:[2,43],81:[2,43],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{7:332,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{76:[2,126],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,41],6:[2,41],28:[2,41],29:[2,41],52:[2,41],57:[2,41],60:[2,41],76:[2,41],81:[2,41],90:[2,41],95:[2,41],97:[2,41],106:[2,41],108:[2,41],109:[2,41],110:[2,41],114:[2,41],122:[2,41],130:[2,41],133:[2,41],134:[2,41],139:[2,41],140:[2,41],141:[2,41],142:[2,41],143:[2,41],144:[2,41],145:[2,41]},{1:[2,117],6:[2,117],28:[2,117],29:[2,117],43:[2,117],52:[2,117],57:[2,117],60:[2,117],69:[2,117],70:[2,117],71:[2,117],72:[2,117],74:[2,117],76:[2,117],77:[2,117],81:[2,117],83:[2,117],88:[2,117],89:[2,117],90:[2,117],95:[2,117],97:[2,117],106:[2,117],108:[2,117],109:[2,117],110:[2,117],114:[2,117],122:[2,117],130:[2,117],133:[2,117],134:[2,117],137:[2,117],138:[2,117],139:[2,117],140:[2,117],141:[2,117],142:[2,117],143:[2,117],144:[2,117],145:[2,117],146:[2,117]},{1:[2,52],6:[2,52],28:[2,52],29:[2,52],52:[2,52],57:[2,52],60:[2,52],76:[2,52],81:[2,52],90:[2,52],95:[2,52],97:[2,52],106:[2,52],108:[2,52],109:[2,52],110:[2,52],114:[2,52],122:[2,52],130:[2,52],133:[2,52],134:[2,52],139:[2,52],140:[2,52],141:[2,52],142:[2,52],143:[2,52],144:[2,52],145:[2,52]},{6:[2,61],28:[2,61],29:[2,61],52:[2,61],57:[2,61]},{6:[2,56],28:[2,56],29:[2,56],56:333,57:[1,217]},{1:[2,215],6:[2,215],28:[2,215],29:[2,215],52:[2,215],57:[2,215],60:[2,215],76:[2,215],81:[2,215],90:[2,215],95:[2,215],97:[2,215],106:[2,215],108:[2,215],109:[2,215],110:[2,215],114:[2,215],122:[2,215],130:[2,215],133:[2,215],134:[2,215],139:[2,215],140:[2,215],141:[2,215],142:[2,215],143:[2,215],144:[2,215],145:[2,215]},{1:[2,189],6:[2,189],28:[2,189],29:[2,189],52:[2,189],57:[2,189],60:[2,189],76:[2,189],81:[2,189],90:[2,189],95:[2,189],97:[2,189],106:[2,189],108:[2,189],109:[2,189],110:[2,189],114:[2,189],122:[2,189],125:[2,189],130:[2,189],133:[2,189],134:[2,189],139:[2,189],140:[2,189],141:[2,189],142:[2,189],143:[2,189],144:[2,189],145:[2,189]},{1:[2,143],6:[2,143],28:[2,143],29:[2,143],52:[2,143],57:[2,143],60:[2,143],76:[2,143],81:[2,143],90:[2,143],95:[2,143],97:[2,143],106:[2,143],108:[2,143],109:[2,143],110:[2,143],114:[2,143],122:[2,143],130:[2,143],133:[2,143],134:[2,143],139:[2,143],140:[2,143],141:[2,143],142:[2,143],143:[2,143],144:[2,143],145:[2,143]},{1:[2,144],6:[2,144],28:[2,144],29:[2,144],52:[2,144],57:[2,144],60:[2,144],76:[2,144],81:[2,144],90:[2,144],95:[2,144],97:[2,144],102:[2,144],106:[2,144],108:[2,144],109:[2,144],110:[2,144],114:[2,144],122:[2,144],130:[2,144],133:[2,144],134:[2,144],139:[2,144],140:[2,144],141:[2,144],142:[2,144],143:[2,144],144:[2,144],145:[2,144]},{1:[2,145],6:[2,145],28:[2,145],29:[2,145],52:[2,145],57:[2,145],60:[2,145],76:[2,145],81:[2,145],90:[2,145],95:[2,145],97:[2,145],102:[2,145],106:[2,145],108:[2,145],109:[2,145],110:[2,145],114:[2,145],122:[2,145],130:[2,145],133:[2,145],134:[2,145],139:[2,145],140:[2,145],141:[2,145],142:[2,145],143:[2,145],144:[2,145],145:[2,145]},{1:[2,180],6:[2,180],28:[2,180],29:[2,180],52:[2,180],57:[2,180],60:[2,180],76:[2,180],81:[2,180],90:[2,180],95:[2,180],97:[2,180],106:[2,180],108:[2,180],109:[2,180],110:[2,180],114:[2,180],122:[2,180],130:[2,180],133:[2,180],134:[2,180],139:[2,180],140:[2,180],141:[2,180],142:[2,180],143:[2,180],144:[2,180],145:[2,180]},{14:334,28:[1,120]},{29:[1,335]},{6:[1,336],29:[2,186],125:[2,186],127:[2,186]},{7:337,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{1:[2,108],6:[2,108],28:[2,108],29:[2,108],52:[2,108],57:[2,108],60:[2,108],76:[2,108],81:[2,108],90:[2,108],95:[2,108],97:[2,108],106:[2,108],108:[2,108],109:[2,108],110:[2,108],114:[2,108],122:[2,108],130:[2,108],133:[2,108],134:[2,108],139:[2,108],140:[2,108],141:[2,108],142:[2,108],143:[2,108],144:[2,108],145:[2,108]},{1:[2,149],6:[2,149],28:[2,149],29:[2,149],52:[2,149],57:[2,149],60:[2,149],69:[2,149],70:[2,149],71:[2,149],72:[2,149],74:[2,149],76:[2,149],77:[2,149],81:[2,149],88:[2,149],89:[2,149],90:[2,149],95:[2,149],97:[2,149],106:[2,149],108:[2,149],109:[2,149],110:[2,149],114:[2,149],122:[2,149],130:[2,149],133:[2,149],134:[2,149],139:[2,149],140:[2,149],141:[2,149],142:[2,149],143:[2,149],144:[2,149],145:[2,149]},{1:[2,125],6:[2,125],28:[2,125],29:[2,125],52:[2,125],57:[2,125],60:[2,125],69:[2,125],70:[2,125],71:[2,125],72:[2,125],74:[2,125],76:[2,125],77:[2,125],81:[2,125],88:[2,125],89:[2,125],90:[2,125],95:[2,125],97:[2,125],106:[2,125],108:[2,125],109:[2,125],110:[2,125],114:[2,125],122:[2,125],130:[2,125],133:[2,125],134:[2,125],139:[2,125],140:[2,125],141:[2,125],142:[2,125],143:[2,125],144:[2,125],145:[2,125]},{6:[2,132],28:[2,132],29:[2,132],57:[2,132],90:[2,132],95:[2,132]},{6:[2,56],28:[2,56],29:[2,56],56:338,57:[1,245]},{6:[2,133],28:[2,133],29:[2,133],57:[2,133],90:[2,133],95:[2,133]},{1:[2,175],6:[2,175],28:[2,175],29:[2,175],52:[2,175],57:[2,175],60:[2,175],76:[2,175],81:[2,175],90:[2,175],95:[2,175],97:[2,175],106:[2,175],107:89,108:[2,175],109:[2,175],110:[2,175],113:90,114:[2,175],115:73,122:[1,339],130:[2,175],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,177],6:[2,177],28:[2,177],29:[2,177],52:[2,177],57:[2,177],60:[2,177],76:[2,177],81:[2,177],90:[2,177],95:[2,177],97:[2,177],106:[2,177],107:89,108:[2,177],109:[1,340],110:[2,177],113:90,114:[2,177],115:73,122:[2,177],130:[2,177],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,176],6:[2,176],28:[2,176],29:[2,176],52:[2,176],57:[2,176],60:[2,176],76:[2,176],81:[2,176],90:[2,176],95:[2,176],97:[2,176],106:[2,176],107:89,108:[2,176],109:[2,176],110:[2,176],113:90,114:[2,176],115:73,122:[2,176],130:[2,176],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{6:[2,99],28:[2,99],29:[2,99],57:[2,99],81:[2,99]},{6:[2,56],28:[2,56],29:[2,56],56:341,57:[1,255]},{29:[1,342],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{6:[1,266],28:[1,267],29:[1,343]},{29:[1,344]},{1:[2,183],6:[2,183],28:[2,183],29:[2,183],52:[2,183],57:[2,183],60:[2,183],76:[2,183],81:[2,183],90:[2,183],95:[2,183],97:[2,183],106:[2,183],108:[2,183],109:[2,183],110:[2,183],114:[2,183],122:[2,183],130:[2,183],133:[2,183],134:[2,183],139:[2,183],140:[2,183],141:[2,183],142:[2,183],143:[2,183],144:[2,183],145:[2,183]},{29:[2,187],125:[2,187],127:[2,187]},{28:[2,139],57:[2,139],107:89,108:[1,69],110:[1,70],113:90,114:[1,72],115:73,130:[1,88],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{6:[1,289],28:[1,290],29:[1,345]},{7:346,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{7:347,8:122,9:19,10:20,11:[1,21],12:22,13:[1,50],15:6,16:7,17:8,18:9,19:10,20:11,21:12,22:13,23:14,24:15,25:16,26:17,27:18,30:66,31:[1,77],32:53,33:[1,75],34:[1,76],35:24,36:[1,54],37:[1,55],38:[1,56],39:[1,57],40:[1,58],41:[1,59],42:23,47:67,48:[1,48],49:[1,49],50:[1,29],53:30,54:[1,64],55:[1,65],61:51,62:52,64:38,66:25,67:26,68:27,79:[1,74],82:[1,45],86:[1,28],87:[1,47],92:[1,62],93:[1,63],94:[1,61],100:[1,40],104:[1,46],105:[1,60],107:41,108:[1,69],110:[1,70],111:42,112:[1,71],113:43,114:[1,72],115:73,123:[1,44],128:39,129:[1,68],131:[1,31],132:[1,32],133:[1,33],134:[1,34],135:[1,35],137:[1,36],138:[1,37]},{6:[1,300],28:[1,301],29:[1,348]},{6:[2,44],28:[2,44],29:[2,44],57:[2,44],81:[2,44]},{6:[2,62],28:[2,62],29:[2,62],52:[2,62],57:[2,62]},{1:[2,181],6:[2,181],28:[2,181],29:[2,181],52:[2,181],57:[2,181],60:[2,181],76:[2,181],81:[2,181],90:[2,181],95:[2,181],97:[2,181],106:[2,181],108:[2,181],109:[2,181],110:[2,181],114:[2,181],122:[2,181],130:[2,181],133:[2,181],134:[2,181],139:[2,181],140:[2,181],141:[2,181],142:[2,181],143:[2,181],144:[2,181],145:[2,181]},{6:[2,134],28:[2,134],29:[2,134],57:[2,134],90:[2,134],95:[2,134]},{1:[2,178],6:[2,178],28:[2,178],29:[2,178],52:[2,178],57:[2,178],60:[2,178],76:[2,178],81:[2,178],90:[2,178],95:[2,178],97:[2,178],106:[2,178],107:89,108:[2,178],109:[2,178],110:[2,178],113:90,114:[2,178],115:73,122:[2,178],130:[2,178],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{1:[2,179],6:[2,179],28:[2,179],29:[2,179],52:[2,179],57:[2,179],60:[2,179],76:[2,179],81:[2,179],90:[2,179],95:[2,179],97:[2,179],106:[2,179],107:89,108:[2,179],109:[2,179],110:[2,179],113:90,114:[2,179],115:73,122:[2,179],130:[2,179],133:[1,81],134:[1,80],139:[1,79],140:[1,82],141:[1,83],142:[1,84],143:[1,85],144:[1,86],145:[1,87]},{6:[2,100],28:[2,100],29:[2,100],57:[2,100],81:[2,100]}],
defaultActions: {64:[2,54],65:[2,55],96:[2,115],204:[2,94]},
parseError: function parseError (str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        throw new Error(str);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    this.lexer.setInput(input);
    this.lexer.yy = this.yy;
    this.yy.lexer = this.lexer;
    this.yy.parser = this;
    if (typeof this.lexer.yylloc == 'undefined') {
        this.lexer.yylloc = {};
    }
    var yyloc = this.lexer.yylloc;
    lstack.push(yyloc);
    var ranges = this.lexer.options && this.lexer.options.ranges;
    if (typeof this.yy.parseError === 'function') {
        this.parseError = this.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    function lex() {
        var token;
        token = self.lexer.lex() || EOF;
        if (typeof token !== 'number') {
            token = self.symbols_[token] || token;
        }
        return token;
    }
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (this.lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + this.lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: this.lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: this.lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(this.lexer.yytext);
            lstack.push(this.lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = this.lexer.yyleng;
                yytext = this.lexer.yytext;
                yylineno = this.lexer.yylineno;
                yyloc = this.lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                this.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain (args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,require('_process'))
},{"_process":22,"fs":13,"path":21}],8:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  var CoffeeScript, Module, binary, child_process, ext, findExtension, fork, helpers, loadFile, path, _i, _len, _ref;

  CoffeeScript = require('./coffee-script');

  child_process = require('child_process');

  helpers = require('./helpers');

  path = require('path');

  loadFile = function(module, filename) {
    var answer;
    answer = CoffeeScript._compileFile(filename, false, {
      runtime: "interp"
    });
    return module._compile(answer, filename);
  };

  if (require.extensions) {
    _ref = CoffeeScript.FILE_EXTENSIONS;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ext = _ref[_i];
      require.extensions[ext] = loadFile;
    }
    Module = require('module');
    findExtension = function(filename) {
      var curExtension, extensions;
      extensions = path.basename(filename).split('.');
      if (extensions[0] === '') {
        extensions.shift();
      }
      while (extensions.shift()) {
        curExtension = '.' + extensions.join('.');
        if (Module._extensions[curExtension]) {
          return curExtension;
        }
      }
      return '.js';
    };
    Module.prototype.load = function(filename) {
      var extension;
      this.filename = filename;
      this.paths = Module._nodeModulePaths(path.dirname(filename));
      extension = findExtension(filename);
      Module._extensions[extension](this, filename);
      return this.loaded = true;
    };
  }

  if (child_process) {
    fork = child_process.fork;
    binary = require.resolve('../../bin/coffee');
    child_process.fork = function(path, args, options) {
      if (helpers.isCoffee(path)) {
        if (!Array.isArray(args)) {
          options = args || {};
          args = [];
        }
        args = [path].concat(args);
        path = binary;
      }
      return fork(path, args, options);
    };
  }

  CoffeeScript.installSourceMapSupport({
    environment: 'node',
    handleUncaughtExceptions: false,
    emptyCacheBetweenOperations: true
  });

}).call(this);

},{"./coffee-script":2,"./helpers":3,"child_process":13,"module":13,"path":21}],9:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  var BALANCED_PAIRS, CALL_CLOSERS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, SINGLE_CLOSERS, SINGLE_LINERS, generate, left, rite, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  generate = function(tag, value, origin) {
    var tok;
    tok = [tag, value];
    tok.generated = true;
    if (origin) {
      tok.origin = origin;
    }
    return tok;
  };

  exports.Rewriter = (function() {
    function Rewriter() {}

    Rewriter.prototype.rewrite = function(tokens) {
      this.tokens = tokens;
      this.removeLeadingNewlines();
      this.closeOpenCalls();
      this.closeOpenIndexes();
      this.normalizeLines();
      this.tagPostfixConditionals();
      this.addImplicitBracesAndParens();
      this.addLocationDataToGeneratedTokens();
      return this.tokens;
    };

    Rewriter.prototype.scanTokens = function(block) {
      var i, token, tokens;
      tokens = this.tokens;
      i = 0;
      while (token = tokens[i]) {
        i += block.call(this, token, i, tokens);
      }
      return true;
    };

    Rewriter.prototype.detectEnd = function(i, condition, action) {
      var levels, token, tokens, _ref, _ref1;
      tokens = this.tokens;
      levels = 0;
      while (token = tokens[i]) {
        if (levels === 0 && condition.call(this, token, i)) {
          return action.call(this, token, i);
        }
        if (!token || levels < 0) {
          return action.call(this, token, i - 1);
        }
        if (_ref = token[0], __indexOf.call(EXPRESSION_START, _ref) >= 0) {
          levels += 1;
        } else if (_ref1 = token[0], __indexOf.call(EXPRESSION_END, _ref1) >= 0) {
          levels -= 1;
        }
        i += 1;
      }
      return i - 1;
    };

    Rewriter.prototype.removeLeadingNewlines = function() {
      var i, tag, _i, _len, _ref;
      _ref = this.tokens;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        tag = _ref[i][0];
        if (tag !== 'TERMINATOR') {
          break;
        }
      }
      if (i) {
        return this.tokens.splice(0, i);
      }
    };

    Rewriter.prototype.closeOpenCalls = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return ((_ref = token[0]) === ')' || _ref === 'CALL_END') || token[0] === 'OUTDENT' && this.tag(i - 1) === ')';
      };
      action = function(token, i) {
        return this.tokens[token[0] === 'OUTDENT' ? i - 1 : i][0] = 'CALL_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'CALL_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.closeOpenIndexes = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === ']' || _ref === 'INDEX_END';
      };
      action = function(token, i) {
        return token[0] = 'INDEX_END';
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === 'INDEX_START') {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.matchTags = function() {
      var fuzz, i, j, pattern, _i, _ref, _ref1;
      i = arguments[0], pattern = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      fuzz = 0;
      for (j = _i = 0, _ref = pattern.length; 0 <= _ref ? _i < _ref : _i > _ref; j = 0 <= _ref ? ++_i : --_i) {
        while (this.tag(i + j + fuzz) === 'HERECOMMENT') {
          fuzz += 2;
        }
        if (pattern[j] == null) {
          continue;
        }
        if (typeof pattern[j] === 'string') {
          pattern[j] = [pattern[j]];
        }
        if (_ref1 = this.tag(i + j + fuzz), __indexOf.call(pattern[j], _ref1) < 0) {
          return false;
        }
      }
      return true;
    };

    Rewriter.prototype.looksObjectish = function(j) {
      return this.matchTags(j, '@', null, ':') || this.matchTags(j, null, ':');
    };

    Rewriter.prototype.findTagsBackwards = function(i, tags) {
      var backStack, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      backStack = [];
      while (i >= 0 && (backStack.length || (_ref2 = this.tag(i), __indexOf.call(tags, _ref2) < 0) && ((_ref3 = this.tag(i), __indexOf.call(EXPRESSION_START, _ref3) < 0) || this.tokens[i].generated) && (_ref4 = this.tag(i), __indexOf.call(LINEBREAKS, _ref4) < 0))) {
        if (_ref = this.tag(i), __indexOf.call(EXPRESSION_END, _ref) >= 0) {
          backStack.push(this.tag(i));
        }
        if ((_ref1 = this.tag(i), __indexOf.call(EXPRESSION_START, _ref1) >= 0) && backStack.length) {
          backStack.pop();
        }
        i -= 1;
      }
      return _ref5 = this.tag(i), __indexOf.call(tags, _ref5) >= 0;
    };

    Rewriter.prototype.addImplicitBracesAndParens = function() {
      var stack;
      stack = [];
      return this.scanTokens(function(token, i, tokens) {
        var endImplicitCall, endImplicitObject, forward, inImplicit, inImplicitCall, inImplicitControl, inImplicitObject, newLine, nextTag, offset, prevTag, prevToken, ret, s, sameLine, stackIdx, stackTag, stackTop, startIdx, startImplicitCall, startImplicitObject, startsLine, tag, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
        tag = token[0];
        prevTag = (prevToken = i > 0 ? tokens[i - 1] : [])[0];
        nextTag = (i < tokens.length - 1 ? tokens[i + 1] : [])[0];
        stackTop = function() {
          return stack[stack.length - 1];
        };
        startIdx = i;
        forward = function(n) {
          return i - startIdx + n;
        };
        inImplicit = function() {
          var _ref, _ref1;
          return (_ref = stackTop()) != null ? (_ref1 = _ref[2]) != null ? _ref1.ours : void 0 : void 0;
        };
        inImplicitCall = function() {
          var _ref;
          return inImplicit() && ((_ref = stackTop()) != null ? _ref[0] : void 0) === '(';
        };
        inImplicitObject = function() {
          var _ref;
          return inImplicit() && ((_ref = stackTop()) != null ? _ref[0] : void 0) === '{';
        };
        inImplicitControl = function() {
          var _ref;
          return inImplicit && ((_ref = stackTop()) != null ? _ref[0] : void 0) === 'CONTROL';
        };
        startImplicitCall = function(j) {
          var idx;
          idx = j != null ? j : i;
          stack.push([
            '(', idx, {
              ours: true
            }
          ]);
          tokens.splice(idx, 0, generate('CALL_START', '('));
          if (j == null) {
            return i += 1;
          }
        };
        endImplicitCall = function() {
          stack.pop();
          tokens.splice(i, 0, generate('CALL_END', ')'));
          return i += 1;
        };
        startImplicitObject = function(j, startsLine) {
          var idx;
          if (startsLine == null) {
            startsLine = true;
          }
          idx = j != null ? j : i;
          stack.push([
            '{', idx, {
              sameLine: true,
              startsLine: startsLine,
              ours: true
            }
          ]);
          tokens.splice(idx, 0, generate('{', generate(new String('{')), token));
          if (j == null) {
            return i += 1;
          }
        };
        endImplicitObject = function(j) {
          j = j != null ? j : i;
          stack.pop();
          tokens.splice(j, 0, generate('}', '}', token));
          return i += 1;
        };
        if (inImplicitCall() && (tag === 'IF' || tag === 'TRY' || tag === 'FINALLY' || tag === 'CATCH' || tag === 'CLASS' || tag === 'SWITCH')) {
          stack.push([
            'CONTROL', i, {
              ours: true
            }
          ]);
          return forward(1);
        }
        if (tag === 'INDENT' && inImplicit()) {
          if (prevTag !== '=>' && prevTag !== '->' && prevTag !== '[' && prevTag !== '(' && prevTag !== ',' && prevTag !== '{' && prevTag !== 'TRY' && prevTag !== 'ELSE' && prevTag !== '=') {
            while (inImplicitCall()) {
              endImplicitCall();
            }
          }
          if (inImplicitControl()) {
            stack.pop();
          }
          stack.push([tag, i]);
          return forward(1);
        }
        if (__indexOf.call(EXPRESSION_START, tag) >= 0) {
          stack.push([tag, i]);
          return forward(1);
        }
        if (__indexOf.call(EXPRESSION_END, tag) >= 0) {
          while (inImplicit()) {
            if (inImplicitCall()) {
              endImplicitCall();
            } else if (inImplicitObject()) {
              endImplicitObject();
            } else {
              stack.pop();
            }
          }
          stack.pop();
        }
        if ((__indexOf.call(IMPLICIT_FUNC, tag) >= 0 && token.spaced && !token.stringEnd || tag === '?' && i > 0 && !tokens[i - 1].spaced) && (__indexOf.call(IMPLICIT_CALL, nextTag) >= 0 || __indexOf.call(IMPLICIT_UNSPACED_CALL, nextTag) >= 0 && !((_ref = tokens[i + 1]) != null ? _ref.spaced : void 0) && !((_ref1 = tokens[i + 1]) != null ? _ref1.newLine : void 0))) {
          if (tag === '?') {
            tag = token[0] = 'FUNC_EXIST';
          }
          startImplicitCall(i + 1);
          ret = forward(2);
          return ret;
        }
        if (__indexOf.call(IMPLICIT_FUNC, tag) >= 0 && this.matchTags(i + 1, 'INDENT', null, ':') && !this.findTagsBackwards(i, ['CLASS', 'EXTENDS', 'IF', 'CATCH', 'SWITCH', 'LEADING_WHEN', 'FOR', 'WHILE', 'UNTIL'])) {
          startImplicitCall(i + 1);
          stack.push(['INDENT', i + 2]);
          return forward(3);
        }
        if (tag === ':') {
          if (this.tag(i - 2) === '@') {
            s = i - 2;
          } else {
            s = i - 1;
          }
          while (this.tag(s - 2) === 'HERECOMMENT') {
            s -= 2;
          }
          this.insideForDeclaration = nextTag === 'FOR';
          startsLine = s === 0 || (_ref2 = this.tag(s - 1), __indexOf.call(LINEBREAKS, _ref2) >= 0) || tokens[s - 1].newLine;
          if (stackTop()) {
            _ref3 = stackTop(), stackTag = _ref3[0], stackIdx = _ref3[1];
            if ((stackTag === '{' || stackTag === 'INDENT' && this.tag(stackIdx - 1) === '{') && (startsLine || this.tag(s - 1) === ',' || this.tag(s - 1) === '{')) {
              return forward(1);
            }
          }
          startImplicitObject(s, !!startsLine);
          return forward(2);
        }
        if (inImplicitObject() && __indexOf.call(LINEBREAKS, tag) >= 0) {
          stackTop()[2].sameLine = false;
        }
        newLine = prevTag === 'OUTDENT' || prevToken.newLine;
        if (__indexOf.call(IMPLICIT_END, tag) >= 0 || __indexOf.call(CALL_CLOSERS, tag) >= 0 && newLine) {
          while (inImplicit()) {
            _ref4 = stackTop(), stackTag = _ref4[0], stackIdx = _ref4[1], (_ref5 = _ref4[2], sameLine = _ref5.sameLine, startsLine = _ref5.startsLine);
            if (inImplicitCall() && prevTag !== ',') {
              endImplicitCall();
            } else if (inImplicitObject() && !this.insideForDeclaration && sameLine && tag !== 'TERMINATOR' && prevTag !== ':' && endImplicitObject()) {

            } else if (inImplicitObject() && tag === 'TERMINATOR' && prevTag !== ',' && !(startsLine && this.looksObjectish(i + 1))) {
              endImplicitObject();
            } else {
              break;
            }
          }
        }
        if (tag === ',' && !this.looksObjectish(i + 1) && inImplicitObject() && !this.insideForDeclaration && (nextTag !== 'TERMINATOR' || !this.looksObjectish(i + 2))) {
          offset = nextTag === 'OUTDENT' ? 1 : 0;
          while (inImplicitObject()) {
            endImplicitObject(i + offset);
          }
        }
        return forward(1);
      });
    };

    Rewriter.prototype.addLocationDataToGeneratedTokens = function() {
      return this.scanTokens(function(token, i, tokens) {
        var column, line, nextLocation, prevLocation, _ref, _ref1;
        if (token[2]) {
          return 1;
        }
        if (!(token.generated || token.explicit)) {
          return 1;
        }
        if (token[0] === '{' && (nextLocation = (_ref = tokens[i + 1]) != null ? _ref[2] : void 0)) {
          line = nextLocation.first_line, column = nextLocation.first_column;
        } else if (prevLocation = (_ref1 = tokens[i - 1]) != null ? _ref1[2] : void 0) {
          line = prevLocation.last_line, column = prevLocation.last_column;
        } else {
          line = column = 0;
        }
        token[2] = {
          first_line: line,
          first_column: column,
          last_line: line,
          last_column: column
        };
        return 1;
      });
    };

    Rewriter.prototype.normalizeLines = function() {
      var action, condition, indent, outdent, starter;
      starter = indent = outdent = null;
      condition = function(token, i) {
        var _ref, _ref1, _ref2, _ref3;
        return token[1] !== ';' && (_ref = token[0], __indexOf.call(SINGLE_CLOSERS, _ref) >= 0) && !(token[0] === 'TERMINATOR' && (_ref1 = this.tag(i + 1), __indexOf.call(EXPRESSION_CLOSE, _ref1) >= 0)) && !(token[0] === 'ELSE' && starter !== 'THEN') && !(((_ref2 = token[0]) === 'CATCH' || _ref2 === 'FINALLY') && (starter === '->' || starter === '=>')) || (_ref3 = token[0], __indexOf.call(CALL_CLOSERS, _ref3) >= 0) && this.tokens[i - 1].newLine;
      };
      action = function(token, i) {
        return this.tokens.splice((this.tag(i - 1) === ',' ? i - 1 : i), 0, outdent);
      };
      return this.scanTokens(function(token, i, tokens) {
        var j, tag, _i, _ref, _ref1, _ref2;
        tag = token[0];
        if (tag === 'TERMINATOR') {
          if (this.tag(i + 1) === 'ELSE' && this.tag(i - 1) !== 'OUTDENT') {
            tokens.splice.apply(tokens, [i, 1].concat(__slice.call(this.indentation())));
            return 1;
          }
          if (_ref = this.tag(i + 1), __indexOf.call(EXPRESSION_CLOSE, _ref) >= 0) {
            tokens.splice(i, 1);
            return 0;
          }
        }
        if (tag === 'CATCH') {
          for (j = _i = 1; _i <= 2; j = ++_i) {
            if (!((_ref1 = this.tag(i + j)) === 'OUTDENT' || _ref1 === 'TERMINATOR' || _ref1 === 'FINALLY')) {
              continue;
            }
            tokens.splice.apply(tokens, [i + j, 0].concat(__slice.call(this.indentation())));
            return 2 + j;
          }
        }
        if (__indexOf.call(SINGLE_LINERS, tag) >= 0 && this.tag(i + 1) !== 'INDENT' && !(tag === 'ELSE' && this.tag(i + 1) === 'IF')) {
          starter = tag;
          _ref2 = this.indentation(tokens[i]), indent = _ref2[0], outdent = _ref2[1];
          if (starter === 'THEN') {
            indent.fromThen = true;
          }
          tokens.splice(i + 1, 0, indent);
          this.detectEnd(i + 2, condition, action);
          if (tag === 'THEN') {
            tokens.splice(i, 1);
          }
          return 1;
        }
        return 1;
      });
    };

    Rewriter.prototype.tagPostfixConditionals = function() {
      var action, condition, original;
      original = null;
      condition = function(token, i) {
        var prevTag, tag;
        tag = token[0];
        prevTag = this.tokens[i - 1][0];
        return tag === 'TERMINATOR' || (tag === 'INDENT' && __indexOf.call(SINGLE_LINERS, prevTag) < 0);
      };
      action = function(token, i) {
        if (token[0] !== 'INDENT' || (token.generated && !token.fromThen)) {
          return original[0] = 'POST_' + original[0];
        }
      };
      return this.scanTokens(function(token, i) {
        if (token[0] !== 'IF') {
          return 1;
        }
        original = token;
        this.detectEnd(i + 1, condition, action);
        return 1;
      });
    };

    Rewriter.prototype.indentation = function(origin) {
      var indent, outdent;
      indent = ['INDENT', 2];
      outdent = ['OUTDENT', 2];
      if (origin) {
        indent.generated = outdent.generated = true;
        indent.origin = outdent.origin = origin;
      } else {
        indent.explicit = outdent.explicit = true;
      }
      return [indent, outdent];
    };

    Rewriter.prototype.generate = generate;

    Rewriter.prototype.tag = function(i) {
      var _ref;
      return (_ref = this.tokens[i]) != null ? _ref[0] : void 0;
    };

    return Rewriter;

  })();

  BALANCED_PAIRS = [['(', ')'], ['[', ']'], ['{', '}'], ['INDENT', 'OUTDENT'], ['CALL_START', 'CALL_END'], ['PARAM_START', 'PARAM_END'], ['INDEX_START', 'INDEX_END']];

  exports.INVERSES = INVERSES = {};

  EXPRESSION_START = [];

  EXPRESSION_END = [];

  for (_i = 0, _len = BALANCED_PAIRS.length; _i < _len; _i++) {
    _ref = BALANCED_PAIRS[_i], left = _ref[0], rite = _ref[1];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  }

  EXPRESSION_CLOSE = ['CATCH', 'THEN', 'ELSE', 'FINALLY'].concat(EXPRESSION_END);

  IMPLICIT_FUNC = ['IDENTIFIER', 'SUPER', ')', 'CALL_END', ']', 'INDEX_END', '@', 'THIS'];

  IMPLICIT_CALL = ['IDENTIFIER', 'NUMBER', 'STRING', 'JS', 'REGEX', 'NEW', 'PARAM_START', 'CLASS', 'IF', 'TRY', 'SWITCH', 'THIS', 'BOOL', 'NULL', 'UNDEFINED', 'UNARY', 'YIELD', 'UNARY_MATH', 'SUPER', 'THROW', '@', '->', '=>', '[', '(', '{', '--', '++'];

  IMPLICIT_UNSPACED_CALL = ['+', '-'];

  IMPLICIT_END = ['POST_IF', 'FOR', 'WHILE', 'UNTIL', 'WHEN', 'BY', 'LOOP', 'TERMINATOR'];

  SINGLE_LINERS = ['ELSE', '->', '=>', 'TRY', 'FINALLY', 'THEN'];

  SINGLE_CLOSERS = ['TERMINATOR', 'CATCH', 'FINALLY', 'ELSE', 'OUTDENT', 'LEADING_WHEN'];

  LINEBREAKS = ['TERMINATOR', 'INDENT', 'OUTDENT'];

  CALL_CLOSERS = ['.', '?.', '::', '?::'];

  IMPLICIT_FUNC.push('DEFER');

  IMPLICIT_CALL.push('DEFER');

  IMPLICIT_END.push('AWAIT');

}).call(this);

},{}],10:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  var Scope, extend, iced, last, _ref;

  _ref = require('./helpers'), extend = _ref.extend, last = _ref.last;

  iced = require('iced-runtime');

  exports.Scope = Scope = (function() {
    Scope.root = null;

    function Scope(parent, expressions, method) {
      this.parent = parent;
      this.expressions = expressions;
      this.method = method;
      this.variables = [
        {
          name: 'arguments',
          type: 'arguments'
        }
      ];
      this.positions = {};
      if (!this.parent) {
        Scope.root = this;
      }
    }

    Scope.prototype.add = function(name, type, immediate) {
      if (this.shared && !immediate) {
        return this.parent.add(name, type, immediate);
      }
      if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
        return this.variables[this.positions[name]].type = type;
      } else {
        return this.positions[name] = this.variables.push({
          name: name,
          type: type
        }) - 1;
      }
    };

    Scope.prototype.namedMethod = function() {
      var _ref1;
      if (((_ref1 = this.method) != null ? _ref1.name : void 0) || !this.parent) {
        return this.method;
      }
      return this.parent.namedMethod();
    };

    Scope.prototype.find = function(name) {
      if (this.check(name)) {
        return true;
      }
      this.add(name, 'var');
      return false;
    };

    Scope.prototype.parameter = function(name) {
      if (this.shared && this.parent.check(name, true)) {
        return;
      }
      return this.add(name, 'param');
    };

    Scope.prototype.check = function(name) {
      var _ref1;
      return !!(this.type(name) || ((_ref1 = this.parent) != null ? _ref1.check(name) : void 0));
    };

    Scope.prototype.temporary = function(name, index) {
      if (name.length > 1) {
        return '_' + name + (index > 1 ? index - 1 : '');
      } else {
        return '_' + (index + parseInt(name, 36)).toString(36).replace(/\d/g, 'a');
      }
    };

    Scope.prototype.type = function(name) {
      var v, _i, _len, _ref1;
      _ref1 = this.variables;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        v = _ref1[_i];
        if (v.name === name) {
          return v.type;
        }
      }
      return null;
    };

    Scope.prototype.freeVariable = function(name, reserve) {
      var index, temp;
      if (reserve == null) {
        reserve = true;
      }
      index = 0;
      while (this.check((temp = this.temporary(name, index)))) {
        index++;
      }
      if (reserve) {
        this.add(temp, 'var', true);
      }
      return temp;
    };

    Scope.prototype.assign = function(name, value) {
      this.add(name, {
        value: value,
        assigned: true
      }, true);
      return this.hasAssignments = true;
    };

    Scope.prototype.hasDeclarations = function() {
      return !!this.declaredVariables().length;
    };

    Scope.prototype.declaredVariables = function() {
      var realVars, tempVars, v, _i, _len, _ref1;
      realVars = [];
      tempVars = [];
      _ref1 = this.variables;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        v = _ref1[_i];
        if (v.type === 'var') {
          (v.name.charAt(0) === '_' ? tempVars : realVars).push(v.name);
        }
      }
      return realVars.sort().concat(tempVars.sort());
    };

    Scope.prototype.assignedVariables = function() {
      var v, _i, _len, _ref1, _results;
      _ref1 = this.variables;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        v = _ref1[_i];
        if (v.type.assigned) {
          _results.push("" + v.name + " = " + v.type.value);
        }
      }
      return _results;
    };

    return Scope;

  })();

}).call(this);

},{"./helpers":3,"iced-runtime":18}],11:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.12
(function() {
  var LineMap, SourceMap;

  LineMap = (function() {
    function LineMap(line) {
      this.line = line;
      this.columns = [];
    }

    LineMap.prototype.add = function(column, _arg, options) {
      var sourceColumn, sourceLine;
      sourceLine = _arg[0], sourceColumn = _arg[1];
      if (options == null) {
        options = {};
      }
      if (this.columns[column] && options.noReplace) {
        return;
      }
      return this.columns[column] = {
        line: this.line,
        column: column,
        sourceLine: sourceLine,
        sourceColumn: sourceColumn
      };
    };

    LineMap.prototype.sourceLocation = function(column) {
      var mapping;
      while (!((mapping = this.columns[column]) || (column <= 0))) {
        column--;
      }
      return mapping && [mapping.sourceLine, mapping.sourceColumn];
    };

    return LineMap;

  })();

  SourceMap = (function() {
    var BASE64_CHARS, VLQ_CONTINUATION_BIT, VLQ_SHIFT, VLQ_VALUE_MASK;

    function SourceMap() {
      this.lines = [];
    }

    SourceMap.prototype.add = function(sourceLocation, generatedLocation, options) {
      var column, line, lineMap, _base;
      if (options == null) {
        options = {};
      }
      line = generatedLocation[0], column = generatedLocation[1];
      lineMap = ((_base = this.lines)[line] || (_base[line] = new LineMap(line)));
      return lineMap.add(column, sourceLocation, options);
    };

    SourceMap.prototype.sourceLocation = function(_arg) {
      var column, line, lineMap;
      line = _arg[0], column = _arg[1];
      while (!((lineMap = this.lines[line]) || (line <= 0))) {
        line--;
      }
      return lineMap && lineMap.sourceLocation(column);
    };

    SourceMap.prototype.generate = function(options, code) {
      var buffer, lastColumn, lastSourceColumn, lastSourceLine, lineMap, lineNumber, mapping, needComma, v3, writingline, _i, _j, _len, _len1, _ref, _ref1;
      if (options == null) {
        options = {};
      }
      if (code == null) {
        code = null;
      }
      writingline = 0;
      lastColumn = 0;
      lastSourceLine = 0;
      lastSourceColumn = 0;
      needComma = false;
      buffer = "";
      _ref = this.lines;
      for (lineNumber = _i = 0, _len = _ref.length; _i < _len; lineNumber = ++_i) {
        lineMap = _ref[lineNumber];
        if (lineMap) {
          _ref1 = lineMap.columns;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            mapping = _ref1[_j];
            if (!(mapping)) {
              continue;
            }
            while (writingline < mapping.line) {
              lastColumn = 0;
              needComma = false;
              buffer += ";";
              writingline++;
            }
            if (needComma) {
              buffer += ",";
              needComma = false;
            }
            buffer += this.encodeVlq(mapping.column - lastColumn);
            lastColumn = mapping.column;
            buffer += this.encodeVlq(0);
            buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);
            lastSourceLine = mapping.sourceLine;
            buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
            lastSourceColumn = mapping.sourceColumn;
            needComma = true;
          }
        }
      }
      v3 = {
        version: 3,
        file: options.generatedFile || '',
        sourceRoot: options.sourceRoot || '',
        sources: options.sourceFiles || [''],
        names: [],
        mappings: buffer
      };
      if (options.inline) {
        v3.sourcesContent = [code];
      }
      return JSON.stringify(v3, null, 2);
    };

    VLQ_SHIFT = 5;

    VLQ_CONTINUATION_BIT = 1 << VLQ_SHIFT;

    VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;

    SourceMap.prototype.encodeVlq = function(value) {
      var answer, nextChunk, signBit, valueToEncode;
      answer = '';
      signBit = value < 0 ? 1 : 0;
      valueToEncode = (Math.abs(value) << 1) + signBit;
      while (valueToEncode || !answer) {
        nextChunk = valueToEncode & VLQ_VALUE_MASK;
        valueToEncode = valueToEncode >> VLQ_SHIFT;
        if (valueToEncode) {
          nextChunk |= VLQ_CONTINUATION_BIT;
        }
        answer += this.encodeBase64(nextChunk);
      }
      return answer;
    };

    BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    SourceMap.prototype.encodeBase64 = function(value) {
      return BASE64_CHARS[value] || (function() {
        throw new Error("Cannot Base64 encode value: " + value);
      })();
    };

    return SourceMap;

  })();

  exports.SourceMap = SourceMap;

}).call(this);

},{}],12:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],13:[function(require,module,exports){

},{}],14:[function(require,module,exports){
(function (Buffer){
var toString = Object.prototype.toString

var isModern = (
  typeof Buffer.alloc === 'function' &&
  typeof Buffer.allocUnsafe === 'function' &&
  typeof Buffer.from === 'function'
)

function isArrayBuffer (input) {
  return toString.call(input).slice(8, -1) === 'ArrayBuffer'
}

function fromArrayBuffer (obj, byteOffset, length) {
  byteOffset >>>= 0

  var maxLength = obj.byteLength - byteOffset

  if (maxLength < 0) {
    throw new RangeError("'offset' is out of bounds")
  }

  if (length === undefined) {
    length = maxLength
  } else {
    length >>>= 0

    if (length > maxLength) {
      throw new RangeError("'length' is out of bounds")
    }
  }

  return isModern
    ? Buffer.from(obj.slice(byteOffset, byteOffset + length))
    : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)))
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  return isModern
    ? Buffer.from(string, encoding)
    : new Buffer(string, encoding)
}

function bufferFrom (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return isModern
    ? Buffer.from(value)
    : new Buffer(value)
}

module.exports = bufferFrom

}).call(this,require("buffer").Buffer)
},{"buffer":15}],15:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this,require("buffer").Buffer)
},{"base64-js":12,"buffer":15,"ieee754":20}],16:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.8
(function() {
  module.exports = {
    k: "__iced_k",
    k_noop: "__iced_k_noop",
    param: "__iced_p_",
    ns: "iced",
    runtime: "runtime",
    Deferrals: "Deferrals",
    deferrals: "__iced_deferrals",
    fulfill: "_fulfill",
    b_while: "_break",
    t_while: "_while",
    c_while: "_continue",
    n_while: "_next",
    n_arg: "__iced_next_arg",
    defer_method: "defer",
    slot: "__slot",
    assign_fn: "assign_fn",
    autocb: "autocb",
    retslot: "ret",
    trace: "__iced_trace",
    passed_deferral: "__iced_passed_deferral",
    findDeferral: "findDeferral",
    lineno: "lineno",
    parent: "parent",
    filename: "filename",
    funcname: "funcname",
    catchExceptions: 'catchExceptions',
    runtime_modes: ["node", "inline", "window", "none", "browserify", "interp"],
    trampoline: "trampoline",
    context: "context",
    defer_arg: "__iced_defer_"
  };

}).call(this);

},{}],17:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.8
(function() {
  var C, Pipeliner, iced, __iced_k, __iced_k_noop, _iand, _ior, _timeout,
    __slice = [].slice;

  __iced_k = __iced_k_noop = function() {};

  C = require('./const');

  exports.iced = iced = require('./runtime');

  _timeout = function(cb, t, res, tmp) {
    var arr, rv, which, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    rv = new iced.Rendezvous;
    tmp[0] = rv.id(true).defer({
      assign_fn: (function(_this) {
        return function() {
          return function() {
            return arr = __slice.call(arguments, 0);
          };
        };
      })(this)(),
      lineno: 20,
      context: __iced_deferrals
    });
    setTimeout(rv.id(false).defer({
      lineno: 21,
      context: __iced_deferrals
    }), t);
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/iced/iced-runtime/src/library.iced"
        });
        rv.wait(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return which = arguments[0];
            };
          })(),
          lineno: 22
        }));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (res) {
          res[0] = which;
        }
        return cb.apply(null, arr);
      };
    })(this));
  };

  exports.timeout = function(cb, t, res) {
    var tmp;
    tmp = [];
    _timeout(cb, t, res, tmp);
    return tmp[0];
  };

  _iand = function(cb, res, tmp) {
    var ok, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/iced/iced-runtime/src/library.iced"
        });
        tmp[0] = __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 39
        });
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (!ok) {
          res[0] = false;
        }
        return cb();
      };
    })(this));
  };

  exports.iand = function(cb, res) {
    var tmp;
    tmp = [];
    _iand(cb, res, tmp);
    return tmp[0];
  };

  _ior = function(cb, res, tmp) {
    var ok, ___iced_passed_deferral, __iced_deferrals, __iced_k;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/Users/max/src/iced/iced-runtime/src/library.iced"
        });
        tmp[0] = __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return ok = arguments[0];
            };
          })(),
          lineno: 58
        });
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        if (ok) {
          res[0] = true;
        }
        return cb();
      };
    })(this));
  };

  exports.ior = function(cb, res) {
    var tmp;
    tmp = [];
    _ior(cb, res, tmp);
    return tmp[0];
  };

  exports.Pipeliner = Pipeliner = (function() {
    function Pipeliner(window, delay) {
      this.window = window || 1;
      this.delay = delay || 0;
      this.queue = [];
      this.n_out = 0;
      this.cb = null;
      this[C.deferrals] = this;
      this["defer"] = this._defer;
    }

    Pipeliner.prototype.waitInQueue = function(cb) {
      var ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          var _while;
          _while = function(__iced_k) {
            var _break, _continue, _next;
            _break = __iced_k;
            _continue = function() {
              return iced.trampoline(function() {
                return _while(__iced_k);
              });
            };
            _next = _continue;
            if (!(_this.n_out >= _this.window)) {
              return _break();
            } else {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/iced/iced-runtime/src/library.iced",
                  funcname: "Pipeliner.waitInQueue"
                });
                _this.cb = __iced_deferrals.defer({
                  lineno: 100
                });
                __iced_deferrals._fulfill();
              })(_next);
            }
          };
          _while(__iced_k);
        });
      })(this)((function(_this) {
        return function() {
          _this.n_out++;
          (function(__iced_k) {
            if (_this.delay) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "/Users/max/src/iced/iced-runtime/src/library.iced",
                  funcname: "Pipeliner.waitInQueue"
                });
                setTimeout(__iced_deferrals.defer({
                  lineno: 108
                }), _this.delay);
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(function() {
            return cb();
          });
        };
      })(this));
    };

    Pipeliner.prototype.__defer = function(out, deferArgs) {
      var tmp, voidCb, ___iced_passed_deferral, __iced_deferrals, __iced_k;
      __iced_k = __iced_k_noop;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      (function(_this) {
        return (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "/Users/max/src/iced/iced-runtime/src/library.iced",
            funcname: "Pipeliner.__defer"
          });
          voidCb = __iced_deferrals.defer({
            lineno: 122
          });
          out[0] = function() {
            var args, _ref;
            args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
            if ((_ref = deferArgs.assign_fn) != null) {
              _ref.apply(null, args);
            }
            return voidCb();
          };
          __iced_deferrals._fulfill();
        });
      })(this)((function(_this) {
        return function() {
          _this.n_out--;
          if (_this.cb) {
            tmp = _this.cb;
            _this.cb = null;
            return tmp();
          }
        };
      })(this));
    };

    Pipeliner.prototype._defer = function(deferArgs) {
      var tmp;
      tmp = [];
      this.__defer(tmp, deferArgs);
      return tmp[0];
    };

    Pipeliner.prototype.flush = function(autocb) {
      var ___iced_passed_deferral, __iced_k, _while;
      __iced_k = autocb;
      ___iced_passed_deferral = iced.findDeferral(arguments);
      _while = (function(_this) {
        var __iced_deferrals;
        return function(__iced_k) {
          var _break, _continue, _next;
          _break = __iced_k;
          _continue = function() {
            return iced.trampoline(function() {
              return _while(__iced_k);
            });
          };
          _next = _continue;
          if (!_this.n_out) {
            return _break();
          } else {
            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/Users/max/src/iced/iced-runtime/src/library.iced",
                funcname: "Pipeliner.flush"
              });
              _this.cb = __iced_deferrals.defer({
                lineno: 151
              });
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
      })(this);
      _while(__iced_k);
    };

    return Pipeliner;

  })();

}).call(this);

},{"./const":16,"./runtime":19}],18:[function(require,module,exports){
// Generated by IcedCoffeeScript 108.0.8
(function() {
  var k, mod, mods, v, _i, _len;

  exports["const"] = require('./const');

  mods = [require('./runtime'), require('./library')];

  for (_i = 0, _len = mods.length; _i < _len; _i++) {
    mod = mods[_i];
    for (k in mod) {
      v = mod[k];
      exports[k] = v;
    }
  }

}).call(this);

},{"./const":16,"./library":17,"./runtime":19}],19:[function(require,module,exports){
(function (process){
// Generated by IcedCoffeeScript 108.0.8
(function() {
  var C, Deferrals, Rendezvous, exceptionHandler, findDeferral, make_defer_return, stackWalk, tick_counter, trampoline, warn, __active_trace, __c, _trace_to_string,
    __slice = [].slice;

  C = require('./const');

  make_defer_return = function(obj, defer_args, id, trace_template, multi) {
    var k, ret, trace, v;
    trace = {};
    for (k in trace_template) {
      v = trace_template[k];
      trace[k] = v;
    }
    trace[C.lineno] = defer_args != null ? defer_args[C.lineno] : void 0;
    ret = function() {
      var inner_args, o, _ref;
      inner_args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (defer_args != null) {
        if ((_ref = defer_args.assign_fn) != null) {
          _ref.apply(null, inner_args);
        }
      }
      if (obj) {
        o = obj;
        if (!multi) {
          obj = null;
        }
        return o._fulfill(id, trace);
      } else {
        return warn("overused deferral at " + (_trace_to_string(trace)));
      }
    };
    ret[C.trace] = trace;
    return ret;
  };

  __c = 0;

  tick_counter = function(mod) {
    __c++;
    if ((__c % mod) === 0) {
      __c = 0;
      return true;
    } else {
      return false;
    }
  };

  __active_trace = null;

  _trace_to_string = function(tr) {
    var fn;
    fn = tr[C.funcname] || "<anonymous>";
    return "" + fn + " (" + tr[C.filename] + ":" + (tr[C.lineno] + 1) + ")";
  };

  warn = function(m) {
    return typeof console !== "undefined" && console !== null ? console.error("ICED warning: " + m) : void 0;
  };

  exports.trampoline = trampoline = function(fn) {
    if (!tick_counter(500)) {
      return fn();
    } else if ((typeof process !== "undefined" && process !== null ? process.nextTick : void 0) != null) {
      return process.nextTick(fn);
    } else {
      return setTimeout(fn);
    }
  };

  exports.Deferrals = Deferrals = (function() {
    function Deferrals(k, trace) {
      this.trace = trace;
      this.continuation = k;
      this.count = 1;
      this.ret = null;
    }

    Deferrals.prototype._call = function(trace) {
      var c;
      if (this.continuation) {
        __active_trace = trace;
        c = this.continuation;
        this.continuation = null;
        return c(this.ret);
      } else {
        return warn("Entered dead await at " + (_trace_to_string(trace)));
      }
    };

    Deferrals.prototype._fulfill = function(id, trace) {
      if (--this.count > 0) {

      } else {
        return trampoline(((function(_this) {
          return function() {
            return _this._call(trace);
          };
        })(this)));
      }
    };

    Deferrals.prototype.defer = function(args) {
      var self;
      this.count++;
      self = this;
      return make_defer_return(self, args, null, this.trace);
    };

    return Deferrals;

  })();

  exports.findDeferral = findDeferral = function(args) {
    var a, _i, _len;
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      a = args[_i];
      if (a != null ? a[C.trace] : void 0) {
        return a;
      }
    }
    return null;
  };

  exports.Rendezvous = Rendezvous = (function() {
    var RvId;

    function Rendezvous() {
      this.completed = [];
      this.waiters = [];
      this.defer_id = 0;
    }

    RvId = (function() {
      function RvId(rv, id, multi) {
        this.rv = rv;
        this.id = id;
        this.multi = multi;
      }

      RvId.prototype.defer = function(defer_args) {
        return this.rv._defer_with_id(this.id, defer_args, this.multi);
      };

      return RvId;

    })();

    Rendezvous.prototype.wait = function(cb) {
      var x;
      if (this.completed.length) {
        x = this.completed.shift();
        return cb(x);
      } else {
        return this.waiters.push(cb);
      }
    };

    Rendezvous.prototype.defer = function(defer_args) {
      var id;
      id = this.defer_id++;
      return this._defer_with_id(id, defer_args);
    };

    Rendezvous.prototype.id = function(i, multi) {
      multi = !!multi;
      return new RvId(this, i, multi);
    };

    Rendezvous.prototype._fulfill = function(id, trace) {
      var cb;
      if (this.waiters.length) {
        cb = this.waiters.shift();
        return cb(id);
      } else {
        return this.completed.push(id);
      }
    };

    Rendezvous.prototype._defer_with_id = function(id, defer_args, multi) {
      this.count++;
      return make_defer_return(this, defer_args, id, {}, multi);
    };

    return Rendezvous;

  })();

  exports.stackWalk = stackWalk = function(cb) {
    var line, ret, tr, _ref;
    ret = [];
    tr = cb ? cb[C.trace] : __active_trace;
    while (tr) {
      line = "   at " + (_trace_to_string(tr));
      ret.push(line);
      tr = tr != null ? (_ref = tr[C.parent]) != null ? _ref[C.trace] : void 0 : void 0;
    }
    return ret;
  };

  exports.exceptionHandler = exceptionHandler = function(err, logger) {
    var stack;
    if (!logger) {
      logger = console.error;
    }
    logger(err.stack);
    stack = stackWalk();
    if (stack.length) {
      logger("Iced 'stack' trace (w/ real line numbers):");
      return logger(stack.join("\n"));
    }
  };

  exports.catchExceptions = function(logger) {
    return typeof process !== "undefined" && process !== null ? process.on('uncaughtException', function(err) {
      exceptionHandler(err, logger);
      return process.exit(1);
    }) : void 0;
  };

}).call(this);

}).call(this,require('_process'))
},{"./const":16,"_process":22}],20:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],21:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":22}],22:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],23:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

},{"./util":32}],24:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = require('./base64');

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

},{"./base64":25}],25:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};

},{}],26:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;

/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */
function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);
  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  }
  else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    }

    // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  }
  else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    }

    // we are in termination case (3) or (2) and return the appropriate thing.
    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}

/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */
exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
  if (index < 0) {
    return -1;
  }

  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }
    --index;
  }

  return index;
};

},{}],27:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.MappingList = MappingList;

},{"./util":32}],28:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}

/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */
function randomIntInRange(low, high) {
  return Math.round(low + (Math.random() * (high - low)));
}

/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */
function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.

  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.

    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;

    swap(ary, pivotIndex, r);
    var pivot = ary[r];

    // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1;

    // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}

/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */
exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

},{}],29:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = require('./util');
var binarySearch = require('./binary-search');
var ArraySet = require('./array-set').ArraySet;
var base64VLQ = require('./base64-vlq');
var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null
    ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
    : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
}

/**
 * The version of the source mapping spec that we are consuming.
 */
SourceMapConsumer.prototype._version = 3;

// `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});

SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator =
  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
SourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;

SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;

/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */
SourceMapConsumer.prototype.eachMapping =
  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

    var mappings;
    switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;
    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;
    default:
      throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */
SourceMapConsumer.prototype.allGeneratedPositionsFor =
  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util.getArg(aArgs, 'line');

    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
    // returns the index of the closest mapping less than the needle. By
    // setting needle.originalColumn to 0, we thus find the last mapping for
    // the given line, provided such a mapping exists.
    var needle = {
      source: util.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util.getArg(aArgs, 'column', 0)
    };

    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }

    var mappings = [];

    var index = this._findMapping(needle,
                                  this._originalMappings,
                                  "originalLine",
                                  "originalColumn",
                                  util.compareByOriginalPositions,
                                  binarySearch.LEAST_UPPER_BOUND);
    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we found. Since
        // mappings are sorted, this is guaranteed to find all mappings for
        // the line we found.
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        // Iterate until either we run out of mappings, or we run into
        // a mapping for a different line than the one we were searching for.
        // Since mappings are sorted, this is guaranteed to find all mappings for
        // the line we are searching for.
        while (mapping &&
               mapping.originalLine === line &&
               mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

exports.SourceMapConsumer = SourceMapConsumer;

/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */
function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources');
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null);

  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources
    .map(String)
    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    .map(util.normalize)
    // Always ensure that absolute sources are internally stored relative to
    // the source root, if the source root is absolute. Not doing this would
    // be particularly problematic when the source root is a prefix of the
    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
    .map(function (source) {
      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
        ? util.relative(sourceRoot, source)
        : source;
    });

  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);

  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });

  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */
BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
  var relativeSource = aSource;
  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  }

  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var i;
  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};

/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */
BasicSourceMapConsumer.fromSourceMap =
  function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);

    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                            smc.sourceRoot);
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function (s) {
      return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
    });

    // Because we are modifying the entries (by converting string sources and
    // names to indices into the sources and names ArraySets), we have to make
    // a copy of the entry or else bad things happen. Shared mutable state
    // strikes again! See github issue #191.

    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping;
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

    return smc;
  };

/**
 * The version of the source mapping spec that we are consuming.
 */
BasicSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});

/**
 * Provide the JIT with a nice shape / hidden class.
 */
function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
BasicSourceMapConsumer.prototype._parseMappings =
  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      }
      else if (aStr.charAt(index) === ',') {
        index++;
      }
      else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        // Because each offset is encoded relative to the previous one,
        // many segments often have the same encoding. We can exploit this
        // fact by caching the parsed variable length fields of each segment,
        // allowing us to avoid a second parse if we encounter the same
        // segment again.
        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str = aStr.slice(index, end);

        segment = cachedSegments[str];
        if (segment) {
          index += str.length;
        } else {
          segment = [];
          while (index < end) {
            base64VLQ.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        // Generated column.
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          // Original source.
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];

          // Original line.
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          // Lines are stored 0-based
          mapping.originalLine += 1;

          // Original column.
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            // Original name.
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;

    quickSort(originalMappings, util.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */
BasicSourceMapConsumer.prototype._findMapping =
  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                         aColumnName, aComparator, aBias) {
    // To return the position we are searching for, we must first find the
    // mapping for the given position and then return the opposite position it
    // points to. Because the mappings are sorted, we can use binary search to
    // find the best mapping.

    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got '
                          + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got '
                          + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */
BasicSourceMapConsumer.prototype.computeColumnSpans =
  function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      // Mappings do not contain a field for the last generated columnt. We
      // can come up with an optimistic estimate, however, by assuming that
      // mappings are contiguous (i.e. given two consecutive mappings, the
      // first mapping ends where the second one starts).
      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      // The last mapping for each line spans the entire line.
      mapping.lastGeneratedColumn = Infinity;
    }
  };

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
BasicSourceMapConsumer.prototype.originalPositionFor =
  function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util.compareByGeneratedPositionsDeflated,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util.getArg(mapping, 'source', null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name = util.getArg(mapping, 'name', null);
        if (name !== null) {
          name = this._names.at(name);
        }
        return {
          source: source,
          line: util.getArg(mapping, 'originalLine', null),
          column: util.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
  function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() &&
      !this.sourcesContent.some(function (sc) { return sc == null; });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
BasicSourceMapConsumer.prototype.sourceContentFor =
  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    var index = this._findSourceIndex(aSource);
    if (index >= 0) {
      return this.sourcesContent[index];
    }

    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    var url;
    if (this.sourceRoot != null
        && (url = util.urlParse(this.sourceRoot))) {
      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
      // many users. We can help them out when they expect file:// URIs to
      // behave like it would if they were running a local HTTP server. See
      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url.scheme == "file"
          && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
      }

      if ((!url.path || url.path == "/")
          && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }

    // This function is used recursively from
    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
    // don't want to throw if we can't find the source - we just want to
    // return null, so we provide a flag to exit gracefully.
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
BasicSourceMapConsumer.prototype.generatedPositionFor =
  function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util.getArg(aArgs, 'source');
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    var needle = {
      source: source,
      originalLine: util.getArg(aArgs, 'line'),
      originalColumn: util.getArg(aArgs, 'column')
    };

    var index = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util.compareByOriginalPositions,
      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
    );

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */
function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;
  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();

  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }
    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line ||
        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }
    lastOffset = offset;

    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    }
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

/**
 * The version of the source mapping spec that we are consuming.
 */
IndexedSourceMapConsumer.prototype._version = 3;

/**
 * The list of original sources.
 */
Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];
    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }
    return sources;
  }
});

/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */
IndexedSourceMapConsumer.prototype.originalPositionFor =
  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util.getArg(aArgs, 'line'),
      generatedColumn: util.getArg(aArgs, 'column')
    };

    // Find the section containing the generated position we're trying to map
    // to an original position.
    var sectionIndex = binarySearch.search(needle, this._sections,
      function(needle, section) {
        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }

        return (needle.generatedColumn -
                section.generatedOffset.generatedColumn);
      });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine -
        (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn -
        (section.generatedOffset.generatedLine === needle.generatedLine
         ? section.generatedOffset.generatedColumn - 1
         : 0),
      bias: aArgs.bias
    });
  };

/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */
IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */
IndexedSourceMapConsumer.prototype.sourceContentFor =
  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    }
    else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */
IndexedSourceMapConsumer.prototype.generatedPositionFor =
  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      // Only consider this section if the requested source is in the list of
      // sources of the consumer.
      if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line +
            (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column +
            (section.generatedOffset.generatedLine === generatedPosition.line
             ? section.generatedOffset.generatedColumn - 1
             : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */
IndexedSourceMapConsumer.prototype._parseMappings =
  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);
        source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);

        var name = null;
        if (mapping.name) {
          name = section.consumer._names.at(mapping.name);
          this._names.add(name);
          name = this._names.indexOf(name);
        }

        // The mappings coming from the consumer for the section have
        // generated positions relative to the start of the section, so we
        // need to offset them to be relative to the start of the concatenated
        // generated file.
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine +
            (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn +
            (section.generatedOffset.generatedLine === mapping.generatedLine
            ? section.generatedOffset.generatedColumn - 1
            : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util.compareByOriginalPositions);
  };

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

},{"./array-set":23,"./base64-vlq":24,"./binary-search":26,"./quick-sort":28,"./util":32}],30:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = require('./base64-vlq');
var util = require('./util');
var ArraySet = require('./array-set').ArraySet;
var MappingList = require('./mapping-list').MappingList;

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.SourceMapGenerator = SourceMapGenerator;

},{"./array-set":23,"./base64-vlq":24,"./mapping-list":27,"./util":32}],31:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
var util = require('./util');

// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).
var REGEX_NEWLINE = /(\r?\n)/;

// Newline character code for charCodeAt() comparisons
var NEWLINE_CODE = 10;

// Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!
var isSourceNode = "$$$isSourceNode$$$";

/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */
function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}

/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */
SourceNode.fromStringWithSourceMap =
  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    // The SourceNode we want to fill with the generated code
    // and the SourceMap
    var node = new SourceNode();

    // All even indices of this array are one line of the generated code,
    // while all odd indices are the newlines between two adjacent lines
    // (since `REGEX_NEWLINE` captures its match).
    // Processed fragments are accessed by calling `shiftNextLine`.
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      // The last line of a file might not have a newline.
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ?
            remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    // We need to remember the position of "remainingLines"
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

    // The generate SourceNodes we need a code range.
    // To extract it current and last mapping is used.
    // Here we store the last mapping.
    var lastMapping = null;

    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        // We add the code from "lastMapping" to "mapping":
        // First check if there is a new line in between.
        if (lastGeneratedLine < mapping.generatedLine) {
          // Associate first line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
          // The remaining code is added without mapping
        } else {
          // There is no new line in between.
          // Associate the code between "lastGeneratedColumn" and
          // "mapping.generatedColumn" with "lastMapping"
          var nextLine = remainingLines[remainingLinesIndex] || '';
          var code = nextLine.substr(0, mapping.generatedColumn -
                                        lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                              lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          // No more remaining code, continue
          lastMapping = mapping;
          return;
        }
      }
      // We add the generated code until the first mapping
      // to the SourceNode without any mapping.
      // Each line is added as separate string.
      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || '';
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    // We have processed all mappings.
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        // Associate the remaining code in the current line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      // and add the remaining lines without any mapping
      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    // Copy sourcesContent into SourceNode
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util.join(aRelativePath, sourceFile);
        }
        node.setSourceContent(sourceFile, content);
      }
    });

    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath
          ? util.join(aRelativePath, mapping.source)
          : mapping.source;
        node.add(new SourceNode(mapping.originalLine,
                                mapping.originalColumn,
                                source,
                                code,
                                mapping.name));
      }
    }
  };

/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */
SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length-1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  }
  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  }
  else {
    throw new TypeError(
      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
    );
  }
  return this;
};

/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;
  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];
    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    }
    else {
      if (chunk !== '') {
        aFn(chunk, { source: this.source,
                     line: this.line,
                     column: this.column,
                     name: this.name });
      }
    }
  }
};

/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */
SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;
  if (len > 0) {
    newChildren = [];
    for (i = 0; i < len-1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }
    newChildren.push(this.children[i]);
    this.children = newChildren;
  }
  return this;
};

/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */
SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];
  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  }
  else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  }
  else {
    this.children.push(''.replace(aPattern, aReplacement));
  }
  return this;
};

/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */
SourceNode.prototype.setSourceContent =
  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
  };

/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */
SourceNode.prototype.walkSourceContents =
  function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */
SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};

/**
 * Returns the string representation of this source node along with a source
 * map.
 */
SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;
    if (original.source !== null
        && original.line !== null
        && original.column !== null) {
      if(lastOriginalSource !== original.source
         || lastOriginalLine !== original.line
         || lastOriginalColumn !== original.column
         || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }
      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }
    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0;
        // Mappings end at eol
        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });

  return { code: generated.code, map: map };
};

exports.SourceNode = SourceNode;

},{"./source-map-generator":30,"./util":32}],32:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);

  var parts = path.split(/\/+/);
  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
}
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;

},{}],33:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;

},{"./lib/source-map-consumer":29,"./lib/source-map-generator":30,"./lib/source-node":31}],34:[function(require,module,exports){
(function (process){
var SourceMapConsumer = require('source-map').SourceMapConsumer;
var path = require('path');

var fs;
try {
  fs = require('fs');
  if (!fs.existsSync || !fs.readFileSync) {
    // fs doesn't have all methods we need
    fs = null;
  }
} catch (err) {
  /* nop */
}

var bufferFrom = require('buffer-from');

// Only install once if called multiple times
var errorFormatterInstalled = false;
var uncaughtShimInstalled = false;

// If true, the caches are reset before a stack trace formatting operation
var emptyCacheBetweenOperations = false;

// Supports {browser, node, auto}
var environment = "auto";

// Maps a file path to a string containing the file contents
var fileContentsCache = {};

// Maps a file path to a source map for that file
var sourceMapCache = {};

// Regex for detecting source maps
var reSourceMap = /^data:application\/json[^,]+base64,/;

// Priority list of retrieve handlers
var retrieveFileHandlers = [];
var retrieveMapHandlers = [];

function isInBrowser() {
  if (environment === "browser")
    return true;
  if (environment === "node")
    return false;
  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === "renderer"));
}

function hasGlobalProcessEventEmitter() {
  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));
}

function handlerExec(list) {
  return function(arg) {
    for (var i = 0; i < list.length; i++) {
      var ret = list[i](arg);
      if (ret) {
        return ret;
      }
    }
    return null;
  };
}

var retrieveFile = handlerExec(retrieveFileHandlers);

retrieveFileHandlers.push(function(path) {
  // Trim the path to make sure there is no extra whitespace.
  path = path.trim();
  if (/^file:/.test(path)) {
    // existsSync/readFileSync can't handle file protocol, but once stripped, it works
    path = path.replace(/file:\/\/\/(\w:)?/, function(protocol, drive) {
      return drive ?
        '' : // file:///C:/dir/file -> C:/dir/file
        '/'; // file:///root-dir/file -> /root-dir/file
    });
  }
  if (path in fileContentsCache) {
    return fileContentsCache[path];
  }

  var contents = '';
  try {
    if (!fs) {
      // Use SJAX if we are in the browser
      var xhr = new XMLHttpRequest();
      xhr.open('GET', path, /** async */ false);
      xhr.send(null);
      if (xhr.readyState === 4 && xhr.status === 200) {
        contents = xhr.responseText;
      }
    } else if (fs.existsSync(path)) {
      // Otherwise, use the filesystem
      contents = fs.readFileSync(path, 'utf8');
    }
  } catch (er) {
    /* ignore any errors */
  }

  return fileContentsCache[path] = contents;
});

// Support URLs relative to a directory, but be careful about a protocol prefix
// in case we are in the browser (i.e. directories may start with "http://" or "file:///")
function supportRelativeURL(file, url) {
  if (!file) return url;
  var dir = path.dirname(file);
  var match = /^\w+:\/\/[^\/]*/.exec(dir);
  var protocol = match ? match[0] : '';
  var startPath = dir.slice(protocol.length);
  if (protocol && /^\/\w\:/.test(startPath)) {
    // handle file:///C:/ paths
    protocol += '/';
    return protocol + path.resolve(dir.slice(protocol.length), url).replace(/\\/g, '/');
  }
  return protocol + path.resolve(dir.slice(protocol.length), url);
}

function retrieveSourceMapURL(source) {
  var fileData;

  if (isInBrowser()) {
     try {
       var xhr = new XMLHttpRequest();
       xhr.open('GET', source, false);
       xhr.send(null);
       fileData = xhr.readyState === 4 ? xhr.responseText : null;

       // Support providing a sourceMappingURL via the SourceMap header
       var sourceMapHeader = xhr.getResponseHeader("SourceMap") ||
                             xhr.getResponseHeader("X-SourceMap");
       if (sourceMapHeader) {
         return sourceMapHeader;
       }
     } catch (e) {
     }
  }

  // Get the URL of the source map
  fileData = retrieveFile(source);
  var re = /(?:\/\/[@#][\s]*sourceMappingURL=([^\s'"]+)[\s]*$)|(?:\/\*[@#][\s]*sourceMappingURL=([^\s*'"]+)[\s]*(?:\*\/)[\s]*$)/mg;
  // Keep executing the search to find the *last* sourceMappingURL to avoid
  // picking up sourceMappingURLs from comments, strings, etc.
  var lastMatch, match;
  while (match = re.exec(fileData)) lastMatch = match;
  if (!lastMatch) return null;
  return lastMatch[1];
};

// Can be overridden by the retrieveSourceMap option to install. Takes a
// generated source filename; returns a {map, optional url} object, or null if
// there is no source map.  The map field may be either a string or the parsed
// JSON object (ie, it must be a valid argument to the SourceMapConsumer
// constructor).
var retrieveSourceMap = handlerExec(retrieveMapHandlers);
retrieveMapHandlers.push(function(source) {
  var sourceMappingURL = retrieveSourceMapURL(source);
  if (!sourceMappingURL) return null;

  // Read the contents of the source map
  var sourceMapData;
  if (reSourceMap.test(sourceMappingURL)) {
    // Support source map URL as a data url
    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);
    sourceMapData = bufferFrom(rawData, "base64").toString();
    sourceMappingURL = source;
  } else {
    // Support source map URLs relative to the source URL
    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);
    sourceMapData = retrieveFile(sourceMappingURL);
  }

  if (!sourceMapData) {
    return null;
  }

  return {
    url: sourceMappingURL,
    map: sourceMapData
  };
});

function mapSourcePosition(position) {
  var sourceMap = sourceMapCache[position.source];
  if (!sourceMap) {
    // Call the (overrideable) retrieveSourceMap function to get the source map.
    var urlAndMap = retrieveSourceMap(position.source);
    if (urlAndMap) {
      sourceMap = sourceMapCache[position.source] = {
        url: urlAndMap.url,
        map: new SourceMapConsumer(urlAndMap.map)
      };

      // Load all sources stored inline with the source map into the file cache
      // to pretend like they are already loaded. They may not exist on disk.
      if (sourceMap.map.sourcesContent) {
        sourceMap.map.sources.forEach(function(source, i) {
          var contents = sourceMap.map.sourcesContent[i];
          if (contents) {
            var url = supportRelativeURL(sourceMap.url, source);
            fileContentsCache[url] = contents;
          }
        });
      }
    } else {
      sourceMap = sourceMapCache[position.source] = {
        url: null,
        map: null
      };
    }
  }

  // Resolve the source URL relative to the URL of the source map
  if (sourceMap && sourceMap.map && typeof sourceMap.map.originalPositionFor === 'function') {
    var originalPosition = sourceMap.map.originalPositionFor(position);

    // Only return the original position if a matching line was found. If no
    // matching line is found then we return position instead, which will cause
    // the stack trace to print the path and line for the compiled file. It is
    // better to give a precise location in the compiled file than a vague
    // location in the original file.
    if (originalPosition.source !== null) {
      originalPosition.source = supportRelativeURL(
        sourceMap.url, originalPosition.source);
      return originalPosition;
    }
  }

  return position;
}

// Parses code generated by FormatEvalOrigin(), a function inside V8:
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js
function mapEvalOrigin(origin) {
  // Most eval() calls are in this format
  var match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
  if (match) {
    var position = mapSourcePosition({
      source: match[2],
      line: +match[3],
      column: match[4] - 1
    });
    return 'eval at ' + match[1] + ' (' + position.source + ':' +
      position.line + ':' + (position.column + 1) + ')';
  }

  // Parse nested eval() calls using recursion
  match = /^eval at ([^(]+) \((.+)\)$/.exec(origin);
  if (match) {
    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';
  }

  // Make sure we still return useful information if we didn't find anything
  return origin;
}

// This is copied almost verbatim from the V8 source code at
// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The
// implementation of wrapCallSite() used to just forward to the actual source
// code of CallSite.prototype.toString but unfortunately a new release of V8
// did something to the prototype chain and broke the shim. The only fix I
// could find was copy/paste.
function CallSiteToString() {
  var fileName;
  var fileLocation = "";
  if (this.isNative()) {
    fileLocation = "native";
  } else {
    fileName = this.getScriptNameOrSourceURL();
    if (!fileName && this.isEval()) {
      fileLocation = this.getEvalOrigin();
      fileLocation += ", ";  // Expecting source position to follow.
    }

    if (fileName) {
      fileLocation += fileName;
    } else {
      // Source code does not originate from a file and is not native, but we
      // can still get the source position inside the source string, e.g. in
      // an eval string.
      fileLocation += "<anonymous>";
    }
    var lineNumber = this.getLineNumber();
    if (lineNumber != null) {
      fileLocation += ":" + lineNumber;
      var columnNumber = this.getColumnNumber();
      if (columnNumber) {
        fileLocation += ":" + columnNumber;
      }
    }
  }

  var line = "";
  var functionName = this.getFunctionName();
  var addSuffix = true;
  var isConstructor = this.isConstructor();
  var isMethodCall = !(this.isToplevel() || isConstructor);
  if (isMethodCall) {
    var typeName = this.getTypeName();
    // Fixes shim to be backward compatable with Node v0 to v4
    if (typeName === "[object Object]") {
      typeName = "null";
    }
    var methodName = this.getMethodName();
    if (functionName) {
      if (typeName && functionName.indexOf(typeName) != 0) {
        line += typeName + ".";
      }
      line += functionName;
      if (methodName && functionName.indexOf("." + methodName) != functionName.length - methodName.length - 1) {
        line += " [as " + methodName + "]";
      }
    } else {
      line += typeName + "." + (methodName || "<anonymous>");
    }
  } else if (isConstructor) {
    line += "new " + (functionName || "<anonymous>");
  } else if (functionName) {
    line += functionName;
  } else {
    line += fileLocation;
    addSuffix = false;
  }
  if (addSuffix) {
    line += " (" + fileLocation + ")";
  }
  return line;
}

function cloneCallSite(frame) {
  var object = {};
  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {
    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];
  });
  object.toString = CallSiteToString;
  return object;
}

function wrapCallSite(frame, state) {
  // provides interface backward compatibility
  if (state === undefined) {
    state = { nextPosition: null, curPosition: null }
  }
  if(frame.isNative()) {
    state.curPosition = null;
    return frame;
  }

  // Most call sites will return the source file from getFileName(), but code
  // passed to eval() ending in "//# sourceURL=..." will return the source file
  // from getScriptNameOrSourceURL() instead
  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();
  if (source) {
    var line = frame.getLineNumber();
    var column = frame.getColumnNumber() - 1;

    // Fix position in Node where some (internal) code is prepended.
    // See https://github.com/evanw/node-source-map-support/issues/36
    // Header removed in node at ^10.16 || >=11.11.0
    // v11 is not an LTS candidate, we can just test the one version with it.
    // Test node versions for: 10.16-19, 10.20+, 12-19, 20-99, 100+, or 11.11
    var noHeader = /^v(10\.1[6-9]|10\.[2-9][0-9]|10\.[0-9]{3,}|1[2-9]\d*|[2-9]\d|\d{3,}|11\.11)/;
    var headerLength = noHeader.test(process.version) ? 0 : 62;
    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {
      column -= headerLength;
    }

    var position = mapSourcePosition({
      source: source,
      line: line,
      column: column
    });
    state.curPosition = position;
    frame = cloneCallSite(frame);
    var originalFunctionName = frame.getFunctionName;
    frame.getFunctionName = function() {
      if (state.nextPosition == null) {
        return originalFunctionName();
      }
      return state.nextPosition.name || originalFunctionName();
    };
    frame.getFileName = function() { return position.source; };
    frame.getLineNumber = function() { return position.line; };
    frame.getColumnNumber = function() { return position.column + 1; };
    frame.getScriptNameOrSourceURL = function() { return position.source; };
    return frame;
  }

  // Code called using eval() needs special handling
  var origin = frame.isEval() && frame.getEvalOrigin();
  if (origin) {
    origin = mapEvalOrigin(origin);
    frame = cloneCallSite(frame);
    frame.getEvalOrigin = function() { return origin; };
    return frame;
  }

  // If we get here then we were unable to change the source position
  return frame;
}

// This function is part of the V8 stack trace API, for more info see:
// https://v8.dev/docs/stack-trace-api
function prepareStackTrace(error, stack) {
  if (emptyCacheBetweenOperations) {
    fileContentsCache = {};
    sourceMapCache = {};
  }

  var name = error.name || 'Error';
  var message = error.message || '';
  var errorString = name + ": " + message;

  var state = { nextPosition: null, curPosition: null };
  var processedStack = [];
  for (var i = stack.length - 1; i >= 0; i--) {
    processedStack.push('\n    at ' + wrapCallSite(stack[i], state));
    state.nextPosition = state.curPosition;
  }
  state.curPosition = state.nextPosition = null;
  return errorString + processedStack.reverse().join('');
}

// Generate position and snippet of original source with pointer
function getErrorSource(error) {
  var match = /\n    at [^(]+ \((.*):(\d+):(\d+)\)/.exec(error.stack);
  if (match) {
    var source = match[1];
    var line = +match[2];
    var column = +match[3];

    // Support the inline sourceContents inside the source map
    var contents = fileContentsCache[source];

    // Support files on disk
    if (!contents && fs && fs.existsSync(source)) {
      try {
        contents = fs.readFileSync(source, 'utf8');
      } catch (er) {
        contents = '';
      }
    }

    // Format the line from the original source code like node does
    if (contents) {
      var code = contents.split(/(?:\r\n|\r|\n)/)[line - 1];
      if (code) {
        return source + ':' + line + '\n' + code + '\n' +
          new Array(column).join(' ') + '^';
      }
    }
  }
  return null;
}

function printErrorAndExit (error) {
  var source = getErrorSource(error);

  // Ensure error is printed synchronously and not truncated
  if (process.stderr._handle && process.stderr._handle.setBlocking) {
    process.stderr._handle.setBlocking(true);
  }

  if (source) {
    console.error();
    console.error(source);
  }

  console.error(error.stack);
  process.exit(1);
}

function shimEmitUncaughtException () {
  var origEmit = process.emit;

  process.emit = function (type) {
    if (type === 'uncaughtException') {
      var hasStack = (arguments[1] && arguments[1].stack);
      var hasListeners = (this.listeners(type).length > 0);

      if (hasStack && !hasListeners) {
        return printErrorAndExit(arguments[1]);
      }
    }

    return origEmit.apply(this, arguments);
  };
}

var originalRetrieveFileHandlers = retrieveFileHandlers.slice(0);
var originalRetrieveMapHandlers = retrieveMapHandlers.slice(0);

exports.wrapCallSite = wrapCallSite;
exports.getErrorSource = getErrorSource;
exports.mapSourcePosition = mapSourcePosition;
exports.retrieveSourceMap = retrieveSourceMap;

exports.install = function(options) {
  options = options || {};

  if (options.environment) {
    environment = options.environment;
    if (["node", "browser", "auto"].indexOf(environment) === -1) {
      throw new Error("environment " + environment + " was unknown. Available options are {auto, browser, node}")
    }
  }

  // Allow sources to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveFile) {
    if (options.overrideRetrieveFile) {
      retrieveFileHandlers.length = 0;
    }

    retrieveFileHandlers.unshift(options.retrieveFile);
  }

  // Allow source maps to be found by methods other than reading the files
  // directly from disk.
  if (options.retrieveSourceMap) {
    if (options.overrideRetrieveSourceMap) {
      retrieveMapHandlers.length = 0;
    }

    retrieveMapHandlers.unshift(options.retrieveSourceMap);
  }

  // Support runtime transpilers that include inline source maps
  if (options.hookRequire && !isInBrowser()) {
    var Module;
    try {
      Module = require('module');
    } catch (err) {
      // NOP: Loading in catch block to convert webpack error to warning.
    }
    var $compile = Module.prototype._compile;

    if (!$compile.__sourceMapSupport) {
      Module.prototype._compile = function(content, filename) {
        fileContentsCache[filename] = content;
        sourceMapCache[filename] = undefined;
        return $compile.call(this, content, filename);
      };

      Module.prototype._compile.__sourceMapSupport = true;
    }
  }

  // Configure options
  if (!emptyCacheBetweenOperations) {
    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?
      options.emptyCacheBetweenOperations : false;
  }

  // Install the error reformatter
  if (!errorFormatterInstalled) {
    errorFormatterInstalled = true;
    Error.prepareStackTrace = prepareStackTrace;
  }

  if (!uncaughtShimInstalled) {
    var installHandler = 'handleUncaughtExceptions' in options ?
      options.handleUncaughtExceptions : true;

    // Provide the option to not install the uncaught exception handler. This is
    // to support other uncaught exception handlers (in test frameworks, for
    // example). If this handler is not installed and there are no other uncaught
    // exception handlers, uncaught exceptions will be caught by node's built-in
    // exception handler and the process will still be terminated. However, the
    // generated JavaScript code will be shown above the stack trace instead of
    // the original source code.
    if (installHandler && hasGlobalProcessEventEmitter()) {
      uncaughtShimInstalled = true;
      shimEmitUncaughtException();
    }
  }
};

exports.resetRetrieveHandlers = function() {
  retrieveFileHandlers.length = 0;
  retrieveMapHandlers.length = 0;

  retrieveFileHandlers = originalRetrieveFileHandlers.slice(0);
  retrieveMapHandlers = originalRetrieveMapHandlers.slice(0);

  retrieveSourceMap = handlerExec(retrieveMapHandlers);
  retrieveFile = handlerExec(retrieveFileHandlers);
}

}).call(this,require('_process'))
},{"_process":22,"buffer-from":14,"fs":13,"module":13,"path":21,"source-map":33}],35:[function(require,module,exports){
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{}]},{},[1])(1)
});

if (typeof CoffeeScript !== 'undefined') { root.CoffeeScript = CoffeeScript; }
})(this);